// Generated by dts-bundle-generator v6.12.0

import { DirectSecp256k1HdWallet } from '@cosmjs/proto-signing';
import { DirectSecp256k1HdWalletOptions } from '@cosmjs/proto-signing/build/directsecp256k1hdwallet';
import { AccountData, DirectSignResponse, OfflineDirectSigner } from '@cosmjs/proto-signing/build/signer';
import { DeliverTxResponse, SequenceResponse, SigningStargateClient } from '@cosmjs/stargate';
import { SigningStargateClientOptions } from '@cosmjs/stargate/build/signingstargateclient';
import { Tendermint34Client } from '@cosmjs/tendermint-rpc';

export interface QueryHasContentRequest {
	cid: string;
}
export interface QueryHasContentResponse {
	hasContent: boolean;
}
declare const QueryHasContentRequest: {
	encode(message: QueryHasContentRequest, writer?: _m0.Writer): _m0.Writer;
	decode(input: _m0.Reader | Uint8Array, length?: number): QueryHasContentRequest;
	fromJSON(object: any): QueryHasContentRequest;
	toJSON(message: QueryHasContentRequest): unknown;
	fromPartial<I extends {
		cid?: string;
	} & {
		cid?: string;
	} & Record<Exclude<keyof I, "cid">, never>>(object: I): QueryHasContentRequest;
};
declare const QueryHasContentResponse: {
	encode(message: QueryHasContentResponse, writer?: _m0.Writer): _m0.Writer;
	decode(input: _m0.Reader | Uint8Array, length?: number): QueryHasContentResponse;
	fromJSON(object: any): QueryHasContentResponse;
	toJSON(message: QueryHasContentResponse): unknown;
	fromPartial<I extends {
		hasContent?: boolean;
	} & {
		hasContent?: boolean;
	} & Record<Exclude<keyof I, "hasContent">, never>>(object: I): QueryHasContentResponse;
};
/** Query defines the gRPC querier service. */
export interface Query {
	HasContent(request: QueryHasContentRequest): Promise<QueryHasContentResponse>;
}
declare class QueryClientImpl implements Query {
	private readonly rpc;
	constructor(rpc: Rpc);
	HasContent(request: QueryHasContentRequest): Promise<QueryHasContentResponse>;
}
export interface Rpc {
	request(service: string, method: string, data: Uint8Array): Promise<Uint8Array>;
}
/**
 * Coin defines a token with a denomination and an amount.
 *
 * NOTE: The amount field is an Int which implements the custom method
 * signatures required by gogoproto.
 */
export interface Coin {
	denom: string;
	amount: string;
}
/**
 * DecCoin defines a token with a denomination and a decimal amount.
 *
 * NOTE: The amount field is an Dec which implements the custom method
 * signatures required by gogoproto.
 */
export interface DecCoin {
	denom: string;
	amount: string;
}
declare const Coin: {
	encode(message: Coin, writer?: _m0.Writer): _m0.Writer;
	decode(input: _m0.Reader | Uint8Array, length?: number): Coin;
	fromJSON(object: any): Coin;
	toJSON(message: Coin): unknown;
	fromPartial<I extends {
		denom?: string;
		amount?: string;
	} & {
		denom?: string;
		amount?: string;
	} & Record<Exclude<keyof I, keyof Coin>, never>>(object: I): Coin;
};
declare const DecCoin: {
	encode(message: DecCoin, writer?: _m0.Writer): _m0.Writer;
	decode(input: _m0.Reader | Uint8Array, length?: number): DecCoin;
	fromJSON(object: any): DecCoin;
	toJSON(message: DecCoin): unknown;
	fromPartial<I extends {
		denom?: string;
		amount?: string;
	} & {
		denom?: string;
		amount?: string;
	} & Record<Exclude<keyof I, keyof DecCoin>, never>>(object: I): DecCoin;
};
/**
 * PageRequest is to be embedded in gRPC request messages for efficient
 * pagination. Ex:
 *
 *  message SomeRequest {
 *          Foo some_parameter = 1;
 *          PageRequest pagination = 2;
 *  }
 */
export interface PageRequest {
	/**
	 * key is a value returned in PageResponse.next_key to begin
	 * querying the next page most efficiently. Only one of offset or key
	 * should be set.
	 */
	key: Uint8Array;
	/**
	 * offset is a numeric offset that can be used when key is unavailable.
	 * It is less efficient than using key. Only one of offset or key should
	 * be set.
	 */
	offset: Long;
	/**
	 * limit is the total number of results to be returned in the result page.
	 * If left empty it will default to a value to be set by each app.
	 */
	limit: Long;
	/**
	 * count_total is set to true  to indicate that the result set should include
	 * a count of the total number of items available for pagination in UIs.
	 * count_total is only respected when offset is used. It is ignored when key
	 * is set.
	 */
	countTotal: boolean;
	/** reverse is set to true if results are to be returned in the descending order. */
	reverse: boolean;
}
/**
 * PageResponse is to be embedded in gRPC response messages where the
 * corresponding request message has used PageRequest.
 *
 *  message SomeResponse {
 *          repeated Bar results = 1;
 *          PageResponse page = 2;
 *  }
 */
export interface PageResponse {
	/**
	 * next_key is the key to be passed to PageRequest.key to
	 * query the next page most efficiently
	 */
	nextKey: Uint8Array;
	/**
	 * total is total number of results available if PageRequest.count_total
	 * was set, its value is undefined otherwise
	 */
	total: Long;
}
declare const PageRequest: {
	encode(message: PageRequest, writer?: _m0.Writer): _m0.Writer;
	decode(input: _m0.Reader | Uint8Array, length?: number): PageRequest;
	fromJSON(object: any): PageRequest;
	toJSON(message: PageRequest): unknown;
	fromPartial<I extends {
		key?: Uint8Array;
		offset?: string | number | Long.Long;
		limit?: string | number | Long.Long;
		countTotal?: boolean;
		reverse?: boolean;
	} & {
		key?: Uint8Array;
		offset?: string | number | (Long.Long & {
			high: number;
			low: number;
			unsigned: boolean;
			add: (addend: string | number | Long.Long) => Long.Long;
			and: (other: string | number | Long.Long) => Long.Long;
			compare: (other: string | number | Long.Long) => number;
			comp: (other: string | number | Long.Long) => number;
			divide: (divisor: string | number | Long.Long) => Long.Long;
			div: (divisor: string | number | Long.Long) => Long.Long;
			equals: (other: string | number | Long.Long) => boolean;
			eq: (other: string | number | Long.Long) => boolean;
			getHighBits: () => number;
			getHighBitsUnsigned: () => number;
			getLowBits: () => number;
			getLowBitsUnsigned: () => number;
			getNumBitsAbs: () => number;
			greaterThan: (other: string | number | Long.Long) => boolean;
			gt: (other: string | number | Long.Long) => boolean;
			greaterThanOrEqual: (other: string | number | Long.Long) => boolean;
			gte: (other: string | number | Long.Long) => boolean;
			isEven: () => boolean;
			isNegative: () => boolean;
			isOdd: () => boolean;
			isPositive: () => boolean;
			isZero: () => boolean;
			lessThan: (other: string | number | Long.Long) => boolean;
			lt: (other: string | number | Long.Long) => boolean;
			lessThanOrEqual: (other: string | number | Long.Long) => boolean;
			lte: (other: string | number | Long.Long) => boolean;
			modulo: (other: string | number | Long.Long) => Long.Long;
			mod: (other: string | number | Long.Long) => Long.Long;
			multiply: (multiplier: string | number | Long.Long) => Long.Long;
			mul: (multiplier: string | number | Long.Long) => Long.Long;
			negate: () => Long.Long;
			neg: () => Long.Long;
			not: () => Long.Long;
			notEquals: (other: string | number | Long.Long) => boolean;
			neq: (other: string | number | Long.Long) => boolean;
			or: (other: string | number | Long.Long) => Long.Long;
			shiftLeft: (numBits: number | Long.Long) => Long.Long;
			shl: (numBits: number | Long.Long) => Long.Long;
			shiftRight: (numBits: number | Long.Long) => Long.Long;
			shr: (numBits: number | Long.Long) => Long.Long;
			shiftRightUnsigned: (numBits: number | Long.Long) => Long.Long;
			shru: (numBits: number | Long.Long) => Long.Long;
			subtract: (subtrahend: string | number | Long.Long) => Long.Long;
			sub: (subtrahend: string | number | Long.Long) => Long.Long;
			toInt: () => number;
			toNumber: () => number;
			toBytes: (le?: boolean) => number[];
			toBytesLE: () => number[];
			toBytesBE: () => number[];
			toSigned: () => Long.Long;
			toString: (radix?: number) => string;
			toUnsigned: () => Long.Long;
			xor: (other: string | number | Long.Long) => Long.Long;
		} & Record<Exclude<keyof I["offset"], keyof Long.Long>, never>);
		limit?: string | number | (Long.Long & {
			high: number;
			low: number;
			unsigned: boolean;
			add: (addend: string | number | Long.Long) => Long.Long;
			and: (other: string | number | Long.Long) => Long.Long;
			compare: (other: string | number | Long.Long) => number;
			comp: (other: string | number | Long.Long) => number;
			divide: (divisor: string | number | Long.Long) => Long.Long;
			div: (divisor: string | number | Long.Long) => Long.Long;
			equals: (other: string | number | Long.Long) => boolean;
			eq: (other: string | number | Long.Long) => boolean;
			getHighBits: () => number;
			getHighBitsUnsigned: () => number;
			getLowBits: () => number;
			getLowBitsUnsigned: () => number;
			getNumBitsAbs: () => number;
			greaterThan: (other: string | number | Long.Long) => boolean;
			gt: (other: string | number | Long.Long) => boolean;
			greaterThanOrEqual: (other: string | number | Long.Long) => boolean;
			gte: (other: string | number | Long.Long) => boolean;
			isEven: () => boolean;
			isNegative: () => boolean;
			isOdd: () => boolean;
			isPositive: () => boolean;
			isZero: () => boolean;
			lessThan: (other: string | number | Long.Long) => boolean;
			lt: (other: string | number | Long.Long) => boolean;
			lessThanOrEqual: (other: string | number | Long.Long) => boolean;
			lte: (other: string | number | Long.Long) => boolean;
			modulo: (other: string | number | Long.Long) => Long.Long;
			mod: (other: string | number | Long.Long) => Long.Long;
			multiply: (multiplier: string | number | Long.Long) => Long.Long;
			mul: (multiplier: string | number | Long.Long) => Long.Long;
			negate: () => Long.Long;
			neg: () => Long.Long;
			not: () => Long.Long;
			notEquals: (other: string | number | Long.Long) => boolean;
			neq: (other: string | number | Long.Long) => boolean;
			or: (other: string | number | Long.Long) => Long.Long;
			shiftLeft: (numBits: number | Long.Long) => Long.Long;
			shl: (numBits: number | Long.Long) => Long.Long;
			shiftRight: (numBits: number | Long.Long) => Long.Long;
			shr: (numBits: number | Long.Long) => Long.Long;
			shiftRightUnsigned: (numBits: number | Long.Long) => Long.Long;
			shru: (numBits: number | Long.Long) => Long.Long;
			subtract: (subtrahend: string | number | Long.Long) => Long.Long;
			sub: (subtrahend: string | number | Long.Long) => Long.Long;
			toInt: () => number;
			toNumber: () => number;
			toBytes: (le?: boolean) => number[];
			toBytesLE: () => number[];
			toBytesBE: () => number[];
			toSigned: () => Long.Long;
			toString: (radix?: number) => string;
			toUnsigned: () => Long.Long;
			xor: (other: string | number | Long.Long) => Long.Long;
		} & Record<Exclude<keyof I["limit"], keyof Long.Long>, never>);
		countTotal?: boolean;
		reverse?: boolean;
	} & Record<Exclude<keyof I, keyof PageRequest>, never>>(object: I): PageRequest;
};
declare const PageResponse: {
	encode(message: PageResponse, writer?: _m0.Writer): _m0.Writer;
	decode(input: _m0.Reader | Uint8Array, length?: number): PageResponse;
	fromJSON(object: any): PageResponse;
	toJSON(message: PageResponse): unknown;
	fromPartial<I extends {
		nextKey?: Uint8Array;
		total?: string | number | Long.Long;
	} & {
		nextKey?: Uint8Array;
		total?: string | number | (Long.Long & {
			high: number;
			low: number;
			unsigned: boolean;
			add: (addend: string | number | Long.Long) => Long.Long;
			and: (other: string | number | Long.Long) => Long.Long;
			compare: (other: string | number | Long.Long) => number;
			comp: (other: string | number | Long.Long) => number;
			divide: (divisor: string | number | Long.Long) => Long.Long;
			div: (divisor: string | number | Long.Long) => Long.Long;
			equals: (other: string | number | Long.Long) => boolean;
			eq: (other: string | number | Long.Long) => boolean;
			getHighBits: () => number;
			getHighBitsUnsigned: () => number;
			getLowBits: () => number;
			getLowBitsUnsigned: () => number;
			getNumBitsAbs: () => number;
			greaterThan: (other: string | number | Long.Long) => boolean;
			gt: (other: string | number | Long.Long) => boolean;
			greaterThanOrEqual: (other: string | number | Long.Long) => boolean;
			gte: (other: string | number | Long.Long) => boolean;
			isEven: () => boolean;
			isNegative: () => boolean;
			isOdd: () => boolean;
			isPositive: () => boolean;
			isZero: () => boolean;
			lessThan: (other: string | number | Long.Long) => boolean;
			lt: (other: string | number | Long.Long) => boolean;
			lessThanOrEqual: (other: string | number | Long.Long) => boolean;
			lte: (other: string | number | Long.Long) => boolean;
			modulo: (other: string | number | Long.Long) => Long.Long;
			mod: (other: string | number | Long.Long) => Long.Long;
			multiply: (multiplier: string | number | Long.Long) => Long.Long;
			mul: (multiplier: string | number | Long.Long) => Long.Long;
			negate: () => Long.Long;
			neg: () => Long.Long;
			not: () => Long.Long;
			notEquals: (other: string | number | Long.Long) => boolean;
			neq: (other: string | number | Long.Long) => boolean;
			or: (other: string | number | Long.Long) => Long.Long;
			shiftLeft: (numBits: number | Long.Long) => Long.Long;
			shl: (numBits: number | Long.Long) => Long.Long;
			shiftRight: (numBits: number | Long.Long) => Long.Long;
			shr: (numBits: number | Long.Long) => Long.Long;
			shiftRightUnsigned: (numBits: number | Long.Long) => Long.Long;
			shru: (numBits: number | Long.Long) => Long.Long;
			subtract: (subtrahend: string | number | Long.Long) => Long.Long;
			sub: (subtrahend: string | number | Long.Long) => Long.Long;
			toInt: () => number;
			toNumber: () => number;
			toBytes: (le?: boolean) => number[];
			toBytesLE: () => number[];
			toBytesBE: () => number[];
			toSigned: () => Long.Long;
			toString: (radix?: number) => string;
			toUnsigned: () => Long.Long;
			xor: (other: string | number | Long.Long) => Long.Long;
		} & Record<Exclude<keyof I["total"], keyof Long.Long>, never>);
	} & Record<Exclude<keyof I, keyof PageResponse>, never>>(object: I): PageResponse;
};
/** Params defines the parameters for the bank module. */
export interface Params {
	sendEnabled: SendEnabled[];
	defaultSendEnabled: boolean;
}
/**
 * SendEnabled maps coin denom to a send_enabled status (whether a denom is
 * sendable).
 */
export interface SendEnabled {
	denom: string;
	enabled: boolean;
}
/**
 * DenomUnit represents a struct that describes a given
 * denomination unit of the basic token.
 */
export interface DenomUnit {
	/** denom represents the string name of the given denom unit (e.g uatom). */
	denom: string;
	/**
	 * exponent represents power of 10 exponent that one must
	 * raise the base_denom to in order to equal the given DenomUnit's denom
	 * 1 denom = 1^exponent base_denom
	 * (e.g. with a base_denom of uatom, one can create a DenomUnit of 'atom' with
	 * exponent = 6, thus: 1 atom = 10^6 uatom).
	 */
	exponent: number;
	/** aliases is a list of string aliases for the given denom */
	aliases: string[];
}
/**
 * Metadata represents a struct that describes
 * a basic token.
 */
export interface Metadata {
	description: string;
	/** denom_units represents the list of DenomUnit's for a given coin */
	denomUnits: DenomUnit[];
	/** base represents the base denom (should be the DenomUnit with exponent = 0). */
	base: string;
	/**
	 * display indicates the suggested denom that should be
	 * displayed in clients.
	 */
	display: string;
	/** name defines the name of the token (eg: Cosmos Atom) */
	name: string;
	/**
	 * symbol is the token symbol usually shown on exchanges (eg: ATOM). This can
	 * be the same as the display.
	 */
	symbol: string;
}
declare const Params: {
	encode(message: Params, writer?: _m0.Writer): _m0.Writer;
	decode(input: _m0.Reader | Uint8Array, length?: number): Params;
	fromJSON(object: any): Params;
	toJSON(message: Params): unknown;
	fromPartial<I extends {
		sendEnabled?: {
			denom?: string;
			enabled?: boolean;
		}[];
		defaultSendEnabled?: boolean;
	} & {
		sendEnabled?: {
			denom?: string;
			enabled?: boolean;
		}[] & ({
			denom?: string;
			enabled?: boolean;
		} & {
			denom?: string;
			enabled?: boolean;
		} & Record<Exclude<keyof I["sendEnabled"][number], keyof SendEnabled>, never>)[] & Record<Exclude<keyof I["sendEnabled"], keyof {
			denom?: string;
			enabled?: boolean;
		}[]>, never>;
		defaultSendEnabled?: boolean;
	} & Record<Exclude<keyof I, keyof Params>, never>>(object: I): Params;
};
declare const SendEnabled: {
	encode(message: SendEnabled, writer?: _m0.Writer): _m0.Writer;
	decode(input: _m0.Reader | Uint8Array, length?: number): SendEnabled;
	fromJSON(object: any): SendEnabled;
	toJSON(message: SendEnabled): unknown;
	fromPartial<I extends {
		denom?: string;
		enabled?: boolean;
	} & {
		denom?: string;
		enabled?: boolean;
	} & Record<Exclude<keyof I, keyof SendEnabled>, never>>(object: I): SendEnabled;
};
declare const DenomUnit: {
	encode(message: DenomUnit, writer?: _m0.Writer): _m0.Writer;
	decode(input: _m0.Reader | Uint8Array, length?: number): DenomUnit;
	fromJSON(object: any): DenomUnit;
	toJSON(message: DenomUnit): unknown;
	fromPartial<I extends {
		denom?: string;
		exponent?: number;
		aliases?: string[];
	} & {
		denom?: string;
		exponent?: number;
		aliases?: string[] & string[] & Record<Exclude<keyof I["aliases"], keyof string[]>, never>;
	} & Record<Exclude<keyof I, keyof DenomUnit>, never>>(object: I): DenomUnit;
};
declare const Metadata: {
	encode(message: Metadata, writer?: _m0.Writer): _m0.Writer;
	decode(input: _m0.Reader | Uint8Array, length?: number): Metadata;
	fromJSON(object: any): Metadata;
	toJSON(message: Metadata): unknown;
	fromPartial<I extends {
		description?: string;
		denomUnits?: {
			denom?: string;
			exponent?: number;
			aliases?: string[];
		}[];
		base?: string;
		display?: string;
		name?: string;
		symbol?: string;
	} & {
		description?: string;
		denomUnits?: {
			denom?: string;
			exponent?: number;
			aliases?: string[];
		}[] & ({
			denom?: string;
			exponent?: number;
			aliases?: string[];
		} & {
			denom?: string;
			exponent?: number;
			aliases?: string[] & string[] & Record<Exclude<keyof I["denomUnits"][number]["aliases"], keyof string[]>, never>;
		} & Record<Exclude<keyof I["denomUnits"][number], keyof DenomUnit>, never>)[] & Record<Exclude<keyof I["denomUnits"], keyof {
			denom?: string;
			exponent?: number;
			aliases?: string[];
		}[]>, never>;
		base?: string;
		display?: string;
		name?: string;
		symbol?: string;
	} & Record<Exclude<keyof I, keyof Metadata>, never>>(object: I): Metadata;
};
/** QueryBalanceRequest is the request type for the Query/Balance RPC method. */
export interface QueryBalanceRequest {
	/** address is the address to query balances for. */
	address: string;
	/** denom is the coin denom to query balances for. */
	denom: string;
}
/** QueryBalanceResponse is the response type for the Query/Balance RPC method. */
export interface QueryBalanceResponse {
	/** balance is the balance of the coin. */
	balance?: Coin;
}
/** QueryBalanceRequest is the request type for the Query/AllBalances RPC method. */
export interface QueryAllBalancesRequest {
	/** address is the address to query balances for. */
	address: string;
	/** pagination defines an optional pagination for the request. */
	pagination?: PageRequest;
}
/**
 * QueryAllBalancesResponse is the response type for the Query/AllBalances RPC
 * method.
 */
export interface QueryAllBalancesResponse {
	/** balances is the balances of all the coins. */
	balances: Coin[];
	/** pagination defines the pagination in the response. */
	pagination?: PageResponse;
}
/**
 * QueryTotalSupplyRequest is the request type for the Query/TotalSupply RPC
 * method.
 */
export interface QueryTotalSupplyRequest {
	/** pagination defines an optional pagination for the request. */
	pagination?: PageRequest;
}
/**
 * QueryTotalSupplyResponse is the response type for the Query/TotalSupply RPC
 * method
 */
export interface QueryTotalSupplyResponse {
	/** supply is the supply of the coins */
	supply: Coin[];
	/** pagination defines the pagination in the response. */
	pagination?: PageResponse;
}
/** QuerySupplyOfRequest is the request type for the Query/SupplyOf RPC method. */
export interface QuerySupplyOfRequest {
	/** denom is the coin denom to query balances for. */
	denom: string;
}
/** QuerySupplyOfResponse is the response type for the Query/SupplyOf RPC method. */
export interface QuerySupplyOfResponse {
	/** amount is the supply of the coin. */
	amount?: Coin;
}
/** QueryParamsRequest defines the request type for querying x/bank parameters. */
export interface QueryParamsRequest {
}
/** QueryParamsResponse defines the response type for querying x/bank parameters. */
export interface QueryParamsResponse {
	params?: Params;
}
/** QueryDenomsMetadataRequest is the request type for the Query/DenomsMetadata RPC method. */
export interface QueryDenomsMetadataRequest {
	/** pagination defines an optional pagination for the request. */
	pagination?: PageRequest;
}
/**
 * QueryDenomsMetadataResponse is the response type for the Query/DenomsMetadata RPC
 * method.
 */
export interface QueryDenomsMetadataResponse {
	/** metadata provides the client information for all the registered tokens. */
	metadatas: Metadata[];
	/** pagination defines the pagination in the response. */
	pagination?: PageResponse;
}
/** QueryDenomMetadataRequest is the request type for the Query/DenomMetadata RPC method. */
export interface QueryDenomMetadataRequest {
	/** denom is the coin denom to query the metadata for. */
	denom: string;
}
/**
 * QueryDenomMetadataResponse is the response type for the Query/DenomMetadata RPC
 * method.
 */
export interface QueryDenomMetadataResponse {
	/** metadata describes and provides all the client information for the requested token. */
	metadata?: Metadata;
}
declare const QueryBalanceRequest: {
	encode(message: QueryBalanceRequest, writer?: _m0.Writer): _m0.Writer;
	decode(input: _m0.Reader | Uint8Array, length?: number): QueryBalanceRequest;
	fromJSON(object: any): QueryBalanceRequest;
	toJSON(message: QueryBalanceRequest): unknown;
	fromPartial<I extends {
		address?: string;
		denom?: string;
	} & {
		address?: string;
		denom?: string;
	} & Record<Exclude<keyof I, keyof QueryBalanceRequest>, never>>(object: I): QueryBalanceRequest;
};
declare const QueryBalanceResponse: {
	encode(message: QueryBalanceResponse, writer?: _m0.Writer): _m0.Writer;
	decode(input: _m0.Reader | Uint8Array, length?: number): QueryBalanceResponse;
	fromJSON(object: any): QueryBalanceResponse;
	toJSON(message: QueryBalanceResponse): unknown;
	fromPartial<I extends {
		balance?: {
			denom?: string;
			amount?: string;
		};
	} & {
		balance?: {
			denom?: string;
			amount?: string;
		} & {
			denom?: string;
			amount?: string;
		} & Record<Exclude<keyof I["balance"], keyof Coin>, never>;
	} & Record<Exclude<keyof I, "balance">, never>>(object: I): QueryBalanceResponse;
};
declare const QueryAllBalancesRequest: {
	encode(message: QueryAllBalancesRequest, writer?: _m0.Writer): _m0.Writer;
	decode(input: _m0.Reader | Uint8Array, length?: number): QueryAllBalancesRequest;
	fromJSON(object: any): QueryAllBalancesRequest;
	toJSON(message: QueryAllBalancesRequest): unknown;
	fromPartial<I extends {
		address?: string;
		pagination?: {
			key?: Uint8Array;
			offset?: string | number | Long.Long;
			limit?: string | number | Long.Long;
			countTotal?: boolean;
			reverse?: boolean;
		};
	} & {
		address?: string;
		pagination?: {
			key?: Uint8Array;
			offset?: string | number | Long.Long;
			limit?: string | number | Long.Long;
			countTotal?: boolean;
			reverse?: boolean;
		} & {
			key?: Uint8Array;
			offset?: string | number | (Long.Long & {
				high: number;
				low: number;
				unsigned: boolean;
				add: (addend: string | number | Long.Long) => Long.Long;
				and: (other: string | number | Long.Long) => Long.Long;
				compare: (other: string | number | Long.Long) => number;
				comp: (other: string | number | Long.Long) => number;
				divide: (divisor: string | number | Long.Long) => Long.Long;
				div: (divisor: string | number | Long.Long) => Long.Long;
				equals: (other: string | number | Long.Long) => boolean;
				eq: (other: string | number | Long.Long) => boolean;
				getHighBits: () => number;
				getHighBitsUnsigned: () => number;
				getLowBits: () => number;
				getLowBitsUnsigned: () => number;
				getNumBitsAbs: () => number;
				greaterThan: (other: string | number | Long.Long) => boolean;
				gt: (other: string | number | Long.Long) => boolean;
				greaterThanOrEqual: (other: string | number | Long.Long) => boolean;
				gte: (other: string | number | Long.Long) => boolean;
				isEven: () => boolean;
				isNegative: () => boolean;
				isOdd: () => boolean;
				isPositive: () => boolean;
				isZero: () => boolean;
				lessThan: (other: string | number | Long.Long) => boolean;
				lt: (other: string | number | Long.Long) => boolean;
				lessThanOrEqual: (other: string | number | Long.Long) => boolean;
				lte: (other: string | number | Long.Long) => boolean;
				modulo: (other: string | number | Long.Long) => Long.Long;
				mod: (other: string | number | Long.Long) => Long.Long;
				multiply: (multiplier: string | number | Long.Long) => Long.Long;
				mul: (multiplier: string | number | Long.Long) => Long.Long;
				negate: () => Long.Long;
				neg: () => Long.Long;
				not: () => Long.Long;
				notEquals: (other: string | number | Long.Long) => boolean;
				neq: (other: string | number | Long.Long) => boolean;
				or: (other: string | number | Long.Long) => Long.Long;
				shiftLeft: (numBits: number | Long.Long) => Long.Long;
				shl: (numBits: number | Long.Long) => Long.Long;
				shiftRight: (numBits: number | Long.Long) => Long.Long;
				shr: (numBits: number | Long.Long) => Long.Long;
				shiftRightUnsigned: (numBits: number | Long.Long) => Long.Long;
				shru: (numBits: number | Long.Long) => Long.Long;
				subtract: (subtrahend: string | number | Long.Long) => Long.Long;
				sub: (subtrahend: string | number | Long.Long) => Long.Long;
				toInt: () => number;
				toNumber: () => number;
				toBytes: (le?: boolean) => number[];
				toBytesLE: () => number[];
				toBytesBE: () => number[];
				toSigned: () => Long.Long;
				toString: (radix?: number) => string;
				toUnsigned: () => Long.Long;
				xor: (other: string | number | Long.Long) => Long.Long;
			} & Record<Exclude<keyof I["pagination"]["offset"], keyof Long.Long>, never>);
			limit?: string | number | (Long.Long & {
				high: number;
				low: number;
				unsigned: boolean;
				add: (addend: string | number | Long.Long) => Long.Long;
				and: (other: string | number | Long.Long) => Long.Long;
				compare: (other: string | number | Long.Long) => number;
				comp: (other: string | number | Long.Long) => number;
				divide: (divisor: string | number | Long.Long) => Long.Long;
				div: (divisor: string | number | Long.Long) => Long.Long;
				equals: (other: string | number | Long.Long) => boolean;
				eq: (other: string | number | Long.Long) => boolean;
				getHighBits: () => number;
				getHighBitsUnsigned: () => number;
				getLowBits: () => number;
				getLowBitsUnsigned: () => number;
				getNumBitsAbs: () => number;
				greaterThan: (other: string | number | Long.Long) => boolean;
				gt: (other: string | number | Long.Long) => boolean;
				greaterThanOrEqual: (other: string | number | Long.Long) => boolean;
				gte: (other: string | number | Long.Long) => boolean;
				isEven: () => boolean;
				isNegative: () => boolean;
				isOdd: () => boolean;
				isPositive: () => boolean;
				isZero: () => boolean;
				lessThan: (other: string | number | Long.Long) => boolean;
				lt: (other: string | number | Long.Long) => boolean;
				lessThanOrEqual: (other: string | number | Long.Long) => boolean;
				lte: (other: string | number | Long.Long) => boolean;
				modulo: (other: string | number | Long.Long) => Long.Long;
				mod: (other: string | number | Long.Long) => Long.Long;
				multiply: (multiplier: string | number | Long.Long) => Long.Long;
				mul: (multiplier: string | number | Long.Long) => Long.Long;
				negate: () => Long.Long;
				neg: () => Long.Long;
				not: () => Long.Long;
				notEquals: (other: string | number | Long.Long) => boolean;
				neq: (other: string | number | Long.Long) => boolean;
				or: (other: string | number | Long.Long) => Long.Long;
				shiftLeft: (numBits: number | Long.Long) => Long.Long;
				shl: (numBits: number | Long.Long) => Long.Long;
				shiftRight: (numBits: number | Long.Long) => Long.Long;
				shr: (numBits: number | Long.Long) => Long.Long;
				shiftRightUnsigned: (numBits: number | Long.Long) => Long.Long;
				shru: (numBits: number | Long.Long) => Long.Long;
				subtract: (subtrahend: string | number | Long.Long) => Long.Long;
				sub: (subtrahend: string | number | Long.Long) => Long.Long;
				toInt: () => number;
				toNumber: () => number;
				toBytes: (le?: boolean) => number[];
				toBytesLE: () => number[];
				toBytesBE: () => number[];
				toSigned: () => Long.Long;
				toString: (radix?: number) => string;
				toUnsigned: () => Long.Long;
				xor: (other: string | number | Long.Long) => Long.Long;
			} & Record<Exclude<keyof I["pagination"]["limit"], keyof Long.Long>, never>);
			countTotal?: boolean;
			reverse?: boolean;
		} & Record<Exclude<keyof I["pagination"], keyof PageRequest>, never>;
	} & Record<Exclude<keyof I, keyof QueryAllBalancesRequest>, never>>(object: I): QueryAllBalancesRequest;
};
declare const QueryAllBalancesResponse: {
	encode(message: QueryAllBalancesResponse, writer?: _m0.Writer): _m0.Writer;
	decode(input: _m0.Reader | Uint8Array, length?: number): QueryAllBalancesResponse;
	fromJSON(object: any): QueryAllBalancesResponse;
	toJSON(message: QueryAllBalancesResponse): unknown;
	fromPartial<I extends {
		balances?: {
			denom?: string;
			amount?: string;
		}[];
		pagination?: {
			nextKey?: Uint8Array;
			total?: string | number | Long.Long;
		};
	} & {
		balances?: {
			denom?: string;
			amount?: string;
		}[] & ({
			denom?: string;
			amount?: string;
		} & {
			denom?: string;
			amount?: string;
		} & Record<Exclude<keyof I["balances"][number], keyof Coin>, never>)[] & Record<Exclude<keyof I["balances"], keyof {
			denom?: string;
			amount?: string;
		}[]>, never>;
		pagination?: {
			nextKey?: Uint8Array;
			total?: string | number | Long.Long;
		} & {
			nextKey?: Uint8Array;
			total?: string | number | (Long.Long & {
				high: number;
				low: number;
				unsigned: boolean;
				add: (addend: string | number | Long.Long) => Long.Long;
				and: (other: string | number | Long.Long) => Long.Long;
				compare: (other: string | number | Long.Long) => number;
				comp: (other: string | number | Long.Long) => number;
				divide: (divisor: string | number | Long.Long) => Long.Long;
				div: (divisor: string | number | Long.Long) => Long.Long;
				equals: (other: string | number | Long.Long) => boolean;
				eq: (other: string | number | Long.Long) => boolean;
				getHighBits: () => number;
				getHighBitsUnsigned: () => number;
				getLowBits: () => number;
				getLowBitsUnsigned: () => number;
				getNumBitsAbs: () => number;
				greaterThan: (other: string | number | Long.Long) => boolean;
				gt: (other: string | number | Long.Long) => boolean;
				greaterThanOrEqual: (other: string | number | Long.Long) => boolean;
				gte: (other: string | number | Long.Long) => boolean;
				isEven: () => boolean;
				isNegative: () => boolean;
				isOdd: () => boolean;
				isPositive: () => boolean;
				isZero: () => boolean;
				lessThan: (other: string | number | Long.Long) => boolean;
				lt: (other: string | number | Long.Long) => boolean;
				lessThanOrEqual: (other: string | number | Long.Long) => boolean;
				lte: (other: string | number | Long.Long) => boolean;
				modulo: (other: string | number | Long.Long) => Long.Long;
				mod: (other: string | number | Long.Long) => Long.Long;
				multiply: (multiplier: string | number | Long.Long) => Long.Long;
				mul: (multiplier: string | number | Long.Long) => Long.Long;
				negate: () => Long.Long;
				neg: () => Long.Long;
				not: () => Long.Long;
				notEquals: (other: string | number | Long.Long) => boolean;
				neq: (other: string | number | Long.Long) => boolean;
				or: (other: string | number | Long.Long) => Long.Long;
				shiftLeft: (numBits: number | Long.Long) => Long.Long;
				shl: (numBits: number | Long.Long) => Long.Long;
				shiftRight: (numBits: number | Long.Long) => Long.Long;
				shr: (numBits: number | Long.Long) => Long.Long;
				shiftRightUnsigned: (numBits: number | Long.Long) => Long.Long;
				shru: (numBits: number | Long.Long) => Long.Long;
				subtract: (subtrahend: string | number | Long.Long) => Long.Long;
				sub: (subtrahend: string | number | Long.Long) => Long.Long;
				toInt: () => number;
				toNumber: () => number;
				toBytes: (le?: boolean) => number[];
				toBytesLE: () => number[];
				toBytesBE: () => number[];
				toSigned: () => Long.Long;
				toString: (radix?: number) => string;
				toUnsigned: () => Long.Long;
				xor: (other: string | number | Long.Long) => Long.Long;
			} & Record<Exclude<keyof I["pagination"]["total"], keyof Long.Long>, never>);
		} & Record<Exclude<keyof I["pagination"], keyof PageResponse>, never>;
	} & Record<Exclude<keyof I, keyof QueryAllBalancesResponse>, never>>(object: I): QueryAllBalancesResponse;
};
declare const QueryTotalSupplyRequest: {
	encode(message: QueryTotalSupplyRequest, writer?: _m0.Writer): _m0.Writer;
	decode(input: _m0.Reader | Uint8Array, length?: number): QueryTotalSupplyRequest;
	fromJSON(object: any): QueryTotalSupplyRequest;
	toJSON(message: QueryTotalSupplyRequest): unknown;
	fromPartial<I extends {
		pagination?: {
			key?: Uint8Array;
			offset?: string | number | Long.Long;
			limit?: string | number | Long.Long;
			countTotal?: boolean;
			reverse?: boolean;
		};
	} & {
		pagination?: {
			key?: Uint8Array;
			offset?: string | number | Long.Long;
			limit?: string | number | Long.Long;
			countTotal?: boolean;
			reverse?: boolean;
		} & {
			key?: Uint8Array;
			offset?: string | number | (Long.Long & {
				high: number;
				low: number;
				unsigned: boolean;
				add: (addend: string | number | Long.Long) => Long.Long;
				and: (other: string | number | Long.Long) => Long.Long;
				compare: (other: string | number | Long.Long) => number;
				comp: (other: string | number | Long.Long) => number;
				divide: (divisor: string | number | Long.Long) => Long.Long;
				div: (divisor: string | number | Long.Long) => Long.Long;
				equals: (other: string | number | Long.Long) => boolean;
				eq: (other: string | number | Long.Long) => boolean;
				getHighBits: () => number;
				getHighBitsUnsigned: () => number;
				getLowBits: () => number;
				getLowBitsUnsigned: () => number;
				getNumBitsAbs: () => number;
				greaterThan: (other: string | number | Long.Long) => boolean;
				gt: (other: string | number | Long.Long) => boolean;
				greaterThanOrEqual: (other: string | number | Long.Long) => boolean;
				gte: (other: string | number | Long.Long) => boolean;
				isEven: () => boolean;
				isNegative: () => boolean;
				isOdd: () => boolean;
				isPositive: () => boolean;
				isZero: () => boolean;
				lessThan: (other: string | number | Long.Long) => boolean;
				lt: (other: string | number | Long.Long) => boolean;
				lessThanOrEqual: (other: string | number | Long.Long) => boolean;
				lte: (other: string | number | Long.Long) => boolean;
				modulo: (other: string | number | Long.Long) => Long.Long;
				mod: (other: string | number | Long.Long) => Long.Long;
				multiply: (multiplier: string | number | Long.Long) => Long.Long;
				mul: (multiplier: string | number | Long.Long) => Long.Long;
				negate: () => Long.Long;
				neg: () => Long.Long;
				not: () => Long.Long;
				notEquals: (other: string | number | Long.Long) => boolean;
				neq: (other: string | number | Long.Long) => boolean;
				or: (other: string | number | Long.Long) => Long.Long;
				shiftLeft: (numBits: number | Long.Long) => Long.Long;
				shl: (numBits: number | Long.Long) => Long.Long;
				shiftRight: (numBits: number | Long.Long) => Long.Long;
				shr: (numBits: number | Long.Long) => Long.Long;
				shiftRightUnsigned: (numBits: number | Long.Long) => Long.Long;
				shru: (numBits: number | Long.Long) => Long.Long;
				subtract: (subtrahend: string | number | Long.Long) => Long.Long;
				sub: (subtrahend: string | number | Long.Long) => Long.Long;
				toInt: () => number;
				toNumber: () => number;
				toBytes: (le?: boolean) => number[];
				toBytesLE: () => number[];
				toBytesBE: () => number[];
				toSigned: () => Long.Long;
				toString: (radix?: number) => string;
				toUnsigned: () => Long.Long;
				xor: (other: string | number | Long.Long) => Long.Long;
			} & Record<Exclude<keyof I["pagination"]["offset"], keyof Long.Long>, never>);
			limit?: string | number | (Long.Long & {
				high: number;
				low: number;
				unsigned: boolean;
				add: (addend: string | number | Long.Long) => Long.Long;
				and: (other: string | number | Long.Long) => Long.Long;
				compare: (other: string | number | Long.Long) => number;
				comp: (other: string | number | Long.Long) => number;
				divide: (divisor: string | number | Long.Long) => Long.Long;
				div: (divisor: string | number | Long.Long) => Long.Long;
				equals: (other: string | number | Long.Long) => boolean;
				eq: (other: string | number | Long.Long) => boolean;
				getHighBits: () => number;
				getHighBitsUnsigned: () => number;
				getLowBits: () => number;
				getLowBitsUnsigned: () => number;
				getNumBitsAbs: () => number;
				greaterThan: (other: string | number | Long.Long) => boolean;
				gt: (other: string | number | Long.Long) => boolean;
				greaterThanOrEqual: (other: string | number | Long.Long) => boolean;
				gte: (other: string | number | Long.Long) => boolean;
				isEven: () => boolean;
				isNegative: () => boolean;
				isOdd: () => boolean;
				isPositive: () => boolean;
				isZero: () => boolean;
				lessThan: (other: string | number | Long.Long) => boolean;
				lt: (other: string | number | Long.Long) => boolean;
				lessThanOrEqual: (other: string | number | Long.Long) => boolean;
				lte: (other: string | number | Long.Long) => boolean;
				modulo: (other: string | number | Long.Long) => Long.Long;
				mod: (other: string | number | Long.Long) => Long.Long;
				multiply: (multiplier: string | number | Long.Long) => Long.Long;
				mul: (multiplier: string | number | Long.Long) => Long.Long;
				negate: () => Long.Long;
				neg: () => Long.Long;
				not: () => Long.Long;
				notEquals: (other: string | number | Long.Long) => boolean;
				neq: (other: string | number | Long.Long) => boolean;
				or: (other: string | number | Long.Long) => Long.Long;
				shiftLeft: (numBits: number | Long.Long) => Long.Long;
				shl: (numBits: number | Long.Long) => Long.Long;
				shiftRight: (numBits: number | Long.Long) => Long.Long;
				shr: (numBits: number | Long.Long) => Long.Long;
				shiftRightUnsigned: (numBits: number | Long.Long) => Long.Long;
				shru: (numBits: number | Long.Long) => Long.Long;
				subtract: (subtrahend: string | number | Long.Long) => Long.Long;
				sub: (subtrahend: string | number | Long.Long) => Long.Long;
				toInt: () => number;
				toNumber: () => number;
				toBytes: (le?: boolean) => number[];
				toBytesLE: () => number[];
				toBytesBE: () => number[];
				toSigned: () => Long.Long;
				toString: (radix?: number) => string;
				toUnsigned: () => Long.Long;
				xor: (other: string | number | Long.Long) => Long.Long;
			} & Record<Exclude<keyof I["pagination"]["limit"], keyof Long.Long>, never>);
			countTotal?: boolean;
			reverse?: boolean;
		} & Record<Exclude<keyof I["pagination"], keyof PageRequest>, never>;
	} & Record<Exclude<keyof I, "pagination">, never>>(object: I): QueryTotalSupplyRequest;
};
declare const QueryTotalSupplyResponse: {
	encode(message: QueryTotalSupplyResponse, writer?: _m0.Writer): _m0.Writer;
	decode(input: _m0.Reader | Uint8Array, length?: number): QueryTotalSupplyResponse;
	fromJSON(object: any): QueryTotalSupplyResponse;
	toJSON(message: QueryTotalSupplyResponse): unknown;
	fromPartial<I extends {
		supply?: {
			denom?: string;
			amount?: string;
		}[];
		pagination?: {
			nextKey?: Uint8Array;
			total?: string | number | Long.Long;
		};
	} & {
		supply?: {
			denom?: string;
			amount?: string;
		}[] & ({
			denom?: string;
			amount?: string;
		} & {
			denom?: string;
			amount?: string;
		} & Record<Exclude<keyof I["supply"][number], keyof Coin>, never>)[] & Record<Exclude<keyof I["supply"], keyof {
			denom?: string;
			amount?: string;
		}[]>, never>;
		pagination?: {
			nextKey?: Uint8Array;
			total?: string | number | Long.Long;
		} & {
			nextKey?: Uint8Array;
			total?: string | number | (Long.Long & {
				high: number;
				low: number;
				unsigned: boolean;
				add: (addend: string | number | Long.Long) => Long.Long;
				and: (other: string | number | Long.Long) => Long.Long;
				compare: (other: string | number | Long.Long) => number;
				comp: (other: string | number | Long.Long) => number;
				divide: (divisor: string | number | Long.Long) => Long.Long;
				div: (divisor: string | number | Long.Long) => Long.Long;
				equals: (other: string | number | Long.Long) => boolean;
				eq: (other: string | number | Long.Long) => boolean;
				getHighBits: () => number;
				getHighBitsUnsigned: () => number;
				getLowBits: () => number;
				getLowBitsUnsigned: () => number;
				getNumBitsAbs: () => number;
				greaterThan: (other: string | number | Long.Long) => boolean;
				gt: (other: string | number | Long.Long) => boolean;
				greaterThanOrEqual: (other: string | number | Long.Long) => boolean;
				gte: (other: string | number | Long.Long) => boolean;
				isEven: () => boolean;
				isNegative: () => boolean;
				isOdd: () => boolean;
				isPositive: () => boolean;
				isZero: () => boolean;
				lessThan: (other: string | number | Long.Long) => boolean;
				lt: (other: string | number | Long.Long) => boolean;
				lessThanOrEqual: (other: string | number | Long.Long) => boolean;
				lte: (other: string | number | Long.Long) => boolean;
				modulo: (other: string | number | Long.Long) => Long.Long;
				mod: (other: string | number | Long.Long) => Long.Long;
				multiply: (multiplier: string | number | Long.Long) => Long.Long;
				mul: (multiplier: string | number | Long.Long) => Long.Long;
				negate: () => Long.Long;
				neg: () => Long.Long;
				not: () => Long.Long;
				notEquals: (other: string | number | Long.Long) => boolean;
				neq: (other: string | number | Long.Long) => boolean;
				or: (other: string | number | Long.Long) => Long.Long;
				shiftLeft: (numBits: number | Long.Long) => Long.Long;
				shl: (numBits: number | Long.Long) => Long.Long;
				shiftRight: (numBits: number | Long.Long) => Long.Long;
				shr: (numBits: number | Long.Long) => Long.Long;
				shiftRightUnsigned: (numBits: number | Long.Long) => Long.Long;
				shru: (numBits: number | Long.Long) => Long.Long;
				subtract: (subtrahend: string | number | Long.Long) => Long.Long;
				sub: (subtrahend: string | number | Long.Long) => Long.Long;
				toInt: () => number;
				toNumber: () => number;
				toBytes: (le?: boolean) => number[];
				toBytesLE: () => number[];
				toBytesBE: () => number[];
				toSigned: () => Long.Long;
				toString: (radix?: number) => string;
				toUnsigned: () => Long.Long;
				xor: (other: string | number | Long.Long) => Long.Long;
			} & Record<Exclude<keyof I["pagination"]["total"], keyof Long.Long>, never>);
		} & Record<Exclude<keyof I["pagination"], keyof PageResponse>, never>;
	} & Record<Exclude<keyof I, keyof QueryTotalSupplyResponse>, never>>(object: I): QueryTotalSupplyResponse;
};
declare const QuerySupplyOfRequest: {
	encode(message: QuerySupplyOfRequest, writer?: _m0.Writer): _m0.Writer;
	decode(input: _m0.Reader | Uint8Array, length?: number): QuerySupplyOfRequest;
	fromJSON(object: any): QuerySupplyOfRequest;
	toJSON(message: QuerySupplyOfRequest): unknown;
	fromPartial<I extends {
		denom?: string;
	} & {
		denom?: string;
	} & Record<Exclude<keyof I, "denom">, never>>(object: I): QuerySupplyOfRequest;
};
declare const QuerySupplyOfResponse: {
	encode(message: QuerySupplyOfResponse, writer?: _m0.Writer): _m0.Writer;
	decode(input: _m0.Reader | Uint8Array, length?: number): QuerySupplyOfResponse;
	fromJSON(object: any): QuerySupplyOfResponse;
	toJSON(message: QuerySupplyOfResponse): unknown;
	fromPartial<I extends {
		amount?: {
			denom?: string;
			amount?: string;
		};
	} & {
		amount?: {
			denom?: string;
			amount?: string;
		} & {
			denom?: string;
			amount?: string;
		} & Record<Exclude<keyof I["amount"], keyof Coin>, never>;
	} & Record<Exclude<keyof I, "amount">, never>>(object: I): QuerySupplyOfResponse;
};
declare const QueryParamsRequest: {
	encode(_: QueryParamsRequest, writer?: _m0.Writer): _m0.Writer;
	decode(input: _m0.Reader | Uint8Array, length?: number): QueryParamsRequest;
	fromJSON(_: any): QueryParamsRequest;
	toJSON(_: QueryParamsRequest): unknown;
	fromPartial<I extends {} & {} & Record<Exclude<keyof I, never>, never>>(_: I): QueryParamsRequest;
};
declare const QueryParamsResponse: {
	encode(message: QueryParamsResponse, writer?: _m0.Writer): _m0.Writer;
	decode(input: _m0.Reader | Uint8Array, length?: number): QueryParamsResponse;
	fromJSON(object: any): QueryParamsResponse;
	toJSON(message: QueryParamsResponse): unknown;
	fromPartial<I extends {
		params?: {
			sendEnabled?: {
				denom?: string;
				enabled?: boolean;
			}[];
			defaultSendEnabled?: boolean;
		};
	} & {
		params?: {
			sendEnabled?: {
				denom?: string;
				enabled?: boolean;
			}[];
			defaultSendEnabled?: boolean;
		} & {
			sendEnabled?: {
				denom?: string;
				enabled?: boolean;
			}[] & ({
				denom?: string;
				enabled?: boolean;
			} & {
				denom?: string;
				enabled?: boolean;
			} & Record<Exclude<keyof I["params"]["sendEnabled"][number], keyof SendEnabled>, never>)[] & Record<Exclude<keyof I["params"]["sendEnabled"], keyof {
				denom?: string;
				enabled?: boolean;
			}[]>, never>;
			defaultSendEnabled?: boolean;
		} & Record<Exclude<keyof I["params"], keyof Params>, never>;
	} & Record<Exclude<keyof I, "params">, never>>(object: I): QueryParamsResponse;
};
declare const QueryDenomsMetadataRequest: {
	encode(message: QueryDenomsMetadataRequest, writer?: _m0.Writer): _m0.Writer;
	decode(input: _m0.Reader | Uint8Array, length?: number): QueryDenomsMetadataRequest;
	fromJSON(object: any): QueryDenomsMetadataRequest;
	toJSON(message: QueryDenomsMetadataRequest): unknown;
	fromPartial<I extends {
		pagination?: {
			key?: Uint8Array;
			offset?: string | number | Long.Long;
			limit?: string | number | Long.Long;
			countTotal?: boolean;
			reverse?: boolean;
		};
	} & {
		pagination?: {
			key?: Uint8Array;
			offset?: string | number | Long.Long;
			limit?: string | number | Long.Long;
			countTotal?: boolean;
			reverse?: boolean;
		} & {
			key?: Uint8Array;
			offset?: string | number | (Long.Long & {
				high: number;
				low: number;
				unsigned: boolean;
				add: (addend: string | number | Long.Long) => Long.Long;
				and: (other: string | number | Long.Long) => Long.Long;
				compare: (other: string | number | Long.Long) => number;
				comp: (other: string | number | Long.Long) => number;
				divide: (divisor: string | number | Long.Long) => Long.Long;
				div: (divisor: string | number | Long.Long) => Long.Long;
				equals: (other: string | number | Long.Long) => boolean;
				eq: (other: string | number | Long.Long) => boolean;
				getHighBits: () => number;
				getHighBitsUnsigned: () => number;
				getLowBits: () => number;
				getLowBitsUnsigned: () => number;
				getNumBitsAbs: () => number;
				greaterThan: (other: string | number | Long.Long) => boolean;
				gt: (other: string | number | Long.Long) => boolean;
				greaterThanOrEqual: (other: string | number | Long.Long) => boolean;
				gte: (other: string | number | Long.Long) => boolean;
				isEven: () => boolean;
				isNegative: () => boolean;
				isOdd: () => boolean;
				isPositive: () => boolean;
				isZero: () => boolean;
				lessThan: (other: string | number | Long.Long) => boolean;
				lt: (other: string | number | Long.Long) => boolean;
				lessThanOrEqual: (other: string | number | Long.Long) => boolean;
				lte: (other: string | number | Long.Long) => boolean;
				modulo: (other: string | number | Long.Long) => Long.Long;
				mod: (other: string | number | Long.Long) => Long.Long;
				multiply: (multiplier: string | number | Long.Long) => Long.Long;
				mul: (multiplier: string | number | Long.Long) => Long.Long;
				negate: () => Long.Long;
				neg: () => Long.Long;
				not: () => Long.Long;
				notEquals: (other: string | number | Long.Long) => boolean;
				neq: (other: string | number | Long.Long) => boolean;
				or: (other: string | number | Long.Long) => Long.Long;
				shiftLeft: (numBits: number | Long.Long) => Long.Long;
				shl: (numBits: number | Long.Long) => Long.Long;
				shiftRight: (numBits: number | Long.Long) => Long.Long;
				shr: (numBits: number | Long.Long) => Long.Long;
				shiftRightUnsigned: (numBits: number | Long.Long) => Long.Long;
				shru: (numBits: number | Long.Long) => Long.Long;
				subtract: (subtrahend: string | number | Long.Long) => Long.Long;
				sub: (subtrahend: string | number | Long.Long) => Long.Long;
				toInt: () => number;
				toNumber: () => number;
				toBytes: (le?: boolean) => number[];
				toBytesLE: () => number[];
				toBytesBE: () => number[];
				toSigned: () => Long.Long;
				toString: (radix?: number) => string;
				toUnsigned: () => Long.Long;
				xor: (other: string | number | Long.Long) => Long.Long;
			} & Record<Exclude<keyof I["pagination"]["offset"], keyof Long.Long>, never>);
			limit?: string | number | (Long.Long & {
				high: number;
				low: number;
				unsigned: boolean;
				add: (addend: string | number | Long.Long) => Long.Long;
				and: (other: string | number | Long.Long) => Long.Long;
				compare: (other: string | number | Long.Long) => number;
				comp: (other: string | number | Long.Long) => number;
				divide: (divisor: string | number | Long.Long) => Long.Long;
				div: (divisor: string | number | Long.Long) => Long.Long;
				equals: (other: string | number | Long.Long) => boolean;
				eq: (other: string | number | Long.Long) => boolean;
				getHighBits: () => number;
				getHighBitsUnsigned: () => number;
				getLowBits: () => number;
				getLowBitsUnsigned: () => number;
				getNumBitsAbs: () => number;
				greaterThan: (other: string | number | Long.Long) => boolean;
				gt: (other: string | number | Long.Long) => boolean;
				greaterThanOrEqual: (other: string | number | Long.Long) => boolean;
				gte: (other: string | number | Long.Long) => boolean;
				isEven: () => boolean;
				isNegative: () => boolean;
				isOdd: () => boolean;
				isPositive: () => boolean;
				isZero: () => boolean;
				lessThan: (other: string | number | Long.Long) => boolean;
				lt: (other: string | number | Long.Long) => boolean;
				lessThanOrEqual: (other: string | number | Long.Long) => boolean;
				lte: (other: string | number | Long.Long) => boolean;
				modulo: (other: string | number | Long.Long) => Long.Long;
				mod: (other: string | number | Long.Long) => Long.Long;
				multiply: (multiplier: string | number | Long.Long) => Long.Long;
				mul: (multiplier: string | number | Long.Long) => Long.Long;
				negate: () => Long.Long;
				neg: () => Long.Long;
				not: () => Long.Long;
				notEquals: (other: string | number | Long.Long) => boolean;
				neq: (other: string | number | Long.Long) => boolean;
				or: (other: string | number | Long.Long) => Long.Long;
				shiftLeft: (numBits: number | Long.Long) => Long.Long;
				shl: (numBits: number | Long.Long) => Long.Long;
				shiftRight: (numBits: number | Long.Long) => Long.Long;
				shr: (numBits: number | Long.Long) => Long.Long;
				shiftRightUnsigned: (numBits: number | Long.Long) => Long.Long;
				shru: (numBits: number | Long.Long) => Long.Long;
				subtract: (subtrahend: string | number | Long.Long) => Long.Long;
				sub: (subtrahend: string | number | Long.Long) => Long.Long;
				toInt: () => number;
				toNumber: () => number;
				toBytes: (le?: boolean) => number[];
				toBytesLE: () => number[];
				toBytesBE: () => number[];
				toSigned: () => Long.Long;
				toString: (radix?: number) => string;
				toUnsigned: () => Long.Long;
				xor: (other: string | number | Long.Long) => Long.Long;
			} & Record<Exclude<keyof I["pagination"]["limit"], keyof Long.Long>, never>);
			countTotal?: boolean;
			reverse?: boolean;
		} & Record<Exclude<keyof I["pagination"], keyof PageRequest>, never>;
	} & Record<Exclude<keyof I, "pagination">, never>>(object: I): QueryDenomsMetadataRequest;
};
declare const QueryDenomsMetadataResponse: {
	encode(message: QueryDenomsMetadataResponse, writer?: _m0.Writer): _m0.Writer;
	decode(input: _m0.Reader | Uint8Array, length?: number): QueryDenomsMetadataResponse;
	fromJSON(object: any): QueryDenomsMetadataResponse;
	toJSON(message: QueryDenomsMetadataResponse): unknown;
	fromPartial<I extends {
		metadatas?: {
			description?: string;
			denomUnits?: {
				denom?: string;
				exponent?: number;
				aliases?: string[];
			}[];
			base?: string;
			display?: string;
			name?: string;
			symbol?: string;
		}[];
		pagination?: {
			nextKey?: Uint8Array;
			total?: string | number | Long.Long;
		};
	} & {
		metadatas?: {
			description?: string;
			denomUnits?: {
				denom?: string;
				exponent?: number;
				aliases?: string[];
			}[];
			base?: string;
			display?: string;
			name?: string;
			symbol?: string;
		}[] & ({
			description?: string;
			denomUnits?: {
				denom?: string;
				exponent?: number;
				aliases?: string[];
			}[];
			base?: string;
			display?: string;
			name?: string;
			symbol?: string;
		} & {
			description?: string;
			denomUnits?: {
				denom?: string;
				exponent?: number;
				aliases?: string[];
			}[] & ({
				denom?: string;
				exponent?: number;
				aliases?: string[];
			} & {
				denom?: string;
				exponent?: number;
				aliases?: string[] & string[] & Record<Exclude<keyof I["metadatas"][number]["denomUnits"][number]["aliases"], keyof string[]>, never>;
			} & Record<Exclude<keyof I["metadatas"][number]["denomUnits"][number], keyof DenomUnit>, never>)[] & Record<Exclude<keyof I["metadatas"][number]["denomUnits"], keyof {
				denom?: string;
				exponent?: number;
				aliases?: string[];
			}[]>, never>;
			base?: string;
			display?: string;
			name?: string;
			symbol?: string;
		} & Record<Exclude<keyof I["metadatas"][number], keyof Metadata>, never>)[] & Record<Exclude<keyof I["metadatas"], keyof {
			description?: string;
			denomUnits?: {
				denom?: string;
				exponent?: number;
				aliases?: string[];
			}[];
			base?: string;
			display?: string;
			name?: string;
			symbol?: string;
		}[]>, never>;
		pagination?: {
			nextKey?: Uint8Array;
			total?: string | number | Long.Long;
		} & {
			nextKey?: Uint8Array;
			total?: string | number | (Long.Long & {
				high: number;
				low: number;
				unsigned: boolean;
				add: (addend: string | number | Long.Long) => Long.Long;
				and: (other: string | number | Long.Long) => Long.Long;
				compare: (other: string | number | Long.Long) => number;
				comp: (other: string | number | Long.Long) => number;
				divide: (divisor: string | number | Long.Long) => Long.Long;
				div: (divisor: string | number | Long.Long) => Long.Long;
				equals: (other: string | number | Long.Long) => boolean;
				eq: (other: string | number | Long.Long) => boolean;
				getHighBits: () => number;
				getHighBitsUnsigned: () => number;
				getLowBits: () => number;
				getLowBitsUnsigned: () => number;
				getNumBitsAbs: () => number;
				greaterThan: (other: string | number | Long.Long) => boolean;
				gt: (other: string | number | Long.Long) => boolean;
				greaterThanOrEqual: (other: string | number | Long.Long) => boolean;
				gte: (other: string | number | Long.Long) => boolean;
				isEven: () => boolean;
				isNegative: () => boolean;
				isOdd: () => boolean;
				isPositive: () => boolean;
				isZero: () => boolean;
				lessThan: (other: string | number | Long.Long) => boolean;
				lt: (other: string | number | Long.Long) => boolean;
				lessThanOrEqual: (other: string | number | Long.Long) => boolean;
				lte: (other: string | number | Long.Long) => boolean;
				modulo: (other: string | number | Long.Long) => Long.Long;
				mod: (other: string | number | Long.Long) => Long.Long;
				multiply: (multiplier: string | number | Long.Long) => Long.Long;
				mul: (multiplier: string | number | Long.Long) => Long.Long;
				negate: () => Long.Long;
				neg: () => Long.Long;
				not: () => Long.Long;
				notEquals: (other: string | number | Long.Long) => boolean;
				neq: (other: string | number | Long.Long) => boolean;
				or: (other: string | number | Long.Long) => Long.Long;
				shiftLeft: (numBits: number | Long.Long) => Long.Long;
				shl: (numBits: number | Long.Long) => Long.Long;
				shiftRight: (numBits: number | Long.Long) => Long.Long;
				shr: (numBits: number | Long.Long) => Long.Long;
				shiftRightUnsigned: (numBits: number | Long.Long) => Long.Long;
				shru: (numBits: number | Long.Long) => Long.Long;
				subtract: (subtrahend: string | number | Long.Long) => Long.Long;
				sub: (subtrahend: string | number | Long.Long) => Long.Long;
				toInt: () => number;
				toNumber: () => number;
				toBytes: (le?: boolean) => number[];
				toBytesLE: () => number[];
				toBytesBE: () => number[];
				toSigned: () => Long.Long;
				toString: (radix?: number) => string;
				toUnsigned: () => Long.Long;
				xor: (other: string | number | Long.Long) => Long.Long;
			} & Record<Exclude<keyof I["pagination"]["total"], keyof Long.Long>, never>);
		} & Record<Exclude<keyof I["pagination"], keyof PageResponse>, never>;
	} & Record<Exclude<keyof I, keyof QueryDenomsMetadataResponse>, never>>(object: I): QueryDenomsMetadataResponse;
};
declare const QueryDenomMetadataRequest: {
	encode(message: QueryDenomMetadataRequest, writer?: _m0.Writer): _m0.Writer;
	decode(input: _m0.Reader | Uint8Array, length?: number): QueryDenomMetadataRequest;
	fromJSON(object: any): QueryDenomMetadataRequest;
	toJSON(message: QueryDenomMetadataRequest): unknown;
	fromPartial<I extends {
		denom?: string;
	} & {
		denom?: string;
	} & Record<Exclude<keyof I, "denom">, never>>(object: I): QueryDenomMetadataRequest;
};
declare const QueryDenomMetadataResponse: {
	encode(message: QueryDenomMetadataResponse, writer?: _m0.Writer): _m0.Writer;
	decode(input: _m0.Reader | Uint8Array, length?: number): QueryDenomMetadataResponse;
	fromJSON(object: any): QueryDenomMetadataResponse;
	toJSON(message: QueryDenomMetadataResponse): unknown;
	fromPartial<I extends {
		metadata?: {
			description?: string;
			denomUnits?: {
				denom?: string;
				exponent?: number;
				aliases?: string[];
			}[];
			base?: string;
			display?: string;
			name?: string;
			symbol?: string;
		};
	} & {
		metadata?: {
			description?: string;
			denomUnits?: {
				denom?: string;
				exponent?: number;
				aliases?: string[];
			}[];
			base?: string;
			display?: string;
			name?: string;
			symbol?: string;
		} & {
			description?: string;
			denomUnits?: {
				denom?: string;
				exponent?: number;
				aliases?: string[];
			}[] & ({
				denom?: string;
				exponent?: number;
				aliases?: string[];
			} & {
				denom?: string;
				exponent?: number;
				aliases?: string[] & string[] & Record<Exclude<keyof I["metadata"]["denomUnits"][number]["aliases"], keyof string[]>, never>;
			} & Record<Exclude<keyof I["metadata"]["denomUnits"][number], keyof DenomUnit>, never>)[] & Record<Exclude<keyof I["metadata"]["denomUnits"], keyof {
				denom?: string;
				exponent?: number;
				aliases?: string[];
			}[]>, never>;
			base?: string;
			display?: string;
			name?: string;
			symbol?: string;
		} & Record<Exclude<keyof I["metadata"], keyof Metadata>, never>;
	} & Record<Exclude<keyof I, "metadata">, never>>(object: I): QueryDenomMetadataResponse;
};
/** Query defines the gRPC querier service. */
export interface Query {
	/** Balance queries the balance of a single coin for a single account. */
	Balance(request: QueryBalanceRequest): Promise<QueryBalanceResponse>;
	/** AllBalances queries the balance of all coins for a single account. */
	AllBalances(request: QueryAllBalancesRequest): Promise<QueryAllBalancesResponse>;
	/** TotalSupply queries the total supply of all coins. */
	TotalSupply(request: QueryTotalSupplyRequest): Promise<QueryTotalSupplyResponse>;
	/** SupplyOf queries the supply of a single coin. */
	SupplyOf(request: QuerySupplyOfRequest): Promise<QuerySupplyOfResponse>;
	/** Params queries the parameters of x/bank module. */
	Params(request: QueryParamsRequest): Promise<QueryParamsResponse>;
	/** DenomsMetadata queries the client metadata of a given coin denomination. */
	DenomMetadata(request: QueryDenomMetadataRequest): Promise<QueryDenomMetadataResponse>;
	/** DenomsMetadata queries the client metadata for all registered coin denominations. */
	DenomsMetadata(request: QueryDenomsMetadataRequest): Promise<QueryDenomsMetadataResponse>;
}
declare class QueryClientImpl implements Query {
	private readonly rpc;
	constructor(rpc: Rpc);
	Balance(request: QueryBalanceRequest): Promise<QueryBalanceResponse>;
	AllBalances(request: QueryAllBalancesRequest): Promise<QueryAllBalancesResponse>;
	TotalSupply(request: QueryTotalSupplyRequest): Promise<QueryTotalSupplyResponse>;
	SupplyOf(request: QuerySupplyOfRequest): Promise<QuerySupplyOfResponse>;
	Params(request: QueryParamsRequest): Promise<QueryParamsResponse>;
	DenomMetadata(request: QueryDenomMetadataRequest): Promise<QueryDenomMetadataResponse>;
	DenomsMetadata(request: QueryDenomsMetadataRequest): Promise<QueryDenomsMetadataResponse>;
}
export interface Rpc {
	request(service: string, method: string, data: Uint8Array): Promise<Uint8Array>;
}
/** Params defines the parameters for the module. */
export interface Params {
	testnet: string;
}
declare const Params: {
	encode(message: Params, writer?: _m0.Writer): _m0.Writer;
	decode(input: _m0.Reader | Uint8Array, length?: number): Params;
	fromJSON(object: any): Params;
	toJSON(message: Params): unknown;
	fromPartial<I extends {
		testnet?: string;
	} & {
		testnet?: string;
	} & Record<Exclude<keyof I, "testnet">, never>>(object: I): Params;
};
/** QueryParamsRequest is request type for the Query/Params RPC method. */
export interface QueryParamsRequest {
}
/** QueryParamsResponse is response type for the Query/Params RPC method. */
export interface QueryParamsResponse {
	/** params holds all the parameters of this module. */
	params?: Params;
}
export interface QueryMintRequest {
	address: string;
}
export interface QueryMintResponse {
	address: string;
	mnemonic: string;
}
declare const QueryParamsRequest: {
	encode(_: QueryParamsRequest, writer?: _m0.Writer): _m0.Writer;
	decode(input: _m0.Reader | Uint8Array, length?: number): QueryParamsRequest;
	fromJSON(_: any): QueryParamsRequest;
	toJSON(_: QueryParamsRequest): unknown;
	fromPartial<I extends {} & {} & Record<Exclude<keyof I, never>, never>>(_: I): QueryParamsRequest;
};
declare const QueryParamsResponse: {
	encode(message: QueryParamsResponse, writer?: _m0.Writer): _m0.Writer;
	decode(input: _m0.Reader | Uint8Array, length?: number): QueryParamsResponse;
	fromJSON(object: any): QueryParamsResponse;
	toJSON(message: QueryParamsResponse): unknown;
	fromPartial<I extends {
		params?: {
			testnet?: string;
		};
	} & {
		params?: {
			testnet?: string;
		} & {
			testnet?: string;
		} & Record<Exclude<keyof I["params"], "testnet">, never>;
	} & Record<Exclude<keyof I, "params">, never>>(object: I): QueryParamsResponse;
};
declare const QueryMintRequest: {
	encode(message: QueryMintRequest, writer?: _m0.Writer): _m0.Writer;
	decode(input: _m0.Reader | Uint8Array, length?: number): QueryMintRequest;
	fromJSON(object: any): QueryMintRequest;
	toJSON(message: QueryMintRequest): unknown;
	fromPartial<I extends {
		address?: string;
	} & {
		address?: string;
	} & Record<Exclude<keyof I, "address">, never>>(object: I): QueryMintRequest;
};
declare const QueryMintResponse: {
	encode(message: QueryMintResponse, writer?: _m0.Writer): _m0.Writer;
	decode(input: _m0.Reader | Uint8Array, length?: number): QueryMintResponse;
	fromJSON(object: any): QueryMintResponse;
	toJSON(message: QueryMintResponse): unknown;
	fromPartial<I extends {
		address?: string;
		mnemonic?: string;
	} & {
		address?: string;
		mnemonic?: string;
	} & Record<Exclude<keyof I, keyof QueryMintResponse>, never>>(object: I): QueryMintResponse;
};
/** Query defines the gRPC querier service. */
export interface Query {
	/** Parameters queries the parameters of the module. */
	Params(request: QueryParamsRequest): Promise<QueryParamsResponse>;
	/** Queries a list of Mint items. */
	Mint(request: QueryMintRequest): Promise<QueryMintResponse>;
}
declare class QueryClientImpl implements Query {
	private readonly rpc;
	constructor(rpc: Rpc);
	Params(request: QueryParamsRequest): Promise<QueryParamsResponse>;
	Mint(request: QueryMintRequest): Promise<QueryMintResponse>;
}
export interface Rpc {
	request(service: string, method: string, data: Uint8Array): Promise<Uint8Array>;
}
export interface QueryGetTaxInfoRequest {
}
export interface QueryGetTaxInfoResponse {
	gasTaxBp: Long;
	transferTaxBp: Long;
	taxCollector: string;
}
declare const QueryGetTaxInfoRequest: {
	encode(_: QueryGetTaxInfoRequest, writer?: _m0.Writer): _m0.Writer;
	decode(input: _m0.Reader | Uint8Array, length?: number): QueryGetTaxInfoRequest;
	fromJSON(_: any): QueryGetTaxInfoRequest;
	toJSON(_: QueryGetTaxInfoRequest): unknown;
	fromPartial<I extends {} & {} & Record<Exclude<keyof I, never>, never>>(_: I): QueryGetTaxInfoRequest;
};
declare const QueryGetTaxInfoResponse: {
	encode(message: QueryGetTaxInfoResponse, writer?: _m0.Writer): _m0.Writer;
	decode(input: _m0.Reader | Uint8Array, length?: number): QueryGetTaxInfoResponse;
	fromJSON(object: any): QueryGetTaxInfoResponse;
	toJSON(message: QueryGetTaxInfoResponse): unknown;
	fromPartial<I extends {
		gasTaxBp?: string | number | Long.Long;
		transferTaxBp?: string | number | Long.Long;
		taxCollector?: string;
	} & {
		gasTaxBp?: string | number | (Long.Long & {
			high: number;
			low: number;
			unsigned: boolean;
			add: (addend: string | number | Long.Long) => Long.Long;
			and: (other: string | number | Long.Long) => Long.Long;
			compare: (other: string | number | Long.Long) => number;
			comp: (other: string | number | Long.Long) => number;
			divide: (divisor: string | number | Long.Long) => Long.Long;
			div: (divisor: string | number | Long.Long) => Long.Long;
			equals: (other: string | number | Long.Long) => boolean;
			eq: (other: string | number | Long.Long) => boolean;
			getHighBits: () => number;
			getHighBitsUnsigned: () => number;
			getLowBits: () => number;
			getLowBitsUnsigned: () => number;
			getNumBitsAbs: () => number;
			greaterThan: (other: string | number | Long.Long) => boolean;
			gt: (other: string | number | Long.Long) => boolean;
			greaterThanOrEqual: (other: string | number | Long.Long) => boolean;
			gte: (other: string | number | Long.Long) => boolean;
			isEven: () => boolean;
			isNegative: () => boolean;
			isOdd: () => boolean;
			isPositive: () => boolean;
			isZero: () => boolean;
			lessThan: (other: string | number | Long.Long) => boolean;
			lt: (other: string | number | Long.Long) => boolean;
			lessThanOrEqual: (other: string | number | Long.Long) => boolean;
			lte: (other: string | number | Long.Long) => boolean;
			modulo: (other: string | number | Long.Long) => Long.Long;
			mod: (other: string | number | Long.Long) => Long.Long;
			multiply: (multiplier: string | number | Long.Long) => Long.Long;
			mul: (multiplier: string | number | Long.Long) => Long.Long;
			negate: () => Long.Long;
			neg: () => Long.Long;
			not: () => Long.Long;
			notEquals: (other: string | number | Long.Long) => boolean;
			neq: (other: string | number | Long.Long) => boolean;
			or: (other: string | number | Long.Long) => Long.Long;
			shiftLeft: (numBits: number | Long.Long) => Long.Long;
			shl: (numBits: number | Long.Long) => Long.Long;
			shiftRight: (numBits: number | Long.Long) => Long.Long;
			shr: (numBits: number | Long.Long) => Long.Long;
			shiftRightUnsigned: (numBits: number | Long.Long) => Long.Long;
			shru: (numBits: number | Long.Long) => Long.Long;
			subtract: (subtrahend: string | number | Long.Long) => Long.Long;
			sub: (subtrahend: string | number | Long.Long) => Long.Long;
			toInt: () => number;
			toNumber: () => number;
			toBytes: (le?: boolean) => number[];
			toBytesLE: () => number[];
			toBytesBE: () => number[];
			toSigned: () => Long.Long;
			toString: (radix?: number) => string;
			toUnsigned: () => Long.Long;
			xor: (other: string | number | Long.Long) => Long.Long;
		} & Record<Exclude<keyof I["gasTaxBp"], keyof Long.Long>, never>);
		transferTaxBp?: string | number | (Long.Long & {
			high: number;
			low: number;
			unsigned: boolean;
			add: (addend: string | number | Long.Long) => Long.Long;
			and: (other: string | number | Long.Long) => Long.Long;
			compare: (other: string | number | Long.Long) => number;
			comp: (other: string | number | Long.Long) => number;
			divide: (divisor: string | number | Long.Long) => Long.Long;
			div: (divisor: string | number | Long.Long) => Long.Long;
			equals: (other: string | number | Long.Long) => boolean;
			eq: (other: string | number | Long.Long) => boolean;
			getHighBits: () => number;
			getHighBitsUnsigned: () => number;
			getLowBits: () => number;
			getLowBitsUnsigned: () => number;
			getNumBitsAbs: () => number;
			greaterThan: (other: string | number | Long.Long) => boolean;
			gt: (other: string | number | Long.Long) => boolean;
			greaterThanOrEqual: (other: string | number | Long.Long) => boolean;
			gte: (other: string | number | Long.Long) => boolean;
			isEven: () => boolean;
			isNegative: () => boolean;
			isOdd: () => boolean;
			isPositive: () => boolean;
			isZero: () => boolean;
			lessThan: (other: string | number | Long.Long) => boolean;
			lt: (other: string | number | Long.Long) => boolean;
			lessThanOrEqual: (other: string | number | Long.Long) => boolean;
			lte: (other: string | number | Long.Long) => boolean;
			modulo: (other: string | number | Long.Long) => Long.Long;
			mod: (other: string | number | Long.Long) => Long.Long;
			multiply: (multiplier: string | number | Long.Long) => Long.Long;
			mul: (multiplier: string | number | Long.Long) => Long.Long;
			negate: () => Long.Long;
			neg: () => Long.Long;
			not: () => Long.Long;
			notEquals: (other: string | number | Long.Long) => boolean;
			neq: (other: string | number | Long.Long) => boolean;
			or: (other: string | number | Long.Long) => Long.Long;
			shiftLeft: (numBits: number | Long.Long) => Long.Long;
			shl: (numBits: number | Long.Long) => Long.Long;
			shiftRight: (numBits: number | Long.Long) => Long.Long;
			shr: (numBits: number | Long.Long) => Long.Long;
			shiftRightUnsigned: (numBits: number | Long.Long) => Long.Long;
			shru: (numBits: number | Long.Long) => Long.Long;
			subtract: (subtrahend: string | number | Long.Long) => Long.Long;
			sub: (subtrahend: string | number | Long.Long) => Long.Long;
			toInt: () => number;
			toNumber: () => number;
			toBytes: (le?: boolean) => number[];
			toBytesLE: () => number[];
			toBytesBE: () => number[];
			toSigned: () => Long.Long;
			toString: (radix?: number) => string;
			toUnsigned: () => Long.Long;
			xor: (other: string | number | Long.Long) => Long.Long;
		} & Record<Exclude<keyof I["transferTaxBp"], keyof Long.Long>, never>);
		taxCollector?: string;
	} & Record<Exclude<keyof I, keyof QueryGetTaxInfoResponse>, never>>(object: I): QueryGetTaxInfoResponse;
};
/** Query defines the gRPC querier service. */
export interface Query {
	/** Queries a list of GetTaxInfo items. */
	GetTaxInfo(request: QueryGetTaxInfoRequest): Promise<QueryGetTaxInfoResponse>;
}
declare class QueryClientImpl implements Query {
	private readonly rpc;
	constructor(rpc: Rpc);
	GetTaxInfo(request: QueryGetTaxInfoRequest): Promise<QueryGetTaxInfoResponse>;
}
export interface Rpc {
	request(service: string, method: string, data: Uint8Array): Promise<Uint8Array>;
}
/**
 * Consensus captures the consensus rules for processing a block in the blockchain,
 * including all blockchain data structures and the rules of the application's
 * state transition machine.
 */
export interface Consensus {
	block: Long;
	app: Long;
}
declare const Consensus: {
	encode(message: Consensus, writer?: _m0.Writer): _m0.Writer;
	decode(input: _m0.Reader | Uint8Array, length?: number): Consensus;
	fromJSON(object: any): Consensus;
	toJSON(message: Consensus): unknown;
	fromPartial<I extends {
		block?: string | number | Long.Long;
		app?: string | number | Long.Long;
	} & {
		block?: string | number | (Long.Long & {
			high: number;
			low: number;
			unsigned: boolean;
			add: (addend: string | number | Long.Long) => Long.Long;
			and: (other: string | number | Long.Long) => Long.Long;
			compare: (other: string | number | Long.Long) => number;
			comp: (other: string | number | Long.Long) => number;
			divide: (divisor: string | number | Long.Long) => Long.Long;
			div: (divisor: string | number | Long.Long) => Long.Long;
			equals: (other: string | number | Long.Long) => boolean;
			eq: (other: string | number | Long.Long) => boolean;
			getHighBits: () => number;
			getHighBitsUnsigned: () => number;
			getLowBits: () => number;
			getLowBitsUnsigned: () => number;
			getNumBitsAbs: () => number;
			greaterThan: (other: string | number | Long.Long) => boolean;
			gt: (other: string | number | Long.Long) => boolean;
			greaterThanOrEqual: (other: string | number | Long.Long) => boolean;
			gte: (other: string | number | Long.Long) => boolean;
			isEven: () => boolean;
			isNegative: () => boolean;
			isOdd: () => boolean;
			isPositive: () => boolean;
			isZero: () => boolean;
			lessThan: (other: string | number | Long.Long) => boolean;
			lt: (other: string | number | Long.Long) => boolean;
			lessThanOrEqual: (other: string | number | Long.Long) => boolean;
			lte: (other: string | number | Long.Long) => boolean;
			modulo: (other: string | number | Long.Long) => Long.Long;
			mod: (other: string | number | Long.Long) => Long.Long;
			multiply: (multiplier: string | number | Long.Long) => Long.Long;
			mul: (multiplier: string | number | Long.Long) => Long.Long;
			negate: () => Long.Long;
			neg: () => Long.Long;
			not: () => Long.Long;
			notEquals: (other: string | number | Long.Long) => boolean;
			neq: (other: string | number | Long.Long) => boolean;
			or: (other: string | number | Long.Long) => Long.Long;
			shiftLeft: (numBits: number | Long.Long) => Long.Long;
			shl: (numBits: number | Long.Long) => Long.Long;
			shiftRight: (numBits: number | Long.Long) => Long.Long;
			shr: (numBits: number | Long.Long) => Long.Long;
			shiftRightUnsigned: (numBits: number | Long.Long) => Long.Long;
			shru: (numBits: number | Long.Long) => Long.Long;
			subtract: (subtrahend: string | number | Long.Long) => Long.Long;
			sub: (subtrahend: string | number | Long.Long) => Long.Long;
			toInt: () => number;
			toNumber: () => number;
			toBytes: (le?: boolean) => number[];
			toBytesLE: () => number[];
			toBytesBE: () => number[];
			toSigned: () => Long.Long;
			toString: (radix?: number) => string;
			toUnsigned: () => Long.Long;
			xor: (other: string | number | Long.Long) => Long.Long;
		} & Record<Exclude<keyof I["block"], keyof Long.Long>, never>);
		app?: string | number | (Long.Long & {
			high: number;
			low: number;
			unsigned: boolean;
			add: (addend: string | number | Long.Long) => Long.Long;
			and: (other: string | number | Long.Long) => Long.Long;
			compare: (other: string | number | Long.Long) => number;
			comp: (other: string | number | Long.Long) => number;
			divide: (divisor: string | number | Long.Long) => Long.Long;
			div: (divisor: string | number | Long.Long) => Long.Long;
			equals: (other: string | number | Long.Long) => boolean;
			eq: (other: string | number | Long.Long) => boolean;
			getHighBits: () => number;
			getHighBitsUnsigned: () => number;
			getLowBits: () => number;
			getLowBitsUnsigned: () => number;
			getNumBitsAbs: () => number;
			greaterThan: (other: string | number | Long.Long) => boolean;
			gt: (other: string | number | Long.Long) => boolean;
			greaterThanOrEqual: (other: string | number | Long.Long) => boolean;
			gte: (other: string | number | Long.Long) => boolean;
			isEven: () => boolean;
			isNegative: () => boolean;
			isOdd: () => boolean;
			isPositive: () => boolean;
			isZero: () => boolean;
			lessThan: (other: string | number | Long.Long) => boolean;
			lt: (other: string | number | Long.Long) => boolean;
			lessThanOrEqual: (other: string | number | Long.Long) => boolean;
			lte: (other: string | number | Long.Long) => boolean;
			modulo: (other: string | number | Long.Long) => Long.Long;
			mod: (other: string | number | Long.Long) => Long.Long;
			multiply: (multiplier: string | number | Long.Long) => Long.Long;
			mul: (multiplier: string | number | Long.Long) => Long.Long;
			negate: () => Long.Long;
			neg: () => Long.Long;
			not: () => Long.Long;
			notEquals: (other: string | number | Long.Long) => boolean;
			neq: (other: string | number | Long.Long) => boolean;
			or: (other: string | number | Long.Long) => Long.Long;
			shiftLeft: (numBits: number | Long.Long) => Long.Long;
			shl: (numBits: number | Long.Long) => Long.Long;
			shiftRight: (numBits: number | Long.Long) => Long.Long;
			shr: (numBits: number | Long.Long) => Long.Long;
			shiftRightUnsigned: (numBits: number | Long.Long) => Long.Long;
			shru: (numBits: number | Long.Long) => Long.Long;
			subtract: (subtrahend: string | number | Long.Long) => Long.Long;
			sub: (subtrahend: string | number | Long.Long) => Long.Long;
			toInt: () => number;
			toNumber: () => number;
			toBytes: (le?: boolean) => number[];
			toBytesLE: () => number[];
			toBytesBE: () => number[];
			toSigned: () => Long.Long;
			toString: (radix?: number) => string;
			toUnsigned: () => Long.Long;
			xor: (other: string | number | Long.Long) => Long.Long;
		} & Record<Exclude<keyof I["app"], keyof Long.Long>, never>);
	} & Record<Exclude<keyof I, keyof Consensus>, never>>(object: I): Consensus;
};
/** PartsetHeader */
export interface PartSetHeader {
	total: number;
	hash: Uint8Array;
}
/** BlockID */
export interface BlockID {
	hash: Uint8Array;
	partSetHeader?: PartSetHeader;
}
/** Header defines the structure of a Tendermint block header. */
export interface Header {
	/** basic block info */
	version?: Consensus;
	chainId: string;
	height: Long;
	time?: Date;
	/** prev block info */
	lastBlockId?: BlockID;
	/** hashes of block data */
	lastCommitHash: Uint8Array;
	/** transactions */
	dataHash: Uint8Array;
	/** hashes from the app output from the prev block */
	validatorsHash: Uint8Array;
	/** validators for the next block */
	nextValidatorsHash: Uint8Array;
	/** consensus params for current block */
	consensusHash: Uint8Array;
	/** state after txs from the previous block */
	appHash: Uint8Array;
	/** root hash of all results from the txs from the previous block */
	lastResultsHash: Uint8Array;
	/** consensus info */
	evidenceHash: Uint8Array;
	/** original proposer of the block */
	proposerAddress: Uint8Array;
}
declare const PartSetHeader: {
	encode(message: PartSetHeader, writer?: _m0.Writer): _m0.Writer;
	decode(input: _m0.Reader | Uint8Array, length?: number): PartSetHeader;
	fromJSON(object: any): PartSetHeader;
	toJSON(message: PartSetHeader): unknown;
	fromPartial<I extends {
		total?: number;
		hash?: Uint8Array;
	} & {
		total?: number;
		hash?: Uint8Array;
	} & Record<Exclude<keyof I, keyof PartSetHeader>, never>>(object: I): PartSetHeader;
};
declare const BlockID: {
	encode(message: BlockID, writer?: _m0.Writer): _m0.Writer;
	decode(input: _m0.Reader | Uint8Array, length?: number): BlockID;
	fromJSON(object: any): BlockID;
	toJSON(message: BlockID): unknown;
	fromPartial<I extends {
		hash?: Uint8Array;
		partSetHeader?: {
			total?: number;
			hash?: Uint8Array;
		};
	} & {
		hash?: Uint8Array;
		partSetHeader?: {
			total?: number;
			hash?: Uint8Array;
		} & {
			total?: number;
			hash?: Uint8Array;
		} & Record<Exclude<keyof I["partSetHeader"], keyof PartSetHeader>, never>;
	} & Record<Exclude<keyof I, keyof BlockID>, never>>(object: I): BlockID;
};
declare const Header: {
	encode(message: Header, writer?: _m0.Writer): _m0.Writer;
	decode(input: _m0.Reader | Uint8Array, length?: number): Header;
	fromJSON(object: any): Header;
	toJSON(message: Header): unknown;
	fromPartial<I extends {
		version?: {
			block?: string | number | Long.Long;
			app?: string | number | Long.Long;
		};
		chainId?: string;
		height?: string | number | Long.Long;
		time?: Date;
		lastBlockId?: {
			hash?: Uint8Array;
			partSetHeader?: {
				total?: number;
				hash?: Uint8Array;
			};
		};
		lastCommitHash?: Uint8Array;
		dataHash?: Uint8Array;
		validatorsHash?: Uint8Array;
		nextValidatorsHash?: Uint8Array;
		consensusHash?: Uint8Array;
		appHash?: Uint8Array;
		lastResultsHash?: Uint8Array;
		evidenceHash?: Uint8Array;
		proposerAddress?: Uint8Array;
	} & {
		version?: {
			block?: string | number | Long.Long;
			app?: string | number | Long.Long;
		} & {
			block?: string | number | (Long.Long & {
				high: number;
				low: number;
				unsigned: boolean;
				add: (addend: string | number | Long.Long) => Long.Long;
				and: (other: string | number | Long.Long) => Long.Long;
				compare: (other: string | number | Long.Long) => number;
				comp: (other: string | number | Long.Long) => number;
				divide: (divisor: string | number | Long.Long) => Long.Long;
				div: (divisor: string | number | Long.Long) => Long.Long;
				equals: (other: string | number | Long.Long) => boolean;
				eq: (other: string | number | Long.Long) => boolean;
				getHighBits: () => number;
				getHighBitsUnsigned: () => number;
				getLowBits: () => number;
				getLowBitsUnsigned: () => number;
				getNumBitsAbs: () => number;
				greaterThan: (other: string | number | Long.Long) => boolean;
				gt: (other: string | number | Long.Long) => boolean;
				greaterThanOrEqual: (other: string | number | Long.Long) => boolean;
				gte: (other: string | number | Long.Long) => boolean;
				isEven: () => boolean;
				isNegative: () => boolean;
				isOdd: () => boolean;
				isPositive: () => boolean;
				isZero: () => boolean;
				lessThan: (other: string | number | Long.Long) => boolean;
				lt: (other: string | number | Long.Long) => boolean;
				lessThanOrEqual: (other: string | number | Long.Long) => boolean;
				lte: (other: string | number | Long.Long) => boolean;
				modulo: (other: string | number | Long.Long) => Long.Long;
				mod: (other: string | number | Long.Long) => Long.Long;
				multiply: (multiplier: string | number | Long.Long) => Long.Long;
				mul: (multiplier: string | number | Long.Long) => Long.Long;
				negate: () => Long.Long;
				neg: () => Long.Long;
				not: () => Long.Long;
				notEquals: (other: string | number | Long.Long) => boolean;
				neq: (other: string | number | Long.Long) => boolean;
				or: (other: string | number | Long.Long) => Long.Long;
				shiftLeft: (numBits: number | Long.Long) => Long.Long;
				shl: (numBits: number | Long.Long) => Long.Long;
				shiftRight: (numBits: number | Long.Long) => Long.Long;
				shr: (numBits: number | Long.Long) => Long.Long;
				shiftRightUnsigned: (numBits: number | Long.Long) => Long.Long;
				shru: (numBits: number | Long.Long) => Long.Long;
				subtract: (subtrahend: string | number | Long.Long) => Long.Long;
				sub: (subtrahend: string | number | Long.Long) => Long.Long;
				toInt: () => number;
				toNumber: () => number;
				toBytes: (le?: boolean) => number[];
				toBytesLE: () => number[];
				toBytesBE: () => number[];
				toSigned: () => Long.Long;
				toString: (radix?: number) => string;
				toUnsigned: () => Long.Long;
				xor: (other: string | number | Long.Long) => Long.Long;
			} & Record<Exclude<keyof I["version"]["block"], keyof Long.Long>, never>);
			app?: string | number | (Long.Long & {
				high: number;
				low: number;
				unsigned: boolean;
				add: (addend: string | number | Long.Long) => Long.Long;
				and: (other: string | number | Long.Long) => Long.Long;
				compare: (other: string | number | Long.Long) => number;
				comp: (other: string | number | Long.Long) => number;
				divide: (divisor: string | number | Long.Long) => Long.Long;
				div: (divisor: string | number | Long.Long) => Long.Long;
				equals: (other: string | number | Long.Long) => boolean;
				eq: (other: string | number | Long.Long) => boolean;
				getHighBits: () => number;
				getHighBitsUnsigned: () => number;
				getLowBits: () => number;
				getLowBitsUnsigned: () => number;
				getNumBitsAbs: () => number;
				greaterThan: (other: string | number | Long.Long) => boolean;
				gt: (other: string | number | Long.Long) => boolean;
				greaterThanOrEqual: (other: string | number | Long.Long) => boolean;
				gte: (other: string | number | Long.Long) => boolean;
				isEven: () => boolean;
				isNegative: () => boolean;
				isOdd: () => boolean;
				isPositive: () => boolean;
				isZero: () => boolean;
				lessThan: (other: string | number | Long.Long) => boolean;
				lt: (other: string | number | Long.Long) => boolean;
				lessThanOrEqual: (other: string | number | Long.Long) => boolean;
				lte: (other: string | number | Long.Long) => boolean;
				modulo: (other: string | number | Long.Long) => Long.Long;
				mod: (other: string | number | Long.Long) => Long.Long;
				multiply: (multiplier: string | number | Long.Long) => Long.Long;
				mul: (multiplier: string | number | Long.Long) => Long.Long;
				negate: () => Long.Long;
				neg: () => Long.Long;
				not: () => Long.Long;
				notEquals: (other: string | number | Long.Long) => boolean;
				neq: (other: string | number | Long.Long) => boolean;
				or: (other: string | number | Long.Long) => Long.Long;
				shiftLeft: (numBits: number | Long.Long) => Long.Long;
				shl: (numBits: number | Long.Long) => Long.Long;
				shiftRight: (numBits: number | Long.Long) => Long.Long;
				shr: (numBits: number | Long.Long) => Long.Long;
				shiftRightUnsigned: (numBits: number | Long.Long) => Long.Long;
				shru: (numBits: number | Long.Long) => Long.Long;
				subtract: (subtrahend: string | number | Long.Long) => Long.Long;
				sub: (subtrahend: string | number | Long.Long) => Long.Long;
				toInt: () => number;
				toNumber: () => number;
				toBytes: (le?: boolean) => number[];
				toBytesLE: () => number[];
				toBytesBE: () => number[];
				toSigned: () => Long.Long;
				toString: (radix?: number) => string;
				toUnsigned: () => Long.Long;
				xor: (other: string | number | Long.Long) => Long.Long;
			} & Record<Exclude<keyof I["version"]["app"], keyof Long.Long>, never>);
		} & Record<Exclude<keyof I["version"], keyof Consensus>, never>;
		chainId?: string;
		height?: string | number | (Long.Long & {
			high: number;
			low: number;
			unsigned: boolean;
			add: (addend: string | number | Long.Long) => Long.Long;
			and: (other: string | number | Long.Long) => Long.Long;
			compare: (other: string | number | Long.Long) => number;
			comp: (other: string | number | Long.Long) => number;
			divide: (divisor: string | number | Long.Long) => Long.Long;
			div: (divisor: string | number | Long.Long) => Long.Long;
			equals: (other: string | number | Long.Long) => boolean;
			eq: (other: string | number | Long.Long) => boolean;
			getHighBits: () => number;
			getHighBitsUnsigned: () => number;
			getLowBits: () => number;
			getLowBitsUnsigned: () => number;
			getNumBitsAbs: () => number;
			greaterThan: (other: string | number | Long.Long) => boolean;
			gt: (other: string | number | Long.Long) => boolean;
			greaterThanOrEqual: (other: string | number | Long.Long) => boolean;
			gte: (other: string | number | Long.Long) => boolean;
			isEven: () => boolean;
			isNegative: () => boolean;
			isOdd: () => boolean;
			isPositive: () => boolean;
			isZero: () => boolean;
			lessThan: (other: string | number | Long.Long) => boolean;
			lt: (other: string | number | Long.Long) => boolean;
			lessThanOrEqual: (other: string | number | Long.Long) => boolean;
			lte: (other: string | number | Long.Long) => boolean;
			modulo: (other: string | number | Long.Long) => Long.Long;
			mod: (other: string | number | Long.Long) => Long.Long;
			multiply: (multiplier: string | number | Long.Long) => Long.Long;
			mul: (multiplier: string | number | Long.Long) => Long.Long;
			negate: () => Long.Long;
			neg: () => Long.Long;
			not: () => Long.Long;
			notEquals: (other: string | number | Long.Long) => boolean;
			neq: (other: string | number | Long.Long) => boolean;
			or: (other: string | number | Long.Long) => Long.Long;
			shiftLeft: (numBits: number | Long.Long) => Long.Long;
			shl: (numBits: number | Long.Long) => Long.Long;
			shiftRight: (numBits: number | Long.Long) => Long.Long;
			shr: (numBits: number | Long.Long) => Long.Long;
			shiftRightUnsigned: (numBits: number | Long.Long) => Long.Long;
			shru: (numBits: number | Long.Long) => Long.Long;
			subtract: (subtrahend: string | number | Long.Long) => Long.Long;
			sub: (subtrahend: string | number | Long.Long) => Long.Long;
			toInt: () => number;
			toNumber: () => number;
			toBytes: (le?: boolean) => number[];
			toBytesLE: () => number[];
			toBytesBE: () => number[];
			toSigned: () => Long.Long;
			toString: (radix?: number) => string;
			toUnsigned: () => Long.Long;
			xor: (other: string | number | Long.Long) => Long.Long;
		} & Record<Exclude<keyof I["height"], keyof Long.Long>, never>);
		time?: Date;
		lastBlockId?: {
			hash?: Uint8Array;
			partSetHeader?: {
				total?: number;
				hash?: Uint8Array;
			};
		} & {
			hash?: Uint8Array;
			partSetHeader?: {
				total?: number;
				hash?: Uint8Array;
			} & {
				total?: number;
				hash?: Uint8Array;
			} & Record<Exclude<keyof I["lastBlockId"]["partSetHeader"], keyof PartSetHeader>, never>;
		} & Record<Exclude<keyof I["lastBlockId"], keyof BlockID>, never>;
		lastCommitHash?: Uint8Array;
		dataHash?: Uint8Array;
		validatorsHash?: Uint8Array;
		nextValidatorsHash?: Uint8Array;
		consensusHash?: Uint8Array;
		appHash?: Uint8Array;
		lastResultsHash?: Uint8Array;
		evidenceHash?: Uint8Array;
		proposerAddress?: Uint8Array;
	} & Record<Exclude<keyof I, keyof Header>, never>>(object: I): Header;
};
/**
 * `Any` contains an arbitrary serialized protocol buffer message along with a
 * URL that describes the type of the serialized message.
 *
 * Protobuf library provides support to pack/unpack Any values in the form
 * of utility functions or additional generated methods of the Any type.
 *
 * Example 1: Pack and unpack a message in C++.
 *
 *     Foo foo = ...;
 *     Any any;
 *     any.PackFrom(foo);
 *     ...
 *     if (any.UnpackTo(&foo)) {
 *       ...
 *     }
 *
 * Example 2: Pack and unpack a message in Java.
 *
 *     Foo foo = ...;
 *     Any any = Any.pack(foo);
 *     ...
 *     if (any.is(Foo.class)) {
 *       foo = any.unpack(Foo.class);
 *     }
 *
 * Example 3: Pack and unpack a message in Python.
 *
 *     foo = Foo(...)
 *     any = Any()
 *     any.Pack(foo)
 *     ...
 *     if any.Is(Foo.DESCRIPTOR):
 *       any.Unpack(foo)
 *       ...
 *
 * Example 4: Pack and unpack a message in Go
 *
 *      foo := &pb.Foo{...}
 *      any, err := anypb.New(foo)
 *      if err != nil {
 *        ...
 *      }
 *      ...
 *      foo := &pb.Foo{}
 *      if err := any.UnmarshalTo(foo); err != nil {
 *        ...
 *      }
 *
 * The pack methods provided by protobuf library will by default use
 * 'type.googleapis.com/full.type.name' as the type URL and the unpack
 * methods only use the fully qualified type name after the last '/'
 * in the type URL, for example "foo.bar.com/x/y.z" will yield type
 * name "y.z".
 *
 *
 * JSON
 *
 * The JSON representation of an `Any` value uses the regular
 * representation of the deserialized, embedded message, with an
 * additional field `@type` which contains the type URL. Example:
 *
 *     package google.profile;
 *     message Person {
 *       string first_name = 1;
 *       string last_name = 2;
 *     }
 *
 *     {
 *       "@type": "type.googleapis.com/google.profile.Person",
 *       "firstName": <string>,
 *       "lastName": <string>
 *     }
 *
 * If the embedded message type is well-known and has a custom JSON
 * representation, that representation will be embedded adding a field
 * `value` which holds the custom JSON in addition to the `@type`
 * field. Example (for message [google.protobuf.Duration][]):
 *
 *     {
 *       "@type": "type.googleapis.com/google.protobuf.Duration",
 *       "value": "1.212s"
 *     }
 */
export interface Any {
	/**
	 * A URL/resource name that uniquely identifies the type of the serialized
	 * protocol buffer message. This string must contain at least
	 * one "/" character. The last segment of the URL's path must represent
	 * the fully qualified name of the type (as in
	 * `path/google.protobuf.Duration`). The name should be in a canonical form
	 * (e.g., leading "." is not accepted).
	 *
	 * In practice, teams usually precompile into the binary all types that they
	 * expect it to use in the context of Any. However, for URLs which use the
	 * scheme `http`, `https`, or no scheme, one can optionally set up a type
	 * server that maps type URLs to message definitions as follows:
	 *
	 * * If no scheme is provided, `https` is assumed.
	 * * An HTTP GET on the URL must yield a [google.protobuf.Type][]
	 *   value in binary format, or produce an error.
	 * * Applications are allowed to cache lookup results based on the
	 *   URL, or have them precompiled into a binary to avoid any
	 *   lookup. Therefore, binary compatibility needs to be preserved
	 *   on changes to types. (Use versioned type names to manage
	 *   breaking changes.)
	 *
	 * Note: this functionality is not currently available in the official
	 * protobuf release, and it is not used for type URLs beginning with
	 * type.googleapis.com.
	 *
	 * Schemes other than `http`, `https` (or the empty scheme) might be
	 * used with implementation specific semantics.
	 */
	typeUrl: string;
	/** Must be a valid serialized protocol buffer of the above specified type. */
	value: Uint8Array;
}
declare const Any: {
	encode(message: Any, writer?: _m0.Writer): _m0.Writer;
	decode(input: _m0.Reader | Uint8Array, length?: number): Any;
	fromJSON(object: any): Any;
	toJSON(message: Any): unknown;
	fromPartial<I extends {
		typeUrl?: string;
		value?: Uint8Array;
	} & {
		typeUrl?: string;
		value?: Uint8Array;
	} & Record<Exclude<keyof I, keyof Any>, never>>(object: I): Any;
};
/**
 * A Duration represents a signed, fixed-length span of time represented
 * as a count of seconds and fractions of seconds at nanosecond
 * resolution. It is independent of any calendar and concepts like "day"
 * or "month". It is related to Timestamp in that the difference between
 * two Timestamp values is a Duration and it can be added or subtracted
 * from a Timestamp. Range is approximately +-10,000 years.
 *
 * # Examples
 *
 * Example 1: Compute Duration from two Timestamps in pseudo code.
 *
 *     Timestamp start = ...;
 *     Timestamp end = ...;
 *     Duration duration = ...;
 *
 *     duration.seconds = end.seconds - start.seconds;
 *     duration.nanos = end.nanos - start.nanos;
 *
 *     if (duration.seconds < 0 && duration.nanos > 0) {
 *       duration.seconds += 1;
 *       duration.nanos -= 1000000000;
 *     } else if (duration.seconds > 0 && duration.nanos < 0) {
 *       duration.seconds -= 1;
 *       duration.nanos += 1000000000;
 *     }
 *
 * Example 2: Compute Timestamp from Timestamp + Duration in pseudo code.
 *
 *     Timestamp start = ...;
 *     Duration duration = ...;
 *     Timestamp end = ...;
 *
 *     end.seconds = start.seconds + duration.seconds;
 *     end.nanos = start.nanos + duration.nanos;
 *
 *     if (end.nanos < 0) {
 *       end.seconds -= 1;
 *       end.nanos += 1000000000;
 *     } else if (end.nanos >= 1000000000) {
 *       end.seconds += 1;
 *       end.nanos -= 1000000000;
 *     }
 *
 * Example 3: Compute Duration from datetime.timedelta in Python.
 *
 *     td = datetime.timedelta(days=3, minutes=10)
 *     duration = Duration()
 *     duration.FromTimedelta(td)
 *
 * # JSON Mapping
 *
 * In JSON format, the Duration type is encoded as a string rather than an
 * object, where the string ends in the suffix "s" (indicating seconds) and
 * is preceded by the number of seconds, with nanoseconds expressed as
 * fractional seconds. For example, 3 seconds with 0 nanoseconds should be
 * encoded in JSON format as "3s", while 3 seconds and 1 nanosecond should
 * be expressed in JSON format as "3.000000001s", and 3 seconds and 1
 * microsecond should be expressed in JSON format as "3.000001s".
 */
export interface Duration {
	/**
	 * Signed seconds of the span of time. Must be from -315,576,000,000
	 * to +315,576,000,000 inclusive. Note: these bounds are computed from:
	 * 60 sec/min * 60 min/hr * 24 hr/day * 365.25 days/year * 10000 years
	 */
	seconds: Long;
	/**
	 * Signed fractions of a second at nanosecond resolution of the span
	 * of time. Durations less than one second are represented with a 0
	 * `seconds` field and a positive or negative `nanos` field. For durations
	 * of one second or more, a non-zero value for the `nanos` field must be
	 * of the same sign as the `seconds` field. Must be from -999,999,999
	 * to +999,999,999 inclusive.
	 */
	nanos: number;
}
declare const Duration: {
	encode(message: Duration, writer?: _m0.Writer): _m0.Writer;
	decode(input: _m0.Reader | Uint8Array, length?: number): Duration;
	fromJSON(object: any): Duration;
	toJSON(message: Duration): unknown;
	fromPartial<I extends {
		seconds?: string | number | Long.Long;
		nanos?: number;
	} & {
		seconds?: string | number | (Long.Long & {
			high: number;
			low: number;
			unsigned: boolean;
			add: (addend: string | number | Long.Long) => Long.Long;
			and: (other: string | number | Long.Long) => Long.Long;
			compare: (other: string | number | Long.Long) => number;
			comp: (other: string | number | Long.Long) => number;
			divide: (divisor: string | number | Long.Long) => Long.Long;
			div: (divisor: string | number | Long.Long) => Long.Long;
			equals: (other: string | number | Long.Long) => boolean;
			eq: (other: string | number | Long.Long) => boolean;
			getHighBits: () => number;
			getHighBitsUnsigned: () => number;
			getLowBits: () => number;
			getLowBitsUnsigned: () => number;
			getNumBitsAbs: () => number;
			greaterThan: (other: string | number | Long.Long) => boolean;
			gt: (other: string | number | Long.Long) => boolean;
			greaterThanOrEqual: (other: string | number | Long.Long) => boolean;
			gte: (other: string | number | Long.Long) => boolean;
			isEven: () => boolean;
			isNegative: () => boolean;
			isOdd: () => boolean;
			isPositive: () => boolean;
			isZero: () => boolean;
			lessThan: (other: string | number | Long.Long) => boolean;
			lt: (other: string | number | Long.Long) => boolean;
			lessThanOrEqual: (other: string | number | Long.Long) => boolean;
			lte: (other: string | number | Long.Long) => boolean;
			modulo: (other: string | number | Long.Long) => Long.Long;
			mod: (other: string | number | Long.Long) => Long.Long;
			multiply: (multiplier: string | number | Long.Long) => Long.Long;
			mul: (multiplier: string | number | Long.Long) => Long.Long;
			negate: () => Long.Long;
			neg: () => Long.Long;
			not: () => Long.Long;
			notEquals: (other: string | number | Long.Long) => boolean;
			neq: (other: string | number | Long.Long) => boolean;
			or: (other: string | number | Long.Long) => Long.Long;
			shiftLeft: (numBits: number | Long.Long) => Long.Long;
			shl: (numBits: number | Long.Long) => Long.Long;
			shiftRight: (numBits: number | Long.Long) => Long.Long;
			shr: (numBits: number | Long.Long) => Long.Long;
			shiftRightUnsigned: (numBits: number | Long.Long) => Long.Long;
			shru: (numBits: number | Long.Long) => Long.Long;
			subtract: (subtrahend: string | number | Long.Long) => Long.Long;
			sub: (subtrahend: string | number | Long.Long) => Long.Long;
			toInt: () => number;
			toNumber: () => number;
			toBytes: (le?: boolean) => number[];
			toBytesLE: () => number[];
			toBytesBE: () => number[];
			toSigned: () => Long.Long;
			toString: (radix?: number) => string;
			toUnsigned: () => Long.Long;
			xor: (other: string | number | Long.Long) => Long.Long;
		} & Record<Exclude<keyof I["seconds"], keyof Long.Long>, never>);
		nanos?: number;
	} & Record<Exclude<keyof I, keyof Duration>, never>>(object: I): Duration;
};
declare enum BondStatus {
	/** BOND_STATUS_UNSPECIFIED - UNSPECIFIED defines an invalid validator status. */
	BOND_STATUS_UNSPECIFIED = 0,
	/** BOND_STATUS_UNBONDED - UNBONDED defines a validator that is not bonded. */
	BOND_STATUS_UNBONDED = 1,
	/** BOND_STATUS_UNBONDING - UNBONDING defines a validator that is unbonding. */
	BOND_STATUS_UNBONDING = 2,
	/** BOND_STATUS_BONDED - BONDED defines a validator that is bonded. */
	BOND_STATUS_BONDED = 3,
	UNRECOGNIZED = -1
}
/**
 * HistoricalInfo contains header and validator information for a given block.
 * It is stored as part of staking module's state, which persists the `n` most
 * recent HistoricalInfo
 * (`n` is set by the staking module's `historical_entries` parameter).
 */
export interface HistoricalInfo {
	header?: Header;
	valset: Validator[];
}
/**
 * CommissionRates defines the initial commission rates to be used for creating
 * a validator.
 */
export interface CommissionRates {
	/** rate is the commission rate charged to delegators, as a fraction. */
	rate: string;
	/** max_rate defines the maximum commission rate which validator can ever charge, as a fraction. */
	maxRate: string;
	/** max_change_rate defines the maximum daily increase of the validator commission, as a fraction. */
	maxChangeRate: string;
}
/** Commission defines commission parameters for a given validator. */
export interface Commission {
	/** commission_rates defines the initial commission rates to be used for creating a validator. */
	commissionRates?: CommissionRates;
	/** update_time is the last time the commission rate was changed. */
	updateTime?: Date;
}
/** Description defines a validator description. */
export interface Description {
	/** moniker defines a human-readable name for the validator. */
	moniker: string;
	/** identity defines an optional identity signature (ex. UPort or Keybase). */
	identity: string;
	/** website defines an optional website link. */
	website: string;
	/** security_contact defines an optional email for security contact. */
	securityContact: string;
	/** details define other optional details. */
	details: string;
}
/**
 * Validator defines a validator, together with the total amount of the
 * Validator's bond shares and their exchange rate to coins. Slashing results in
 * a decrease in the exchange rate, allowing correct calculation of future
 * undelegations without iterating over delegators. When coins are delegated to
 * this validator, the validator is credited with a delegation whose number of
 * bond shares is based on the amount of coins delegated divided by the current
 * exchange rate. Voting power can be calculated as total bonded shares
 * multiplied by exchange rate.
 */
export interface Validator {
	/** operator_address defines the address of the validator's operator; bech encoded in JSON. */
	operatorAddress: string;
	/** consensus_pubkey is the consensus public key of the validator, as a Protobuf Any. */
	consensusPubkey?: Any;
	/** jailed defined whether the validator has been jailed from bonded status or not. */
	jailed: boolean;
	/** status is the validator status (bonded/unbonding/unbonded). */
	status: BondStatus;
	/** tokens define the delegated tokens (incl. self-delegation). */
	tokens: string;
	/** delegator_shares defines total shares issued to a validator's delegators. */
	delegatorShares: string;
	/** description defines the description terms for the validator. */
	description?: Description;
	/** unbonding_height defines, if unbonding, the height at which this validator has begun unbonding. */
	unbondingHeight: Long;
	/** unbonding_time defines, if unbonding, the min time for the validator to complete unbonding. */
	unbondingTime?: Date;
	/** commission defines the commission parameters. */
	commission?: Commission;
	/** min_self_delegation is the validator's self declared minimum self delegation. */
	minSelfDelegation: string;
}
/**
 * Delegation represents the bond with tokens held by an account. It is
 * owned by one delegator, and is associated with the voting power of one
 * validator.
 */
export interface Delegation {
	/** delegator_address is the bech32-encoded address of the delegator. */
	delegatorAddress: string;
	/** validator_address is the bech32-encoded address of the validator. */
	validatorAddress: string;
	/** shares define the delegation shares received. */
	shares: string;
}
/**
 * UnbondingDelegation stores all of a single delegator's unbonding bonds
 * for a single validator in an time-ordered list.
 */
export interface UnbondingDelegation {
	/** delegator_address is the bech32-encoded address of the delegator. */
	delegatorAddress: string;
	/** validator_address is the bech32-encoded address of the validator. */
	validatorAddress: string;
	/** entries are the unbonding delegation entries. */
	entries: UnbondingDelegationEntry[];
}
/** UnbondingDelegationEntry defines an unbonding object with relevant metadata. */
export interface UnbondingDelegationEntry {
	/** creation_height is the height which the unbonding took place. */
	creationHeight: Long;
	/** completion_time is the unix time for unbonding completion. */
	completionTime?: Date;
	/** initial_balance defines the tokens initially scheduled to receive at completion. */
	initialBalance: string;
	/** balance defines the tokens to receive at completion. */
	balance: string;
}
/** RedelegationEntry defines a redelegation object with relevant metadata. */
export interface RedelegationEntry {
	/** creation_height  defines the height which the redelegation took place. */
	creationHeight: Long;
	/** completion_time defines the unix time for redelegation completion. */
	completionTime?: Date;
	/** initial_balance defines the initial balance when redelegation started. */
	initialBalance: string;
	/** shares_dst is the amount of destination-validator shares created by redelegation. */
	sharesDst: string;
}
/**
 * Redelegation contains the list of a particular delegator's redelegating bonds
 * from a particular source validator to a particular destination validator.
 */
export interface Redelegation {
	/** delegator_address is the bech32-encoded address of the delegator. */
	delegatorAddress: string;
	/** validator_src_address is the validator redelegation source operator address. */
	validatorSrcAddress: string;
	/** validator_dst_address is the validator redelegation destination operator address. */
	validatorDstAddress: string;
	/** entries are the redelegation entries. */
	entries: RedelegationEntry[];
}
/** Params defines the parameters for the staking module. */
export interface Params {
	/** unbonding_time is the time duration of unbonding. */
	unbondingTime?: Duration;
	/** max_validators is the maximum number of validators. */
	maxValidators: number;
	/** max_entries is the max entries for either unbonding delegation or redelegation (per pair/trio). */
	maxEntries: number;
	/** historical_entries is the number of historical entries to persist. */
	historicalEntries: number;
	/** bond_denom defines the bondable coin denomination. */
	bondDenom: string;
}
/**
 * DelegationResponse is equivalent to Delegation except that it contains a
 * balance in addition to shares which is more suitable for client responses.
 */
export interface DelegationResponse {
	delegation?: Delegation;
	balance?: Coin;
}
/**
 * RedelegationEntryResponse is equivalent to a RedelegationEntry except that it
 * contains a balance in addition to shares which is more suitable for client
 * responses.
 */
export interface RedelegationEntryResponse {
	redelegationEntry?: RedelegationEntry;
	balance: string;
}
/**
 * RedelegationResponse is equivalent to a Redelegation except that its entries
 * contain a balance in addition to shares which is more suitable for client
 * responses.
 */
export interface RedelegationResponse {
	redelegation?: Redelegation;
	entries: RedelegationEntryResponse[];
}
/**
 * Pool is used for tracking bonded and not-bonded token supply of the bond
 * denomination.
 */
export interface Pool {
	notBondedTokens: string;
	bondedTokens: string;
}
declare const HistoricalInfo: {
	encode(message: HistoricalInfo, writer?: _m0.Writer): _m0.Writer;
	decode(input: _m0.Reader | Uint8Array, length?: number): HistoricalInfo;
	fromJSON(object: any): HistoricalInfo;
	toJSON(message: HistoricalInfo): unknown;
	fromPartial<I extends {
		header?: {
			version?: {
				block?: string | number | Long.Long;
				app?: string | number | Long.Long;
			};
			chainId?: string;
			height?: string | number | Long.Long;
			time?: Date;
			lastBlockId?: {
				hash?: Uint8Array;
				partSetHeader?: {
					total?: number;
					hash?: Uint8Array;
				};
			};
			lastCommitHash?: Uint8Array;
			dataHash?: Uint8Array;
			validatorsHash?: Uint8Array;
			nextValidatorsHash?: Uint8Array;
			consensusHash?: Uint8Array;
			appHash?: Uint8Array;
			lastResultsHash?: Uint8Array;
			evidenceHash?: Uint8Array;
			proposerAddress?: Uint8Array;
		};
		valset?: {
			operatorAddress?: string;
			consensusPubkey?: {
				typeUrl?: string;
				value?: Uint8Array;
			};
			jailed?: boolean;
			status?: BondStatus;
			tokens?: string;
			delegatorShares?: string;
			description?: {
				moniker?: string;
				identity?: string;
				website?: string;
				securityContact?: string;
				details?: string;
			};
			unbondingHeight?: string | number | Long.Long;
			unbondingTime?: Date;
			commission?: {
				commissionRates?: {
					rate?: string;
					maxRate?: string;
					maxChangeRate?: string;
				};
				updateTime?: Date;
			};
			minSelfDelegation?: string;
		}[];
	} & {
		header?: {
			version?: {
				block?: string | number | Long.Long;
				app?: string | number | Long.Long;
			};
			chainId?: string;
			height?: string | number | Long.Long;
			time?: Date;
			lastBlockId?: {
				hash?: Uint8Array;
				partSetHeader?: {
					total?: number;
					hash?: Uint8Array;
				};
			};
			lastCommitHash?: Uint8Array;
			dataHash?: Uint8Array;
			validatorsHash?: Uint8Array;
			nextValidatorsHash?: Uint8Array;
			consensusHash?: Uint8Array;
			appHash?: Uint8Array;
			lastResultsHash?: Uint8Array;
			evidenceHash?: Uint8Array;
			proposerAddress?: Uint8Array;
		} & {
			version?: {
				block?: string | number | Long.Long;
				app?: string | number | Long.Long;
			} & {
				block?: string | number | (Long.Long & {
					high: number;
					low: number;
					unsigned: boolean;
					add: (addend: string | number | Long.Long) => Long.Long;
					and: (other: string | number | Long.Long) => Long.Long;
					compare: (other: string | number | Long.Long) => number;
					comp: (other: string | number | Long.Long) => number;
					divide: (divisor: string | number | Long.Long) => Long.Long;
					div: (divisor: string | number | Long.Long) => Long.Long;
					equals: (other: string | number | Long.Long) => boolean;
					eq: (other: string | number | Long.Long) => boolean;
					getHighBits: () => number;
					getHighBitsUnsigned: () => number;
					getLowBits: () => number;
					getLowBitsUnsigned: () => number;
					getNumBitsAbs: () => number;
					greaterThan: (other: string | number | Long.Long) => boolean;
					gt: (other: string | number | Long.Long) => boolean;
					greaterThanOrEqual: (other: string | number | Long.Long) => boolean;
					gte: (other: string | number | Long.Long) => boolean;
					isEven: () => boolean;
					isNegative: () => boolean;
					isOdd: () => boolean;
					isPositive: () => boolean;
					isZero: () => boolean;
					lessThan: (other: string | number | Long.Long) => boolean;
					lt: (other: string | number | Long.Long) => boolean;
					lessThanOrEqual: (other: string | number | Long.Long) => boolean;
					lte: (other: string | number | Long.Long) => boolean;
					modulo: (other: string | number | Long.Long) => Long.Long;
					mod: (other: string | number | Long.Long) => Long.Long;
					multiply: (multiplier: string | number | Long.Long) => Long.Long;
					mul: (multiplier: string | number | Long.Long) => Long.Long;
					negate: () => Long.Long;
					neg: () => Long.Long;
					not: () => Long.Long;
					notEquals: (other: string | number | Long.Long) => boolean;
					neq: (other: string | number | Long.Long) => boolean;
					or: (other: string | number | Long.Long) => Long.Long;
					shiftLeft: (numBits: number | Long.Long) => Long.Long;
					shl: (numBits: number | Long.Long) => Long.Long;
					shiftRight: (numBits: number | Long.Long) => Long.Long;
					shr: (numBits: number | Long.Long) => Long.Long;
					shiftRightUnsigned: (numBits: number | Long.Long) => Long.Long;
					shru: (numBits: number | Long.Long) => Long.Long;
					subtract: (subtrahend: string | number | Long.Long) => Long.Long;
					sub: (subtrahend: string | number | Long.Long) => Long.Long;
					toInt: () => number;
					toNumber: () => number;
					toBytes: (le?: boolean) => number[];
					toBytesLE: () => number[];
					toBytesBE: () => number[];
					toSigned: () => Long.Long;
					toString: (radix?: number) => string;
					toUnsigned: () => Long.Long;
					xor: (other: string | number | Long.Long) => Long.Long;
				} & Record<Exclude<keyof I["header"]["version"]["block"], keyof Long.Long>, never>);
				app?: string | number | (Long.Long & {
					high: number;
					low: number;
					unsigned: boolean;
					add: (addend: string | number | Long.Long) => Long.Long;
					and: (other: string | number | Long.Long) => Long.Long;
					compare: (other: string | number | Long.Long) => number;
					comp: (other: string | number | Long.Long) => number;
					divide: (divisor: string | number | Long.Long) => Long.Long;
					div: (divisor: string | number | Long.Long) => Long.Long;
					equals: (other: string | number | Long.Long) => boolean;
					eq: (other: string | number | Long.Long) => boolean;
					getHighBits: () => number;
					getHighBitsUnsigned: () => number;
					getLowBits: () => number;
					getLowBitsUnsigned: () => number;
					getNumBitsAbs: () => number;
					greaterThan: (other: string | number | Long.Long) => boolean;
					gt: (other: string | number | Long.Long) => boolean;
					greaterThanOrEqual: (other: string | number | Long.Long) => boolean;
					gte: (other: string | number | Long.Long) => boolean;
					isEven: () => boolean;
					isNegative: () => boolean;
					isOdd: () => boolean;
					isPositive: () => boolean;
					isZero: () => boolean;
					lessThan: (other: string | number | Long.Long) => boolean;
					lt: (other: string | number | Long.Long) => boolean;
					lessThanOrEqual: (other: string | number | Long.Long) => boolean;
					lte: (other: string | number | Long.Long) => boolean;
					modulo: (other: string | number | Long.Long) => Long.Long;
					mod: (other: string | number | Long.Long) => Long.Long;
					multiply: (multiplier: string | number | Long.Long) => Long.Long;
					mul: (multiplier: string | number | Long.Long) => Long.Long;
					negate: () => Long.Long;
					neg: () => Long.Long;
					not: () => Long.Long;
					notEquals: (other: string | number | Long.Long) => boolean;
					neq: (other: string | number | Long.Long) => boolean;
					or: (other: string | number | Long.Long) => Long.Long;
					shiftLeft: (numBits: number | Long.Long) => Long.Long;
					shl: (numBits: number | Long.Long) => Long.Long;
					shiftRight: (numBits: number | Long.Long) => Long.Long;
					shr: (numBits: number | Long.Long) => Long.Long;
					shiftRightUnsigned: (numBits: number | Long.Long) => Long.Long;
					shru: (numBits: number | Long.Long) => Long.Long;
					subtract: (subtrahend: string | number | Long.Long) => Long.Long;
					sub: (subtrahend: string | number | Long.Long) => Long.Long;
					toInt: () => number;
					toNumber: () => number;
					toBytes: (le?: boolean) => number[];
					toBytesLE: () => number[];
					toBytesBE: () => number[];
					toSigned: () => Long.Long;
					toString: (radix?: number) => string;
					toUnsigned: () => Long.Long;
					xor: (other: string | number | Long.Long) => Long.Long;
				} & Record<Exclude<keyof I["header"]["version"]["app"], keyof Long.Long>, never>);
			} & Record<Exclude<keyof I["header"]["version"], keyof Consensus>, never>;
			chainId?: string;
			height?: string | number | (Long.Long & {
				high: number;
				low: number;
				unsigned: boolean;
				add: (addend: string | number | Long.Long) => Long.Long;
				and: (other: string | number | Long.Long) => Long.Long;
				compare: (other: string | number | Long.Long) => number;
				comp: (other: string | number | Long.Long) => number;
				divide: (divisor: string | number | Long.Long) => Long.Long;
				div: (divisor: string | number | Long.Long) => Long.Long;
				equals: (other: string | number | Long.Long) => boolean;
				eq: (other: string | number | Long.Long) => boolean;
				getHighBits: () => number;
				getHighBitsUnsigned: () => number;
				getLowBits: () => number;
				getLowBitsUnsigned: () => number;
				getNumBitsAbs: () => number;
				greaterThan: (other: string | number | Long.Long) => boolean;
				gt: (other: string | number | Long.Long) => boolean;
				greaterThanOrEqual: (other: string | number | Long.Long) => boolean;
				gte: (other: string | number | Long.Long) => boolean;
				isEven: () => boolean;
				isNegative: () => boolean;
				isOdd: () => boolean;
				isPositive: () => boolean;
				isZero: () => boolean;
				lessThan: (other: string | number | Long.Long) => boolean;
				lt: (other: string | number | Long.Long) => boolean;
				lessThanOrEqual: (other: string | number | Long.Long) => boolean;
				lte: (other: string | number | Long.Long) => boolean;
				modulo: (other: string | number | Long.Long) => Long.Long;
				mod: (other: string | number | Long.Long) => Long.Long;
				multiply: (multiplier: string | number | Long.Long) => Long.Long;
				mul: (multiplier: string | number | Long.Long) => Long.Long;
				negate: () => Long.Long;
				neg: () => Long.Long;
				not: () => Long.Long;
				notEquals: (other: string | number | Long.Long) => boolean;
				neq: (other: string | number | Long.Long) => boolean;
				or: (other: string | number | Long.Long) => Long.Long;
				shiftLeft: (numBits: number | Long.Long) => Long.Long;
				shl: (numBits: number | Long.Long) => Long.Long;
				shiftRight: (numBits: number | Long.Long) => Long.Long;
				shr: (numBits: number | Long.Long) => Long.Long;
				shiftRightUnsigned: (numBits: number | Long.Long) => Long.Long;
				shru: (numBits: number | Long.Long) => Long.Long;
				subtract: (subtrahend: string | number | Long.Long) => Long.Long;
				sub: (subtrahend: string | number | Long.Long) => Long.Long;
				toInt: () => number;
				toNumber: () => number;
				toBytes: (le?: boolean) => number[];
				toBytesLE: () => number[];
				toBytesBE: () => number[];
				toSigned: () => Long.Long;
				toString: (radix?: number) => string;
				toUnsigned: () => Long.Long;
				xor: (other: string | number | Long.Long) => Long.Long;
			} & Record<Exclude<keyof I["header"]["height"], keyof Long.Long>, never>);
			time?: Date;
			lastBlockId?: {
				hash?: Uint8Array;
				partSetHeader?: {
					total?: number;
					hash?: Uint8Array;
				};
			} & {
				hash?: Uint8Array;
				partSetHeader?: {
					total?: number;
					hash?: Uint8Array;
				} & {
					total?: number;
					hash?: Uint8Array;
				} & Record<Exclude<keyof I["header"]["lastBlockId"]["partSetHeader"], keyof PartSetHeader>, never>;
			} & Record<Exclude<keyof I["header"]["lastBlockId"], keyof BlockID>, never>;
			lastCommitHash?: Uint8Array;
			dataHash?: Uint8Array;
			validatorsHash?: Uint8Array;
			nextValidatorsHash?: Uint8Array;
			consensusHash?: Uint8Array;
			appHash?: Uint8Array;
			lastResultsHash?: Uint8Array;
			evidenceHash?: Uint8Array;
			proposerAddress?: Uint8Array;
		} & Record<Exclude<keyof I["header"], keyof Header>, never>;
		valset?: {
			operatorAddress?: string;
			consensusPubkey?: {
				typeUrl?: string;
				value?: Uint8Array;
			};
			jailed?: boolean;
			status?: BondStatus;
			tokens?: string;
			delegatorShares?: string;
			description?: {
				moniker?: string;
				identity?: string;
				website?: string;
				securityContact?: string;
				details?: string;
			};
			unbondingHeight?: string | number | Long.Long;
			unbondingTime?: Date;
			commission?: {
				commissionRates?: {
					rate?: string;
					maxRate?: string;
					maxChangeRate?: string;
				};
				updateTime?: Date;
			};
			minSelfDelegation?: string;
		}[] & ({
			operatorAddress?: string;
			consensusPubkey?: {
				typeUrl?: string;
				value?: Uint8Array;
			};
			jailed?: boolean;
			status?: BondStatus;
			tokens?: string;
			delegatorShares?: string;
			description?: {
				moniker?: string;
				identity?: string;
				website?: string;
				securityContact?: string;
				details?: string;
			};
			unbondingHeight?: string | number | Long.Long;
			unbondingTime?: Date;
			commission?: {
				commissionRates?: {
					rate?: string;
					maxRate?: string;
					maxChangeRate?: string;
				};
				updateTime?: Date;
			};
			minSelfDelegation?: string;
		} & {
			operatorAddress?: string;
			consensusPubkey?: {
				typeUrl?: string;
				value?: Uint8Array;
			} & {
				typeUrl?: string;
				value?: Uint8Array;
			} & Record<Exclude<keyof I["valset"][number]["consensusPubkey"], keyof Any>, never>;
			jailed?: boolean;
			status?: BondStatus;
			tokens?: string;
			delegatorShares?: string;
			description?: {
				moniker?: string;
				identity?: string;
				website?: string;
				securityContact?: string;
				details?: string;
			} & {
				moniker?: string;
				identity?: string;
				website?: string;
				securityContact?: string;
				details?: string;
			} & Record<Exclude<keyof I["valset"][number]["description"], keyof Description>, never>;
			unbondingHeight?: string | number | (Long.Long & {
				high: number;
				low: number;
				unsigned: boolean;
				add: (addend: string | number | Long.Long) => Long.Long;
				and: (other: string | number | Long.Long) => Long.Long;
				compare: (other: string | number | Long.Long) => number;
				comp: (other: string | number | Long.Long) => number;
				divide: (divisor: string | number | Long.Long) => Long.Long;
				div: (divisor: string | number | Long.Long) => Long.Long;
				equals: (other: string | number | Long.Long) => boolean;
				eq: (other: string | number | Long.Long) => boolean;
				getHighBits: () => number;
				getHighBitsUnsigned: () => number;
				getLowBits: () => number;
				getLowBitsUnsigned: () => number;
				getNumBitsAbs: () => number;
				greaterThan: (other: string | number | Long.Long) => boolean;
				gt: (other: string | number | Long.Long) => boolean;
				greaterThanOrEqual: (other: string | number | Long.Long) => boolean;
				gte: (other: string | number | Long.Long) => boolean;
				isEven: () => boolean;
				isNegative: () => boolean;
				isOdd: () => boolean;
				isPositive: () => boolean;
				isZero: () => boolean;
				lessThan: (other: string | number | Long.Long) => boolean;
				lt: (other: string | number | Long.Long) => boolean;
				lessThanOrEqual: (other: string | number | Long.Long) => boolean;
				lte: (other: string | number | Long.Long) => boolean;
				modulo: (other: string | number | Long.Long) => Long.Long;
				mod: (other: string | number | Long.Long) => Long.Long;
				multiply: (multiplier: string | number | Long.Long) => Long.Long;
				mul: (multiplier: string | number | Long.Long) => Long.Long;
				negate: () => Long.Long;
				neg: () => Long.Long;
				not: () => Long.Long;
				notEquals: (other: string | number | Long.Long) => boolean;
				neq: (other: string | number | Long.Long) => boolean;
				or: (other: string | number | Long.Long) => Long.Long;
				shiftLeft: (numBits: number | Long.Long) => Long.Long;
				shl: (numBits: number | Long.Long) => Long.Long;
				shiftRight: (numBits: number | Long.Long) => Long.Long;
				shr: (numBits: number | Long.Long) => Long.Long;
				shiftRightUnsigned: (numBits: number | Long.Long) => Long.Long;
				shru: (numBits: number | Long.Long) => Long.Long;
				subtract: (subtrahend: string | number | Long.Long) => Long.Long;
				sub: (subtrahend: string | number | Long.Long) => Long.Long;
				toInt: () => number;
				toNumber: () => number;
				toBytes: (le?: boolean) => number[];
				toBytesLE: () => number[];
				toBytesBE: () => number[];
				toSigned: () => Long.Long;
				toString: (radix?: number) => string;
				toUnsigned: () => Long.Long;
				xor: (other: string | number | Long.Long) => Long.Long;
			} & Record<Exclude<keyof I["valset"][number]["unbondingHeight"], keyof Long.Long>, never>);
			unbondingTime?: Date;
			commission?: {
				commissionRates?: {
					rate?: string;
					maxRate?: string;
					maxChangeRate?: string;
				};
				updateTime?: Date;
			} & {
				commissionRates?: {
					rate?: string;
					maxRate?: string;
					maxChangeRate?: string;
				} & {
					rate?: string;
					maxRate?: string;
					maxChangeRate?: string;
				} & Record<Exclude<keyof I["valset"][number]["commission"]["commissionRates"], keyof CommissionRates>, never>;
				updateTime?: Date;
			} & Record<Exclude<keyof I["valset"][number]["commission"], keyof Commission>, never>;
			minSelfDelegation?: string;
		} & Record<Exclude<keyof I["valset"][number], keyof Validator>, never>)[] & Record<Exclude<keyof I["valset"], keyof {
			operatorAddress?: string;
			consensusPubkey?: {
				typeUrl?: string;
				value?: Uint8Array;
			};
			jailed?: boolean;
			status?: BondStatus;
			tokens?: string;
			delegatorShares?: string;
			description?: {
				moniker?: string;
				identity?: string;
				website?: string;
				securityContact?: string;
				details?: string;
			};
			unbondingHeight?: string | number | Long.Long;
			unbondingTime?: Date;
			commission?: {
				commissionRates?: {
					rate?: string;
					maxRate?: string;
					maxChangeRate?: string;
				};
				updateTime?: Date;
			};
			minSelfDelegation?: string;
		}[]>, never>;
	} & Record<Exclude<keyof I, keyof HistoricalInfo>, never>>(object: I): HistoricalInfo;
};
declare const CommissionRates: {
	encode(message: CommissionRates, writer?: _m0.Writer): _m0.Writer;
	decode(input: _m0.Reader | Uint8Array, length?: number): CommissionRates;
	fromJSON(object: any): CommissionRates;
	toJSON(message: CommissionRates): unknown;
	fromPartial<I extends {
		rate?: string;
		maxRate?: string;
		maxChangeRate?: string;
	} & {
		rate?: string;
		maxRate?: string;
		maxChangeRate?: string;
	} & Record<Exclude<keyof I, keyof CommissionRates>, never>>(object: I): CommissionRates;
};
declare const Commission: {
	encode(message: Commission, writer?: _m0.Writer): _m0.Writer;
	decode(input: _m0.Reader | Uint8Array, length?: number): Commission;
	fromJSON(object: any): Commission;
	toJSON(message: Commission): unknown;
	fromPartial<I extends {
		commissionRates?: {
			rate?: string;
			maxRate?: string;
			maxChangeRate?: string;
		};
		updateTime?: Date;
	} & {
		commissionRates?: {
			rate?: string;
			maxRate?: string;
			maxChangeRate?: string;
		} & {
			rate?: string;
			maxRate?: string;
			maxChangeRate?: string;
		} & Record<Exclude<keyof I["commissionRates"], keyof CommissionRates>, never>;
		updateTime?: Date;
	} & Record<Exclude<keyof I, keyof Commission>, never>>(object: I): Commission;
};
declare const Description: {
	encode(message: Description, writer?: _m0.Writer): _m0.Writer;
	decode(input: _m0.Reader | Uint8Array, length?: number): Description;
	fromJSON(object: any): Description;
	toJSON(message: Description): unknown;
	fromPartial<I extends {
		moniker?: string;
		identity?: string;
		website?: string;
		securityContact?: string;
		details?: string;
	} & {
		moniker?: string;
		identity?: string;
		website?: string;
		securityContact?: string;
		details?: string;
	} & Record<Exclude<keyof I, keyof Description>, never>>(object: I): Description;
};
declare const Validator: {
	encode(message: Validator, writer?: _m0.Writer): _m0.Writer;
	decode(input: _m0.Reader | Uint8Array, length?: number): Validator;
	fromJSON(object: any): Validator;
	toJSON(message: Validator): unknown;
	fromPartial<I extends {
		operatorAddress?: string;
		consensusPubkey?: {
			typeUrl?: string;
			value?: Uint8Array;
		};
		jailed?: boolean;
		status?: BondStatus;
		tokens?: string;
		delegatorShares?: string;
		description?: {
			moniker?: string;
			identity?: string;
			website?: string;
			securityContact?: string;
			details?: string;
		};
		unbondingHeight?: string | number | Long.Long;
		unbondingTime?: Date;
		commission?: {
			commissionRates?: {
				rate?: string;
				maxRate?: string;
				maxChangeRate?: string;
			};
			updateTime?: Date;
		};
		minSelfDelegation?: string;
	} & {
		operatorAddress?: string;
		consensusPubkey?: {
			typeUrl?: string;
			value?: Uint8Array;
		} & {
			typeUrl?: string;
			value?: Uint8Array;
		} & Record<Exclude<keyof I["consensusPubkey"], keyof Any>, never>;
		jailed?: boolean;
		status?: BondStatus;
		tokens?: string;
		delegatorShares?: string;
		description?: {
			moniker?: string;
			identity?: string;
			website?: string;
			securityContact?: string;
			details?: string;
		} & {
			moniker?: string;
			identity?: string;
			website?: string;
			securityContact?: string;
			details?: string;
		} & Record<Exclude<keyof I["description"], keyof Description>, never>;
		unbondingHeight?: string | number | (Long.Long & {
			high: number;
			low: number;
			unsigned: boolean;
			add: (addend: string | number | Long.Long) => Long.Long;
			and: (other: string | number | Long.Long) => Long.Long;
			compare: (other: string | number | Long.Long) => number;
			comp: (other: string | number | Long.Long) => number;
			divide: (divisor: string | number | Long.Long) => Long.Long;
			div: (divisor: string | number | Long.Long) => Long.Long;
			equals: (other: string | number | Long.Long) => boolean;
			eq: (other: string | number | Long.Long) => boolean;
			getHighBits: () => number;
			getHighBitsUnsigned: () => number;
			getLowBits: () => number;
			getLowBitsUnsigned: () => number;
			getNumBitsAbs: () => number;
			greaterThan: (other: string | number | Long.Long) => boolean;
			gt: (other: string | number | Long.Long) => boolean;
			greaterThanOrEqual: (other: string | number | Long.Long) => boolean;
			gte: (other: string | number | Long.Long) => boolean;
			isEven: () => boolean;
			isNegative: () => boolean;
			isOdd: () => boolean;
			isPositive: () => boolean;
			isZero: () => boolean;
			lessThan: (other: string | number | Long.Long) => boolean;
			lt: (other: string | number | Long.Long) => boolean;
			lessThanOrEqual: (other: string | number | Long.Long) => boolean;
			lte: (other: string | number | Long.Long) => boolean;
			modulo: (other: string | number | Long.Long) => Long.Long;
			mod: (other: string | number | Long.Long) => Long.Long;
			multiply: (multiplier: string | number | Long.Long) => Long.Long;
			mul: (multiplier: string | number | Long.Long) => Long.Long;
			negate: () => Long.Long;
			neg: () => Long.Long;
			not: () => Long.Long;
			notEquals: (other: string | number | Long.Long) => boolean;
			neq: (other: string | number | Long.Long) => boolean;
			or: (other: string | number | Long.Long) => Long.Long;
			shiftLeft: (numBits: number | Long.Long) => Long.Long;
			shl: (numBits: number | Long.Long) => Long.Long;
			shiftRight: (numBits: number | Long.Long) => Long.Long;
			shr: (numBits: number | Long.Long) => Long.Long;
			shiftRightUnsigned: (numBits: number | Long.Long) => Long.Long;
			shru: (numBits: number | Long.Long) => Long.Long;
			subtract: (subtrahend: string | number | Long.Long) => Long.Long;
			sub: (subtrahend: string | number | Long.Long) => Long.Long;
			toInt: () => number;
			toNumber: () => number;
			toBytes: (le?: boolean) => number[];
			toBytesLE: () => number[];
			toBytesBE: () => number[];
			toSigned: () => Long.Long;
			toString: (radix?: number) => string;
			toUnsigned: () => Long.Long;
			xor: (other: string | number | Long.Long) => Long.Long;
		} & Record<Exclude<keyof I["unbondingHeight"], keyof Long.Long>, never>);
		unbondingTime?: Date;
		commission?: {
			commissionRates?: {
				rate?: string;
				maxRate?: string;
				maxChangeRate?: string;
			};
			updateTime?: Date;
		} & {
			commissionRates?: {
				rate?: string;
				maxRate?: string;
				maxChangeRate?: string;
			} & {
				rate?: string;
				maxRate?: string;
				maxChangeRate?: string;
			} & Record<Exclude<keyof I["commission"]["commissionRates"], keyof CommissionRates>, never>;
			updateTime?: Date;
		} & Record<Exclude<keyof I["commission"], keyof Commission>, never>;
		minSelfDelegation?: string;
	} & Record<Exclude<keyof I, keyof Validator>, never>>(object: I): Validator;
};
declare const Delegation: {
	encode(message: Delegation, writer?: _m0.Writer): _m0.Writer;
	decode(input: _m0.Reader | Uint8Array, length?: number): Delegation;
	fromJSON(object: any): Delegation;
	toJSON(message: Delegation): unknown;
	fromPartial<I extends {
		delegatorAddress?: string;
		validatorAddress?: string;
		shares?: string;
	} & {
		delegatorAddress?: string;
		validatorAddress?: string;
		shares?: string;
	} & Record<Exclude<keyof I, keyof Delegation>, never>>(object: I): Delegation;
};
declare const UnbondingDelegation: {
	encode(message: UnbondingDelegation, writer?: _m0.Writer): _m0.Writer;
	decode(input: _m0.Reader | Uint8Array, length?: number): UnbondingDelegation;
	fromJSON(object: any): UnbondingDelegation;
	toJSON(message: UnbondingDelegation): unknown;
	fromPartial<I extends {
		delegatorAddress?: string;
		validatorAddress?: string;
		entries?: {
			creationHeight?: string | number | Long.Long;
			completionTime?: Date;
			initialBalance?: string;
			balance?: string;
		}[];
	} & {
		delegatorAddress?: string;
		validatorAddress?: string;
		entries?: {
			creationHeight?: string | number | Long.Long;
			completionTime?: Date;
			initialBalance?: string;
			balance?: string;
		}[] & ({
			creationHeight?: string | number | Long.Long;
			completionTime?: Date;
			initialBalance?: string;
			balance?: string;
		} & {
			creationHeight?: string | number | (Long.Long & {
				high: number;
				low: number;
				unsigned: boolean;
				add: (addend: string | number | Long.Long) => Long.Long;
				and: (other: string | number | Long.Long) => Long.Long;
				compare: (other: string | number | Long.Long) => number;
				comp: (other: string | number | Long.Long) => number;
				divide: (divisor: string | number | Long.Long) => Long.Long;
				div: (divisor: string | number | Long.Long) => Long.Long;
				equals: (other: string | number | Long.Long) => boolean;
				eq: (other: string | number | Long.Long) => boolean;
				getHighBits: () => number;
				getHighBitsUnsigned: () => number;
				getLowBits: () => number;
				getLowBitsUnsigned: () => number;
				getNumBitsAbs: () => number;
				greaterThan: (other: string | number | Long.Long) => boolean;
				gt: (other: string | number | Long.Long) => boolean;
				greaterThanOrEqual: (other: string | number | Long.Long) => boolean;
				gte: (other: string | number | Long.Long) => boolean;
				isEven: () => boolean;
				isNegative: () => boolean;
				isOdd: () => boolean;
				isPositive: () => boolean;
				isZero: () => boolean;
				lessThan: (other: string | number | Long.Long) => boolean;
				lt: (other: string | number | Long.Long) => boolean;
				lessThanOrEqual: (other: string | number | Long.Long) => boolean;
				lte: (other: string | number | Long.Long) => boolean;
				modulo: (other: string | number | Long.Long) => Long.Long;
				mod: (other: string | number | Long.Long) => Long.Long;
				multiply: (multiplier: string | number | Long.Long) => Long.Long;
				mul: (multiplier: string | number | Long.Long) => Long.Long;
				negate: () => Long.Long;
				neg: () => Long.Long;
				not: () => Long.Long;
				notEquals: (other: string | number | Long.Long) => boolean;
				neq: (other: string | number | Long.Long) => boolean;
				or: (other: string | number | Long.Long) => Long.Long;
				shiftLeft: (numBits: number | Long.Long) => Long.Long;
				shl: (numBits: number | Long.Long) => Long.Long;
				shiftRight: (numBits: number | Long.Long) => Long.Long;
				shr: (numBits: number | Long.Long) => Long.Long;
				shiftRightUnsigned: (numBits: number | Long.Long) => Long.Long;
				shru: (numBits: number | Long.Long) => Long.Long;
				subtract: (subtrahend: string | number | Long.Long) => Long.Long;
				sub: (subtrahend: string | number | Long.Long) => Long.Long;
				toInt: () => number;
				toNumber: () => number;
				toBytes: (le?: boolean) => number[];
				toBytesLE: () => number[];
				toBytesBE: () => number[];
				toSigned: () => Long.Long;
				toString: (radix?: number) => string;
				toUnsigned: () => Long.Long;
				xor: (other: string | number | Long.Long) => Long.Long;
			} & Record<Exclude<keyof I["entries"][number]["creationHeight"], keyof Long.Long>, never>);
			completionTime?: Date;
			initialBalance?: string;
			balance?: string;
		} & Record<Exclude<keyof I["entries"][number], keyof UnbondingDelegationEntry>, never>)[] & Record<Exclude<keyof I["entries"], keyof {
			creationHeight?: string | number | Long.Long;
			completionTime?: Date;
			initialBalance?: string;
			balance?: string;
		}[]>, never>;
	} & Record<Exclude<keyof I, keyof UnbondingDelegation>, never>>(object: I): UnbondingDelegation;
};
declare const UnbondingDelegationEntry: {
	encode(message: UnbondingDelegationEntry, writer?: _m0.Writer): _m0.Writer;
	decode(input: _m0.Reader | Uint8Array, length?: number): UnbondingDelegationEntry;
	fromJSON(object: any): UnbondingDelegationEntry;
	toJSON(message: UnbondingDelegationEntry): unknown;
	fromPartial<I extends {
		creationHeight?: string | number | Long.Long;
		completionTime?: Date;
		initialBalance?: string;
		balance?: string;
	} & {
		creationHeight?: string | number | (Long.Long & {
			high: number;
			low: number;
			unsigned: boolean;
			add: (addend: string | number | Long.Long) => Long.Long;
			and: (other: string | number | Long.Long) => Long.Long;
			compare: (other: string | number | Long.Long) => number;
			comp: (other: string | number | Long.Long) => number;
			divide: (divisor: string | number | Long.Long) => Long.Long;
			div: (divisor: string | number | Long.Long) => Long.Long;
			equals: (other: string | number | Long.Long) => boolean;
			eq: (other: string | number | Long.Long) => boolean;
			getHighBits: () => number;
			getHighBitsUnsigned: () => number;
			getLowBits: () => number;
			getLowBitsUnsigned: () => number;
			getNumBitsAbs: () => number;
			greaterThan: (other: string | number | Long.Long) => boolean;
			gt: (other: string | number | Long.Long) => boolean;
			greaterThanOrEqual: (other: string | number | Long.Long) => boolean;
			gte: (other: string | number | Long.Long) => boolean;
			isEven: () => boolean;
			isNegative: () => boolean;
			isOdd: () => boolean;
			isPositive: () => boolean;
			isZero: () => boolean;
			lessThan: (other: string | number | Long.Long) => boolean;
			lt: (other: string | number | Long.Long) => boolean;
			lessThanOrEqual: (other: string | number | Long.Long) => boolean;
			lte: (other: string | number | Long.Long) => boolean;
			modulo: (other: string | number | Long.Long) => Long.Long;
			mod: (other: string | number | Long.Long) => Long.Long;
			multiply: (multiplier: string | number | Long.Long) => Long.Long;
			mul: (multiplier: string | number | Long.Long) => Long.Long;
			negate: () => Long.Long;
			neg: () => Long.Long;
			not: () => Long.Long;
			notEquals: (other: string | number | Long.Long) => boolean;
			neq: (other: string | number | Long.Long) => boolean;
			or: (other: string | number | Long.Long) => Long.Long;
			shiftLeft: (numBits: number | Long.Long) => Long.Long;
			shl: (numBits: number | Long.Long) => Long.Long;
			shiftRight: (numBits: number | Long.Long) => Long.Long;
			shr: (numBits: number | Long.Long) => Long.Long;
			shiftRightUnsigned: (numBits: number | Long.Long) => Long.Long;
			shru: (numBits: number | Long.Long) => Long.Long;
			subtract: (subtrahend: string | number | Long.Long) => Long.Long;
			sub: (subtrahend: string | number | Long.Long) => Long.Long;
			toInt: () => number;
			toNumber: () => number;
			toBytes: (le?: boolean) => number[];
			toBytesLE: () => number[];
			toBytesBE: () => number[];
			toSigned: () => Long.Long;
			toString: (radix?: number) => string;
			toUnsigned: () => Long.Long;
			xor: (other: string | number | Long.Long) => Long.Long;
		} & Record<Exclude<keyof I["creationHeight"], keyof Long.Long>, never>);
		completionTime?: Date;
		initialBalance?: string;
		balance?: string;
	} & Record<Exclude<keyof I, keyof UnbondingDelegationEntry>, never>>(object: I): UnbondingDelegationEntry;
};
declare const RedelegationEntry: {
	encode(message: RedelegationEntry, writer?: _m0.Writer): _m0.Writer;
	decode(input: _m0.Reader | Uint8Array, length?: number): RedelegationEntry;
	fromJSON(object: any): RedelegationEntry;
	toJSON(message: RedelegationEntry): unknown;
	fromPartial<I extends {
		creationHeight?: string | number | Long.Long;
		completionTime?: Date;
		initialBalance?: string;
		sharesDst?: string;
	} & {
		creationHeight?: string | number | (Long.Long & {
			high: number;
			low: number;
			unsigned: boolean;
			add: (addend: string | number | Long.Long) => Long.Long;
			and: (other: string | number | Long.Long) => Long.Long;
			compare: (other: string | number | Long.Long) => number;
			comp: (other: string | number | Long.Long) => number;
			divide: (divisor: string | number | Long.Long) => Long.Long;
			div: (divisor: string | number | Long.Long) => Long.Long;
			equals: (other: string | number | Long.Long) => boolean;
			eq: (other: string | number | Long.Long) => boolean;
			getHighBits: () => number;
			getHighBitsUnsigned: () => number;
			getLowBits: () => number;
			getLowBitsUnsigned: () => number;
			getNumBitsAbs: () => number;
			greaterThan: (other: string | number | Long.Long) => boolean;
			gt: (other: string | number | Long.Long) => boolean;
			greaterThanOrEqual: (other: string | number | Long.Long) => boolean;
			gte: (other: string | number | Long.Long) => boolean;
			isEven: () => boolean;
			isNegative: () => boolean;
			isOdd: () => boolean;
			isPositive: () => boolean;
			isZero: () => boolean;
			lessThan: (other: string | number | Long.Long) => boolean;
			lt: (other: string | number | Long.Long) => boolean;
			lessThanOrEqual: (other: string | number | Long.Long) => boolean;
			lte: (other: string | number | Long.Long) => boolean;
			modulo: (other: string | number | Long.Long) => Long.Long;
			mod: (other: string | number | Long.Long) => Long.Long;
			multiply: (multiplier: string | number | Long.Long) => Long.Long;
			mul: (multiplier: string | number | Long.Long) => Long.Long;
			negate: () => Long.Long;
			neg: () => Long.Long;
			not: () => Long.Long;
			notEquals: (other: string | number | Long.Long) => boolean;
			neq: (other: string | number | Long.Long) => boolean;
			or: (other: string | number | Long.Long) => Long.Long;
			shiftLeft: (numBits: number | Long.Long) => Long.Long;
			shl: (numBits: number | Long.Long) => Long.Long;
			shiftRight: (numBits: number | Long.Long) => Long.Long;
			shr: (numBits: number | Long.Long) => Long.Long;
			shiftRightUnsigned: (numBits: number | Long.Long) => Long.Long;
			shru: (numBits: number | Long.Long) => Long.Long;
			subtract: (subtrahend: string | number | Long.Long) => Long.Long;
			sub: (subtrahend: string | number | Long.Long) => Long.Long;
			toInt: () => number;
			toNumber: () => number;
			toBytes: (le?: boolean) => number[];
			toBytesLE: () => number[];
			toBytesBE: () => number[];
			toSigned: () => Long.Long;
			toString: (radix?: number) => string;
			toUnsigned: () => Long.Long;
			xor: (other: string | number | Long.Long) => Long.Long;
		} & Record<Exclude<keyof I["creationHeight"], keyof Long.Long>, never>);
		completionTime?: Date;
		initialBalance?: string;
		sharesDst?: string;
	} & Record<Exclude<keyof I, keyof RedelegationEntry>, never>>(object: I): RedelegationEntry;
};
declare const Redelegation: {
	encode(message: Redelegation, writer?: _m0.Writer): _m0.Writer;
	decode(input: _m0.Reader | Uint8Array, length?: number): Redelegation;
	fromJSON(object: any): Redelegation;
	toJSON(message: Redelegation): unknown;
	fromPartial<I extends {
		delegatorAddress?: string;
		validatorSrcAddress?: string;
		validatorDstAddress?: string;
		entries?: {
			creationHeight?: string | number | Long.Long;
			completionTime?: Date;
			initialBalance?: string;
			sharesDst?: string;
		}[];
	} & {
		delegatorAddress?: string;
		validatorSrcAddress?: string;
		validatorDstAddress?: string;
		entries?: {
			creationHeight?: string | number | Long.Long;
			completionTime?: Date;
			initialBalance?: string;
			sharesDst?: string;
		}[] & ({
			creationHeight?: string | number | Long.Long;
			completionTime?: Date;
			initialBalance?: string;
			sharesDst?: string;
		} & {
			creationHeight?: string | number | (Long.Long & {
				high: number;
				low: number;
				unsigned: boolean;
				add: (addend: string | number | Long.Long) => Long.Long;
				and: (other: string | number | Long.Long) => Long.Long;
				compare: (other: string | number | Long.Long) => number;
				comp: (other: string | number | Long.Long) => number;
				divide: (divisor: string | number | Long.Long) => Long.Long;
				div: (divisor: string | number | Long.Long) => Long.Long;
				equals: (other: string | number | Long.Long) => boolean;
				eq: (other: string | number | Long.Long) => boolean;
				getHighBits: () => number;
				getHighBitsUnsigned: () => number;
				getLowBits: () => number;
				getLowBitsUnsigned: () => number;
				getNumBitsAbs: () => number;
				greaterThan: (other: string | number | Long.Long) => boolean;
				gt: (other: string | number | Long.Long) => boolean;
				greaterThanOrEqual: (other: string | number | Long.Long) => boolean;
				gte: (other: string | number | Long.Long) => boolean;
				isEven: () => boolean;
				isNegative: () => boolean;
				isOdd: () => boolean;
				isPositive: () => boolean;
				isZero: () => boolean;
				lessThan: (other: string | number | Long.Long) => boolean;
				lt: (other: string | number | Long.Long) => boolean;
				lessThanOrEqual: (other: string | number | Long.Long) => boolean;
				lte: (other: string | number | Long.Long) => boolean;
				modulo: (other: string | number | Long.Long) => Long.Long;
				mod: (other: string | number | Long.Long) => Long.Long;
				multiply: (multiplier: string | number | Long.Long) => Long.Long;
				mul: (multiplier: string | number | Long.Long) => Long.Long;
				negate: () => Long.Long;
				neg: () => Long.Long;
				not: () => Long.Long;
				notEquals: (other: string | number | Long.Long) => boolean;
				neq: (other: string | number | Long.Long) => boolean;
				or: (other: string | number | Long.Long) => Long.Long;
				shiftLeft: (numBits: number | Long.Long) => Long.Long;
				shl: (numBits: number | Long.Long) => Long.Long;
				shiftRight: (numBits: number | Long.Long) => Long.Long;
				shr: (numBits: number | Long.Long) => Long.Long;
				shiftRightUnsigned: (numBits: number | Long.Long) => Long.Long;
				shru: (numBits: number | Long.Long) => Long.Long;
				subtract: (subtrahend: string | number | Long.Long) => Long.Long;
				sub: (subtrahend: string | number | Long.Long) => Long.Long;
				toInt: () => number;
				toNumber: () => number;
				toBytes: (le?: boolean) => number[];
				toBytesLE: () => number[];
				toBytesBE: () => number[];
				toSigned: () => Long.Long;
				toString: (radix?: number) => string;
				toUnsigned: () => Long.Long;
				xor: (other: string | number | Long.Long) => Long.Long;
			} & Record<Exclude<keyof I["entries"][number]["creationHeight"], keyof Long.Long>, never>);
			completionTime?: Date;
			initialBalance?: string;
			sharesDst?: string;
		} & Record<Exclude<keyof I["entries"][number], keyof RedelegationEntry>, never>)[] & Record<Exclude<keyof I["entries"], keyof {
			creationHeight?: string | number | Long.Long;
			completionTime?: Date;
			initialBalance?: string;
			sharesDst?: string;
		}[]>, never>;
	} & Record<Exclude<keyof I, keyof Redelegation>, never>>(object: I): Redelegation;
};
declare const Params: {
	encode(message: Params, writer?: _m0.Writer): _m0.Writer;
	decode(input: _m0.Reader | Uint8Array, length?: number): Params;
	fromJSON(object: any): Params;
	toJSON(message: Params): unknown;
	fromPartial<I extends {
		unbondingTime?: {
			seconds?: string | number | Long.Long;
			nanos?: number;
		};
		maxValidators?: number;
		maxEntries?: number;
		historicalEntries?: number;
		bondDenom?: string;
	} & {
		unbondingTime?: {
			seconds?: string | number | Long.Long;
			nanos?: number;
		} & {
			seconds?: string | number | (Long.Long & {
				high: number;
				low: number;
				unsigned: boolean;
				add: (addend: string | number | Long.Long) => Long.Long;
				and: (other: string | number | Long.Long) => Long.Long;
				compare: (other: string | number | Long.Long) => number;
				comp: (other: string | number | Long.Long) => number;
				divide: (divisor: string | number | Long.Long) => Long.Long;
				div: (divisor: string | number | Long.Long) => Long.Long;
				equals: (other: string | number | Long.Long) => boolean;
				eq: (other: string | number | Long.Long) => boolean;
				getHighBits: () => number;
				getHighBitsUnsigned: () => number;
				getLowBits: () => number;
				getLowBitsUnsigned: () => number;
				getNumBitsAbs: () => number;
				greaterThan: (other: string | number | Long.Long) => boolean;
				gt: (other: string | number | Long.Long) => boolean;
				greaterThanOrEqual: (other: string | number | Long.Long) => boolean;
				gte: (other: string | number | Long.Long) => boolean;
				isEven: () => boolean;
				isNegative: () => boolean;
				isOdd: () => boolean;
				isPositive: () => boolean;
				isZero: () => boolean;
				lessThan: (other: string | number | Long.Long) => boolean;
				lt: (other: string | number | Long.Long) => boolean;
				lessThanOrEqual: (other: string | number | Long.Long) => boolean;
				lte: (other: string | number | Long.Long) => boolean;
				modulo: (other: string | number | Long.Long) => Long.Long;
				mod: (other: string | number | Long.Long) => Long.Long;
				multiply: (multiplier: string | number | Long.Long) => Long.Long;
				mul: (multiplier: string | number | Long.Long) => Long.Long;
				negate: () => Long.Long;
				neg: () => Long.Long;
				not: () => Long.Long;
				notEquals: (other: string | number | Long.Long) => boolean;
				neq: (other: string | number | Long.Long) => boolean;
				or: (other: string | number | Long.Long) => Long.Long;
				shiftLeft: (numBits: number | Long.Long) => Long.Long;
				shl: (numBits: number | Long.Long) => Long.Long;
				shiftRight: (numBits: number | Long.Long) => Long.Long;
				shr: (numBits: number | Long.Long) => Long.Long;
				shiftRightUnsigned: (numBits: number | Long.Long) => Long.Long;
				shru: (numBits: number | Long.Long) => Long.Long;
				subtract: (subtrahend: string | number | Long.Long) => Long.Long;
				sub: (subtrahend: string | number | Long.Long) => Long.Long;
				toInt: () => number;
				toNumber: () => number;
				toBytes: (le?: boolean) => number[];
				toBytesLE: () => number[];
				toBytesBE: () => number[];
				toSigned: () => Long.Long;
				toString: (radix?: number) => string;
				toUnsigned: () => Long.Long;
				xor: (other: string | number | Long.Long) => Long.Long;
			} & Record<Exclude<keyof I["unbondingTime"]["seconds"], keyof Long.Long>, never>);
			nanos?: number;
		} & Record<Exclude<keyof I["unbondingTime"], keyof Duration>, never>;
		maxValidators?: number;
		maxEntries?: number;
		historicalEntries?: number;
		bondDenom?: string;
	} & Record<Exclude<keyof I, keyof Params>, never>>(object: I): Params;
};
declare const DelegationResponse: {
	encode(message: DelegationResponse, writer?: _m0.Writer): _m0.Writer;
	decode(input: _m0.Reader | Uint8Array, length?: number): DelegationResponse;
	fromJSON(object: any): DelegationResponse;
	toJSON(message: DelegationResponse): unknown;
	fromPartial<I extends {
		delegation?: {
			delegatorAddress?: string;
			validatorAddress?: string;
			shares?: string;
		};
		balance?: {
			denom?: string;
			amount?: string;
		};
	} & {
		delegation?: {
			delegatorAddress?: string;
			validatorAddress?: string;
			shares?: string;
		} & {
			delegatorAddress?: string;
			validatorAddress?: string;
			shares?: string;
		} & Record<Exclude<keyof I["delegation"], keyof Delegation>, never>;
		balance?: {
			denom?: string;
			amount?: string;
		} & {
			denom?: string;
			amount?: string;
		} & Record<Exclude<keyof I["balance"], keyof Coin>, never>;
	} & Record<Exclude<keyof I, keyof DelegationResponse>, never>>(object: I): DelegationResponse;
};
declare const RedelegationEntryResponse: {
	encode(message: RedelegationEntryResponse, writer?: _m0.Writer): _m0.Writer;
	decode(input: _m0.Reader | Uint8Array, length?: number): RedelegationEntryResponse;
	fromJSON(object: any): RedelegationEntryResponse;
	toJSON(message: RedelegationEntryResponse): unknown;
	fromPartial<I extends {
		redelegationEntry?: {
			creationHeight?: string | number | Long.Long;
			completionTime?: Date;
			initialBalance?: string;
			sharesDst?: string;
		};
		balance?: string;
	} & {
		redelegationEntry?: {
			creationHeight?: string | number | Long.Long;
			completionTime?: Date;
			initialBalance?: string;
			sharesDst?: string;
		} & {
			creationHeight?: string | number | (Long.Long & {
				high: number;
				low: number;
				unsigned: boolean;
				add: (addend: string | number | Long.Long) => Long.Long;
				and: (other: string | number | Long.Long) => Long.Long;
				compare: (other: string | number | Long.Long) => number;
				comp: (other: string | number | Long.Long) => number;
				divide: (divisor: string | number | Long.Long) => Long.Long;
				div: (divisor: string | number | Long.Long) => Long.Long;
				equals: (other: string | number | Long.Long) => boolean;
				eq: (other: string | number | Long.Long) => boolean;
				getHighBits: () => number;
				getHighBitsUnsigned: () => number;
				getLowBits: () => number;
				getLowBitsUnsigned: () => number;
				getNumBitsAbs: () => number;
				greaterThan: (other: string | number | Long.Long) => boolean;
				gt: (other: string | number | Long.Long) => boolean;
				greaterThanOrEqual: (other: string | number | Long.Long) => boolean;
				gte: (other: string | number | Long.Long) => boolean;
				isEven: () => boolean;
				isNegative: () => boolean;
				isOdd: () => boolean;
				isPositive: () => boolean;
				isZero: () => boolean;
				lessThan: (other: string | number | Long.Long) => boolean;
				lt: (other: string | number | Long.Long) => boolean;
				lessThanOrEqual: (other: string | number | Long.Long) => boolean;
				lte: (other: string | number | Long.Long) => boolean;
				modulo: (other: string | number | Long.Long) => Long.Long;
				mod: (other: string | number | Long.Long) => Long.Long;
				multiply: (multiplier: string | number | Long.Long) => Long.Long;
				mul: (multiplier: string | number | Long.Long) => Long.Long;
				negate: () => Long.Long;
				neg: () => Long.Long;
				not: () => Long.Long;
				notEquals: (other: string | number | Long.Long) => boolean;
				neq: (other: string | number | Long.Long) => boolean;
				or: (other: string | number | Long.Long) => Long.Long;
				shiftLeft: (numBits: number | Long.Long) => Long.Long;
				shl: (numBits: number | Long.Long) => Long.Long;
				shiftRight: (numBits: number | Long.Long) => Long.Long;
				shr: (numBits: number | Long.Long) => Long.Long;
				shiftRightUnsigned: (numBits: number | Long.Long) => Long.Long;
				shru: (numBits: number | Long.Long) => Long.Long;
				subtract: (subtrahend: string | number | Long.Long) => Long.Long;
				sub: (subtrahend: string | number | Long.Long) => Long.Long;
				toInt: () => number;
				toNumber: () => number;
				toBytes: (le?: boolean) => number[];
				toBytesLE: () => number[];
				toBytesBE: () => number[];
				toSigned: () => Long.Long;
				toString: (radix?: number) => string;
				toUnsigned: () => Long.Long;
				xor: (other: string | number | Long.Long) => Long.Long;
			} & Record<Exclude<keyof I["redelegationEntry"]["creationHeight"], keyof Long.Long>, never>);
			completionTime?: Date;
			initialBalance?: string;
			sharesDst?: string;
		} & Record<Exclude<keyof I["redelegationEntry"], keyof RedelegationEntry>, never>;
		balance?: string;
	} & Record<Exclude<keyof I, keyof RedelegationEntryResponse>, never>>(object: I): RedelegationEntryResponse;
};
declare const RedelegationResponse: {
	encode(message: RedelegationResponse, writer?: _m0.Writer): _m0.Writer;
	decode(input: _m0.Reader | Uint8Array, length?: number): RedelegationResponse;
	fromJSON(object: any): RedelegationResponse;
	toJSON(message: RedelegationResponse): unknown;
	fromPartial<I extends {
		redelegation?: {
			delegatorAddress?: string;
			validatorSrcAddress?: string;
			validatorDstAddress?: string;
			entries?: {
				creationHeight?: string | number | Long.Long;
				completionTime?: Date;
				initialBalance?: string;
				sharesDst?: string;
			}[];
		};
		entries?: {
			redelegationEntry?: {
				creationHeight?: string | number | Long.Long;
				completionTime?: Date;
				initialBalance?: string;
				sharesDst?: string;
			};
			balance?: string;
		}[];
	} & {
		redelegation?: {
			delegatorAddress?: string;
			validatorSrcAddress?: string;
			validatorDstAddress?: string;
			entries?: {
				creationHeight?: string | number | Long.Long;
				completionTime?: Date;
				initialBalance?: string;
				sharesDst?: string;
			}[];
		} & {
			delegatorAddress?: string;
			validatorSrcAddress?: string;
			validatorDstAddress?: string;
			entries?: {
				creationHeight?: string | number | Long.Long;
				completionTime?: Date;
				initialBalance?: string;
				sharesDst?: string;
			}[] & ({
				creationHeight?: string | number | Long.Long;
				completionTime?: Date;
				initialBalance?: string;
				sharesDst?: string;
			} & {
				creationHeight?: string | number | (Long.Long & {
					high: number;
					low: number;
					unsigned: boolean;
					add: (addend: string | number | Long.Long) => Long.Long;
					and: (other: string | number | Long.Long) => Long.Long;
					compare: (other: string | number | Long.Long) => number;
					comp: (other: string | number | Long.Long) => number;
					divide: (divisor: string | number | Long.Long) => Long.Long;
					div: (divisor: string | number | Long.Long) => Long.Long;
					equals: (other: string | number | Long.Long) => boolean;
					eq: (other: string | number | Long.Long) => boolean;
					getHighBits: () => number;
					getHighBitsUnsigned: () => number;
					getLowBits: () => number;
					getLowBitsUnsigned: () => number;
					getNumBitsAbs: () => number;
					greaterThan: (other: string | number | Long.Long) => boolean;
					gt: (other: string | number | Long.Long) => boolean;
					greaterThanOrEqual: (other: string | number | Long.Long) => boolean;
					gte: (other: string | number | Long.Long) => boolean;
					isEven: () => boolean;
					isNegative: () => boolean;
					isOdd: () => boolean;
					isPositive: () => boolean;
					isZero: () => boolean;
					lessThan: (other: string | number | Long.Long) => boolean;
					lt: (other: string | number | Long.Long) => boolean;
					lessThanOrEqual: (other: string | number | Long.Long) => boolean;
					lte: (other: string | number | Long.Long) => boolean;
					modulo: (other: string | number | Long.Long) => Long.Long;
					mod: (other: string | number | Long.Long) => Long.Long;
					multiply: (multiplier: string | number | Long.Long) => Long.Long;
					mul: (multiplier: string | number | Long.Long) => Long.Long;
					negate: () => Long.Long;
					neg: () => Long.Long;
					not: () => Long.Long;
					notEquals: (other: string | number | Long.Long) => boolean;
					neq: (other: string | number | Long.Long) => boolean;
					or: (other: string | number | Long.Long) => Long.Long;
					shiftLeft: (numBits: number | Long.Long) => Long.Long;
					shl: (numBits: number | Long.Long) => Long.Long;
					shiftRight: (numBits: number | Long.Long) => Long.Long;
					shr: (numBits: number | Long.Long) => Long.Long;
					shiftRightUnsigned: (numBits: number | Long.Long) => Long.Long;
					shru: (numBits: number | Long.Long) => Long.Long;
					subtract: (subtrahend: string | number | Long.Long) => Long.Long;
					sub: (subtrahend: string | number | Long.Long) => Long.Long;
					toInt: () => number;
					toNumber: () => number;
					toBytes: (le?: boolean) => number[];
					toBytesLE: () => number[];
					toBytesBE: () => number[];
					toSigned: () => Long.Long;
					toString: (radix?: number) => string;
					toUnsigned: () => Long.Long;
					xor: (other: string | number | Long.Long) => Long.Long;
				} & Record<Exclude<keyof I["redelegation"]["entries"][number]["creationHeight"], keyof Long.Long>, never>);
				completionTime?: Date;
				initialBalance?: string;
				sharesDst?: string;
			} & Record<Exclude<keyof I["redelegation"]["entries"][number], keyof RedelegationEntry>, never>)[] & Record<Exclude<keyof I["redelegation"]["entries"], keyof {
				creationHeight?: string | number | Long.Long;
				completionTime?: Date;
				initialBalance?: string;
				sharesDst?: string;
			}[]>, never>;
		} & Record<Exclude<keyof I["redelegation"], keyof Redelegation>, never>;
		entries?: {
			redelegationEntry?: {
				creationHeight?: string | number | Long.Long;
				completionTime?: Date;
				initialBalance?: string;
				sharesDst?: string;
			};
			balance?: string;
		}[] & ({
			redelegationEntry?: {
				creationHeight?: string | number | Long.Long;
				completionTime?: Date;
				initialBalance?: string;
				sharesDst?: string;
			};
			balance?: string;
		} & {
			redelegationEntry?: {
				creationHeight?: string | number | Long.Long;
				completionTime?: Date;
				initialBalance?: string;
				sharesDst?: string;
			} & {
				creationHeight?: string | number | (Long.Long & {
					high: number;
					low: number;
					unsigned: boolean;
					add: (addend: string | number | Long.Long) => Long.Long;
					and: (other: string | number | Long.Long) => Long.Long;
					compare: (other: string | number | Long.Long) => number;
					comp: (other: string | number | Long.Long) => number;
					divide: (divisor: string | number | Long.Long) => Long.Long;
					div: (divisor: string | number | Long.Long) => Long.Long;
					equals: (other: string | number | Long.Long) => boolean;
					eq: (other: string | number | Long.Long) => boolean;
					getHighBits: () => number;
					getHighBitsUnsigned: () => number;
					getLowBits: () => number;
					getLowBitsUnsigned: () => number;
					getNumBitsAbs: () => number;
					greaterThan: (other: string | number | Long.Long) => boolean;
					gt: (other: string | number | Long.Long) => boolean;
					greaterThanOrEqual: (other: string | number | Long.Long) => boolean;
					gte: (other: string | number | Long.Long) => boolean;
					isEven: () => boolean;
					isNegative: () => boolean;
					isOdd: () => boolean;
					isPositive: () => boolean;
					isZero: () => boolean;
					lessThan: (other: string | number | Long.Long) => boolean;
					lt: (other: string | number | Long.Long) => boolean;
					lessThanOrEqual: (other: string | number | Long.Long) => boolean;
					lte: (other: string | number | Long.Long) => boolean;
					modulo: (other: string | number | Long.Long) => Long.Long;
					mod: (other: string | number | Long.Long) => Long.Long;
					multiply: (multiplier: string | number | Long.Long) => Long.Long;
					mul: (multiplier: string | number | Long.Long) => Long.Long;
					negate: () => Long.Long;
					neg: () => Long.Long;
					not: () => Long.Long;
					notEquals: (other: string | number | Long.Long) => boolean;
					neq: (other: string | number | Long.Long) => boolean;
					or: (other: string | number | Long.Long) => Long.Long;
					shiftLeft: (numBits: number | Long.Long) => Long.Long;
					shl: (numBits: number | Long.Long) => Long.Long;
					shiftRight: (numBits: number | Long.Long) => Long.Long;
					shr: (numBits: number | Long.Long) => Long.Long;
					shiftRightUnsigned: (numBits: number | Long.Long) => Long.Long;
					shru: (numBits: number | Long.Long) => Long.Long;
					subtract: (subtrahend: string | number | Long.Long) => Long.Long;
					sub: (subtrahend: string | number | Long.Long) => Long.Long;
					toInt: () => number;
					toNumber: () => number;
					toBytes: (le?: boolean) => number[];
					toBytesLE: () => number[];
					toBytesBE: () => number[];
					toSigned: () => Long.Long;
					toString: (radix?: number) => string;
					toUnsigned: () => Long.Long;
					xor: (other: string | number | Long.Long) => Long.Long;
				} & Record<Exclude<keyof I["entries"][number]["redelegationEntry"]["creationHeight"], keyof Long.Long>, never>);
				completionTime?: Date;
				initialBalance?: string;
				sharesDst?: string;
			} & Record<Exclude<keyof I["entries"][number]["redelegationEntry"], keyof RedelegationEntry>, never>;
			balance?: string;
		} & Record<Exclude<keyof I["entries"][number], keyof RedelegationEntryResponse>, never>)[] & Record<Exclude<keyof I["entries"], keyof {
			redelegationEntry?: {
				creationHeight?: string | number | Long.Long;
				completionTime?: Date;
				initialBalance?: string;
				sharesDst?: string;
			};
			balance?: string;
		}[]>, never>;
	} & Record<Exclude<keyof I, keyof RedelegationResponse>, never>>(object: I): RedelegationResponse;
};
declare const Pool: {
	encode(message: Pool, writer?: _m0.Writer): _m0.Writer;
	decode(input: _m0.Reader | Uint8Array, length?: number): Pool;
	fromJSON(object: any): Pool;
	toJSON(message: Pool): unknown;
	fromPartial<I extends {
		notBondedTokens?: string;
		bondedTokens?: string;
	} & {
		notBondedTokens?: string;
		bondedTokens?: string;
	} & Record<Exclude<keyof I, keyof Pool>, never>>(object: I): Pool;
};
/** QueryValidatorsRequest is request type for Query/Validators RPC method. */
export interface QueryValidatorsRequest {
	/** status enables to query for validators matching a given status. */
	status: string;
	/** pagination defines an optional pagination for the request. */
	pagination?: PageRequest;
}
/** QueryValidatorsResponse is response type for the Query/Validators RPC method */
export interface QueryValidatorsResponse {
	/** validators contains all the queried validators. */
	validators: Validator[];
	/** pagination defines the pagination in the response. */
	pagination?: PageResponse;
}
/** QueryValidatorRequest is response type for the Query/Validator RPC method */
export interface QueryValidatorRequest {
	/** validator_addr defines the validator address to query for. */
	validatorAddr: string;
}
/** QueryValidatorResponse is response type for the Query/Validator RPC method */
export interface QueryValidatorResponse {
	/** validator defines the the validator info. */
	validator?: Validator;
}
/**
 * QueryValidatorDelegationsRequest is request type for the
 * Query/ValidatorDelegations RPC method
 */
export interface QueryValidatorDelegationsRequest {
	/** validator_addr defines the validator address to query for. */
	validatorAddr: string;
	/** pagination defines an optional pagination for the request. */
	pagination?: PageRequest;
}
/**
 * QueryValidatorDelegationsResponse is response type for the
 * Query/ValidatorDelegations RPC method
 */
export interface QueryValidatorDelegationsResponse {
	delegationResponses: DelegationResponse[];
	/** pagination defines the pagination in the response. */
	pagination?: PageResponse;
}
/**
 * QueryValidatorUnbondingDelegationsRequest is required type for the
 * Query/ValidatorUnbondingDelegations RPC method
 */
export interface QueryValidatorUnbondingDelegationsRequest {
	/** validator_addr defines the validator address to query for. */
	validatorAddr: string;
	/** pagination defines an optional pagination for the request. */
	pagination?: PageRequest;
}
/**
 * QueryValidatorUnbondingDelegationsResponse is response type for the
 * Query/ValidatorUnbondingDelegations RPC method.
 */
export interface QueryValidatorUnbondingDelegationsResponse {
	unbondingResponses: UnbondingDelegation[];
	/** pagination defines the pagination in the response. */
	pagination?: PageResponse;
}
/** QueryDelegationRequest is request type for the Query/Delegation RPC method. */
export interface QueryDelegationRequest {
	/** delegator_addr defines the delegator address to query for. */
	delegatorAddr: string;
	/** validator_addr defines the validator address to query for. */
	validatorAddr: string;
}
/** QueryDelegationResponse is response type for the Query/Delegation RPC method. */
export interface QueryDelegationResponse {
	/** delegation_responses defines the delegation info of a delegation. */
	delegationResponse?: DelegationResponse;
}
/**
 * QueryUnbondingDelegationRequest is request type for the
 * Query/UnbondingDelegation RPC method.
 */
export interface QueryUnbondingDelegationRequest {
	/** delegator_addr defines the delegator address to query for. */
	delegatorAddr: string;
	/** validator_addr defines the validator address to query for. */
	validatorAddr: string;
}
/**
 * QueryDelegationResponse is response type for the Query/UnbondingDelegation
 * RPC method.
 */
export interface QueryUnbondingDelegationResponse {
	/** unbond defines the unbonding information of a delegation. */
	unbond?: UnbondingDelegation;
}
/**
 * QueryDelegatorDelegationsRequest is request type for the
 * Query/DelegatorDelegations RPC method.
 */
export interface QueryDelegatorDelegationsRequest {
	/** delegator_addr defines the delegator address to query for. */
	delegatorAddr: string;
	/** pagination defines an optional pagination for the request. */
	pagination?: PageRequest;
}
/**
 * QueryDelegatorDelegationsResponse is response type for the
 * Query/DelegatorDelegations RPC method.
 */
export interface QueryDelegatorDelegationsResponse {
	/** delegation_responses defines all the delegations' info of a delegator. */
	delegationResponses: DelegationResponse[];
	/** pagination defines the pagination in the response. */
	pagination?: PageResponse;
}
/**
 * QueryDelegatorUnbondingDelegationsRequest is request type for the
 * Query/DelegatorUnbondingDelegations RPC method.
 */
export interface QueryDelegatorUnbondingDelegationsRequest {
	/** delegator_addr defines the delegator address to query for. */
	delegatorAddr: string;
	/** pagination defines an optional pagination for the request. */
	pagination?: PageRequest;
}
/**
 * QueryUnbondingDelegatorDelegationsResponse is response type for the
 * Query/UnbondingDelegatorDelegations RPC method.
 */
export interface QueryDelegatorUnbondingDelegationsResponse {
	unbondingResponses: UnbondingDelegation[];
	/** pagination defines the pagination in the response. */
	pagination?: PageResponse;
}
/**
 * QueryRedelegationsRequest is request type for the Query/Redelegations RPC
 * method.
 */
export interface QueryRedelegationsRequest {
	/** delegator_addr defines the delegator address to query for. */
	delegatorAddr: string;
	/** src_validator_addr defines the validator address to redelegate from. */
	srcValidatorAddr: string;
	/** dst_validator_addr defines the validator address to redelegate to. */
	dstValidatorAddr: string;
	/** pagination defines an optional pagination for the request. */
	pagination?: PageRequest;
}
/**
 * QueryRedelegationsResponse is response type for the Query/Redelegations RPC
 * method.
 */
export interface QueryRedelegationsResponse {
	redelegationResponses: RedelegationResponse[];
	/** pagination defines the pagination in the response. */
	pagination?: PageResponse;
}
/**
 * QueryDelegatorValidatorsRequest is request type for the
 * Query/DelegatorValidators RPC method.
 */
export interface QueryDelegatorValidatorsRequest {
	/** delegator_addr defines the delegator address to query for. */
	delegatorAddr: string;
	/** pagination defines an optional pagination for the request. */
	pagination?: PageRequest;
}
/**
 * QueryDelegatorValidatorsResponse is response type for the
 * Query/DelegatorValidators RPC method.
 */
export interface QueryDelegatorValidatorsResponse {
	/** validators defines the the validators' info of a delegator. */
	validators: Validator[];
	/** pagination defines the pagination in the response. */
	pagination?: PageResponse;
}
/**
 * QueryDelegatorValidatorRequest is request type for the
 * Query/DelegatorValidator RPC method.
 */
export interface QueryDelegatorValidatorRequest {
	/** delegator_addr defines the delegator address to query for. */
	delegatorAddr: string;
	/** validator_addr defines the validator address to query for. */
	validatorAddr: string;
}
/**
 * QueryDelegatorValidatorResponse response type for the
 * Query/DelegatorValidator RPC method.
 */
export interface QueryDelegatorValidatorResponse {
	/** validator defines the the validator info. */
	validator?: Validator;
}
/**
 * QueryHistoricalInfoRequest is request type for the Query/HistoricalInfo RPC
 * method.
 */
export interface QueryHistoricalInfoRequest {
	/** height defines at which height to query the historical info. */
	height: Long;
}
/**
 * QueryHistoricalInfoResponse is response type for the Query/HistoricalInfo RPC
 * method.
 */
export interface QueryHistoricalInfoResponse {
	/** hist defines the historical info at the given height. */
	hist?: HistoricalInfo;
}
/** QueryPoolRequest is request type for the Query/Pool RPC method. */
export interface QueryPoolRequest {
}
/** QueryPoolResponse is response type for the Query/Pool RPC method. */
export interface QueryPoolResponse {
	/** pool defines the pool info. */
	pool?: Pool;
}
/** QueryParamsRequest is request type for the Query/Params RPC method. */
export interface QueryParamsRequest {
}
/** QueryParamsResponse is response type for the Query/Params RPC method. */
export interface QueryParamsResponse {
	/** params holds all the parameters of this module. */
	params?: Params;
}
declare const QueryValidatorsRequest: {
	encode(message: QueryValidatorsRequest, writer?: _m0.Writer): _m0.Writer;
	decode(input: _m0.Reader | Uint8Array, length?: number): QueryValidatorsRequest;
	fromJSON(object: any): QueryValidatorsRequest;
	toJSON(message: QueryValidatorsRequest): unknown;
	fromPartial<I extends {
		status?: string;
		pagination?: {
			key?: Uint8Array;
			offset?: string | number | Long.Long;
			limit?: string | number | Long.Long;
			countTotal?: boolean;
			reverse?: boolean;
		};
	} & {
		status?: string;
		pagination?: {
			key?: Uint8Array;
			offset?: string | number | Long.Long;
			limit?: string | number | Long.Long;
			countTotal?: boolean;
			reverse?: boolean;
		} & {
			key?: Uint8Array;
			offset?: string | number | (Long.Long & {
				high: number;
				low: number;
				unsigned: boolean;
				add: (addend: string | number | Long.Long) => Long.Long;
				and: (other: string | number | Long.Long) => Long.Long;
				compare: (other: string | number | Long.Long) => number;
				comp: (other: string | number | Long.Long) => number;
				divide: (divisor: string | number | Long.Long) => Long.Long;
				div: (divisor: string | number | Long.Long) => Long.Long;
				equals: (other: string | number | Long.Long) => boolean;
				eq: (other: string | number | Long.Long) => boolean;
				getHighBits: () => number;
				getHighBitsUnsigned: () => number;
				getLowBits: () => number;
				getLowBitsUnsigned: () => number;
				getNumBitsAbs: () => number;
				greaterThan: (other: string | number | Long.Long) => boolean;
				gt: (other: string | number | Long.Long) => boolean;
				greaterThanOrEqual: (other: string | number | Long.Long) => boolean;
				gte: (other: string | number | Long.Long) => boolean;
				isEven: () => boolean;
				isNegative: () => boolean;
				isOdd: () => boolean;
				isPositive: () => boolean;
				isZero: () => boolean;
				lessThan: (other: string | number | Long.Long) => boolean;
				lt: (other: string | number | Long.Long) => boolean;
				lessThanOrEqual: (other: string | number | Long.Long) => boolean;
				lte: (other: string | number | Long.Long) => boolean;
				modulo: (other: string | number | Long.Long) => Long.Long;
				mod: (other: string | number | Long.Long) => Long.Long;
				multiply: (multiplier: string | number | Long.Long) => Long.Long;
				mul: (multiplier: string | number | Long.Long) => Long.Long;
				negate: () => Long.Long;
				neg: () => Long.Long;
				not: () => Long.Long;
				notEquals: (other: string | number | Long.Long) => boolean;
				neq: (other: string | number | Long.Long) => boolean;
				or: (other: string | number | Long.Long) => Long.Long;
				shiftLeft: (numBits: number | Long.Long) => Long.Long;
				shl: (numBits: number | Long.Long) => Long.Long;
				shiftRight: (numBits: number | Long.Long) => Long.Long;
				shr: (numBits: number | Long.Long) => Long.Long;
				shiftRightUnsigned: (numBits: number | Long.Long) => Long.Long;
				shru: (numBits: number | Long.Long) => Long.Long;
				subtract: (subtrahend: string | number | Long.Long) => Long.Long;
				sub: (subtrahend: string | number | Long.Long) => Long.Long;
				toInt: () => number;
				toNumber: () => number;
				toBytes: (le?: boolean) => number[];
				toBytesLE: () => number[];
				toBytesBE: () => number[];
				toSigned: () => Long.Long;
				toString: (radix?: number) => string;
				toUnsigned: () => Long.Long;
				xor: (other: string | number | Long.Long) => Long.Long;
			} & Record<Exclude<keyof I["pagination"]["offset"], keyof Long.Long>, never>);
			limit?: string | number | (Long.Long & {
				high: number;
				low: number;
				unsigned: boolean;
				add: (addend: string | number | Long.Long) => Long.Long;
				and: (other: string | number | Long.Long) => Long.Long;
				compare: (other: string | number | Long.Long) => number;
				comp: (other: string | number | Long.Long) => number;
				divide: (divisor: string | number | Long.Long) => Long.Long;
				div: (divisor: string | number | Long.Long) => Long.Long;
				equals: (other: string | number | Long.Long) => boolean;
				eq: (other: string | number | Long.Long) => boolean;
				getHighBits: () => number;
				getHighBitsUnsigned: () => number;
				getLowBits: () => number;
				getLowBitsUnsigned: () => number;
				getNumBitsAbs: () => number;
				greaterThan: (other: string | number | Long.Long) => boolean;
				gt: (other: string | number | Long.Long) => boolean;
				greaterThanOrEqual: (other: string | number | Long.Long) => boolean;
				gte: (other: string | number | Long.Long) => boolean;
				isEven: () => boolean;
				isNegative: () => boolean;
				isOdd: () => boolean;
				isPositive: () => boolean;
				isZero: () => boolean;
				lessThan: (other: string | number | Long.Long) => boolean;
				lt: (other: string | number | Long.Long) => boolean;
				lessThanOrEqual: (other: string | number | Long.Long) => boolean;
				lte: (other: string | number | Long.Long) => boolean;
				modulo: (other: string | number | Long.Long) => Long.Long;
				mod: (other: string | number | Long.Long) => Long.Long;
				multiply: (multiplier: string | number | Long.Long) => Long.Long;
				mul: (multiplier: string | number | Long.Long) => Long.Long;
				negate: () => Long.Long;
				neg: () => Long.Long;
				not: () => Long.Long;
				notEquals: (other: string | number | Long.Long) => boolean;
				neq: (other: string | number | Long.Long) => boolean;
				or: (other: string | number | Long.Long) => Long.Long;
				shiftLeft: (numBits: number | Long.Long) => Long.Long;
				shl: (numBits: number | Long.Long) => Long.Long;
				shiftRight: (numBits: number | Long.Long) => Long.Long;
				shr: (numBits: number | Long.Long) => Long.Long;
				shiftRightUnsigned: (numBits: number | Long.Long) => Long.Long;
				shru: (numBits: number | Long.Long) => Long.Long;
				subtract: (subtrahend: string | number | Long.Long) => Long.Long;
				sub: (subtrahend: string | number | Long.Long) => Long.Long;
				toInt: () => number;
				toNumber: () => number;
				toBytes: (le?: boolean) => number[];
				toBytesLE: () => number[];
				toBytesBE: () => number[];
				toSigned: () => Long.Long;
				toString: (radix?: number) => string;
				toUnsigned: () => Long.Long;
				xor: (other: string | number | Long.Long) => Long.Long;
			} & Record<Exclude<keyof I["pagination"]["limit"], keyof Long.Long>, never>);
			countTotal?: boolean;
			reverse?: boolean;
		} & Record<Exclude<keyof I["pagination"], keyof PageRequest>, never>;
	} & Record<Exclude<keyof I, keyof QueryValidatorsRequest>, never>>(object: I): QueryValidatorsRequest;
};
declare const QueryValidatorsResponse: {
	encode(message: QueryValidatorsResponse, writer?: _m0.Writer): _m0.Writer;
	decode(input: _m0.Reader | Uint8Array, length?: number): QueryValidatorsResponse;
	fromJSON(object: any): QueryValidatorsResponse;
	toJSON(message: QueryValidatorsResponse): unknown;
	fromPartial<I extends {
		validators?: {
			operatorAddress?: string;
			consensusPubkey?: {
				typeUrl?: string;
				value?: Uint8Array;
			};
			jailed?: boolean;
			status?: BondStatus;
			tokens?: string;
			delegatorShares?: string;
			description?: {
				moniker?: string;
				identity?: string;
				website?: string;
				securityContact?: string;
				details?: string;
			};
			unbondingHeight?: string | number | Long.Long;
			unbondingTime?: Date;
			commission?: {
				commissionRates?: {
					rate?: string;
					maxRate?: string;
					maxChangeRate?: string;
				};
				updateTime?: Date;
			};
			minSelfDelegation?: string;
		}[];
		pagination?: {
			nextKey?: Uint8Array;
			total?: string | number | Long.Long;
		};
	} & {
		validators?: {
			operatorAddress?: string;
			consensusPubkey?: {
				typeUrl?: string;
				value?: Uint8Array;
			};
			jailed?: boolean;
			status?: BondStatus;
			tokens?: string;
			delegatorShares?: string;
			description?: {
				moniker?: string;
				identity?: string;
				website?: string;
				securityContact?: string;
				details?: string;
			};
			unbondingHeight?: string | number | Long.Long;
			unbondingTime?: Date;
			commission?: {
				commissionRates?: {
					rate?: string;
					maxRate?: string;
					maxChangeRate?: string;
				};
				updateTime?: Date;
			};
			minSelfDelegation?: string;
		}[] & ({
			operatorAddress?: string;
			consensusPubkey?: {
				typeUrl?: string;
				value?: Uint8Array;
			};
			jailed?: boolean;
			status?: BondStatus;
			tokens?: string;
			delegatorShares?: string;
			description?: {
				moniker?: string;
				identity?: string;
				website?: string;
				securityContact?: string;
				details?: string;
			};
			unbondingHeight?: string | number | Long.Long;
			unbondingTime?: Date;
			commission?: {
				commissionRates?: {
					rate?: string;
					maxRate?: string;
					maxChangeRate?: string;
				};
				updateTime?: Date;
			};
			minSelfDelegation?: string;
		} & {
			operatorAddress?: string;
			consensusPubkey?: {
				typeUrl?: string;
				value?: Uint8Array;
			} & {
				typeUrl?: string;
				value?: Uint8Array;
			} & Record<Exclude<keyof I["validators"][number]["consensusPubkey"], keyof Any>, never>;
			jailed?: boolean;
			status?: BondStatus;
			tokens?: string;
			delegatorShares?: string;
			description?: {
				moniker?: string;
				identity?: string;
				website?: string;
				securityContact?: string;
				details?: string;
			} & {
				moniker?: string;
				identity?: string;
				website?: string;
				securityContact?: string;
				details?: string;
			} & Record<Exclude<keyof I["validators"][number]["description"], keyof Description>, never>;
			unbondingHeight?: string | number | (Long.Long & {
				high: number;
				low: number;
				unsigned: boolean;
				add: (addend: string | number | Long.Long) => Long.Long;
				and: (other: string | number | Long.Long) => Long.Long;
				compare: (other: string | number | Long.Long) => number;
				comp: (other: string | number | Long.Long) => number;
				divide: (divisor: string | number | Long.Long) => Long.Long;
				div: (divisor: string | number | Long.Long) => Long.Long;
				equals: (other: string | number | Long.Long) => boolean;
				eq: (other: string | number | Long.Long) => boolean;
				getHighBits: () => number;
				getHighBitsUnsigned: () => number;
				getLowBits: () => number;
				getLowBitsUnsigned: () => number;
				getNumBitsAbs: () => number;
				greaterThan: (other: string | number | Long.Long) => boolean;
				gt: (other: string | number | Long.Long) => boolean;
				greaterThanOrEqual: (other: string | number | Long.Long) => boolean;
				gte: (other: string | number | Long.Long) => boolean;
				isEven: () => boolean;
				isNegative: () => boolean;
				isOdd: () => boolean;
				isPositive: () => boolean;
				isZero: () => boolean;
				lessThan: (other: string | number | Long.Long) => boolean;
				lt: (other: string | number | Long.Long) => boolean;
				lessThanOrEqual: (other: string | number | Long.Long) => boolean;
				lte: (other: string | number | Long.Long) => boolean;
				modulo: (other: string | number | Long.Long) => Long.Long;
				mod: (other: string | number | Long.Long) => Long.Long;
				multiply: (multiplier: string | number | Long.Long) => Long.Long;
				mul: (multiplier: string | number | Long.Long) => Long.Long;
				negate: () => Long.Long;
				neg: () => Long.Long;
				not: () => Long.Long;
				notEquals: (other: string | number | Long.Long) => boolean;
				neq: (other: string | number | Long.Long) => boolean;
				or: (other: string | number | Long.Long) => Long.Long;
				shiftLeft: (numBits: number | Long.Long) => Long.Long;
				shl: (numBits: number | Long.Long) => Long.Long;
				shiftRight: (numBits: number | Long.Long) => Long.Long;
				shr: (numBits: number | Long.Long) => Long.Long;
				shiftRightUnsigned: (numBits: number | Long.Long) => Long.Long;
				shru: (numBits: number | Long.Long) => Long.Long;
				subtract: (subtrahend: string | number | Long.Long) => Long.Long;
				sub: (subtrahend: string | number | Long.Long) => Long.Long;
				toInt: () => number;
				toNumber: () => number;
				toBytes: (le?: boolean) => number[];
				toBytesLE: () => number[];
				toBytesBE: () => number[];
				toSigned: () => Long.Long;
				toString: (radix?: number) => string;
				toUnsigned: () => Long.Long;
				xor: (other: string | number | Long.Long) => Long.Long;
			} & Record<Exclude<keyof I["validators"][number]["unbondingHeight"], keyof Long.Long>, never>);
			unbondingTime?: Date;
			commission?: {
				commissionRates?: {
					rate?: string;
					maxRate?: string;
					maxChangeRate?: string;
				};
				updateTime?: Date;
			} & {
				commissionRates?: {
					rate?: string;
					maxRate?: string;
					maxChangeRate?: string;
				} & {
					rate?: string;
					maxRate?: string;
					maxChangeRate?: string;
				} & Record<Exclude<keyof I["validators"][number]["commission"]["commissionRates"], keyof CommissionRates>, never>;
				updateTime?: Date;
			} & Record<Exclude<keyof I["validators"][number]["commission"], keyof Commission>, never>;
			minSelfDelegation?: string;
		} & Record<Exclude<keyof I["validators"][number], keyof Validator>, never>)[] & Record<Exclude<keyof I["validators"], keyof {
			operatorAddress?: string;
			consensusPubkey?: {
				typeUrl?: string;
				value?: Uint8Array;
			};
			jailed?: boolean;
			status?: BondStatus;
			tokens?: string;
			delegatorShares?: string;
			description?: {
				moniker?: string;
				identity?: string;
				website?: string;
				securityContact?: string;
				details?: string;
			};
			unbondingHeight?: string | number | Long.Long;
			unbondingTime?: Date;
			commission?: {
				commissionRates?: {
					rate?: string;
					maxRate?: string;
					maxChangeRate?: string;
				};
				updateTime?: Date;
			};
			minSelfDelegation?: string;
		}[]>, never>;
		pagination?: {
			nextKey?: Uint8Array;
			total?: string | number | Long.Long;
		} & {
			nextKey?: Uint8Array;
			total?: string | number | (Long.Long & {
				high: number;
				low: number;
				unsigned: boolean;
				add: (addend: string | number | Long.Long) => Long.Long;
				and: (other: string | number | Long.Long) => Long.Long;
				compare: (other: string | number | Long.Long) => number;
				comp: (other: string | number | Long.Long) => number;
				divide: (divisor: string | number | Long.Long) => Long.Long;
				div: (divisor: string | number | Long.Long) => Long.Long;
				equals: (other: string | number | Long.Long) => boolean;
				eq: (other: string | number | Long.Long) => boolean;
				getHighBits: () => number;
				getHighBitsUnsigned: () => number;
				getLowBits: () => number;
				getLowBitsUnsigned: () => number;
				getNumBitsAbs: () => number;
				greaterThan: (other: string | number | Long.Long) => boolean;
				gt: (other: string | number | Long.Long) => boolean;
				greaterThanOrEqual: (other: string | number | Long.Long) => boolean;
				gte: (other: string | number | Long.Long) => boolean;
				isEven: () => boolean;
				isNegative: () => boolean;
				isOdd: () => boolean;
				isPositive: () => boolean;
				isZero: () => boolean;
				lessThan: (other: string | number | Long.Long) => boolean;
				lt: (other: string | number | Long.Long) => boolean;
				lessThanOrEqual: (other: string | number | Long.Long) => boolean;
				lte: (other: string | number | Long.Long) => boolean;
				modulo: (other: string | number | Long.Long) => Long.Long;
				mod: (other: string | number | Long.Long) => Long.Long;
				multiply: (multiplier: string | number | Long.Long) => Long.Long;
				mul: (multiplier: string | number | Long.Long) => Long.Long;
				negate: () => Long.Long;
				neg: () => Long.Long;
				not: () => Long.Long;
				notEquals: (other: string | number | Long.Long) => boolean;
				neq: (other: string | number | Long.Long) => boolean;
				or: (other: string | number | Long.Long) => Long.Long;
				shiftLeft: (numBits: number | Long.Long) => Long.Long;
				shl: (numBits: number | Long.Long) => Long.Long;
				shiftRight: (numBits: number | Long.Long) => Long.Long;
				shr: (numBits: number | Long.Long) => Long.Long;
				shiftRightUnsigned: (numBits: number | Long.Long) => Long.Long;
				shru: (numBits: number | Long.Long) => Long.Long;
				subtract: (subtrahend: string | number | Long.Long) => Long.Long;
				sub: (subtrahend: string | number | Long.Long) => Long.Long;
				toInt: () => number;
				toNumber: () => number;
				toBytes: (le?: boolean) => number[];
				toBytesLE: () => number[];
				toBytesBE: () => number[];
				toSigned: () => Long.Long;
				toString: (radix?: number) => string;
				toUnsigned: () => Long.Long;
				xor: (other: string | number | Long.Long) => Long.Long;
			} & Record<Exclude<keyof I["pagination"]["total"], keyof Long.Long>, never>);
		} & Record<Exclude<keyof I["pagination"], keyof PageResponse>, never>;
	} & Record<Exclude<keyof I, keyof QueryValidatorsResponse>, never>>(object: I): QueryValidatorsResponse;
};
declare const QueryValidatorRequest: {
	encode(message: QueryValidatorRequest, writer?: _m0.Writer): _m0.Writer;
	decode(input: _m0.Reader | Uint8Array, length?: number): QueryValidatorRequest;
	fromJSON(object: any): QueryValidatorRequest;
	toJSON(message: QueryValidatorRequest): unknown;
	fromPartial<I extends {
		validatorAddr?: string;
	} & {
		validatorAddr?: string;
	} & Record<Exclude<keyof I, "validatorAddr">, never>>(object: I): QueryValidatorRequest;
};
declare const QueryValidatorResponse: {
	encode(message: QueryValidatorResponse, writer?: _m0.Writer): _m0.Writer;
	decode(input: _m0.Reader | Uint8Array, length?: number): QueryValidatorResponse;
	fromJSON(object: any): QueryValidatorResponse;
	toJSON(message: QueryValidatorResponse): unknown;
	fromPartial<I extends {
		validator?: {
			operatorAddress?: string;
			consensusPubkey?: {
				typeUrl?: string;
				value?: Uint8Array;
			};
			jailed?: boolean;
			status?: BondStatus;
			tokens?: string;
			delegatorShares?: string;
			description?: {
				moniker?: string;
				identity?: string;
				website?: string;
				securityContact?: string;
				details?: string;
			};
			unbondingHeight?: string | number | Long.Long;
			unbondingTime?: Date;
			commission?: {
				commissionRates?: {
					rate?: string;
					maxRate?: string;
					maxChangeRate?: string;
				};
				updateTime?: Date;
			};
			minSelfDelegation?: string;
		};
	} & {
		validator?: {
			operatorAddress?: string;
			consensusPubkey?: {
				typeUrl?: string;
				value?: Uint8Array;
			};
			jailed?: boolean;
			status?: BondStatus;
			tokens?: string;
			delegatorShares?: string;
			description?: {
				moniker?: string;
				identity?: string;
				website?: string;
				securityContact?: string;
				details?: string;
			};
			unbondingHeight?: string | number | Long.Long;
			unbondingTime?: Date;
			commission?: {
				commissionRates?: {
					rate?: string;
					maxRate?: string;
					maxChangeRate?: string;
				};
				updateTime?: Date;
			};
			minSelfDelegation?: string;
		} & {
			operatorAddress?: string;
			consensusPubkey?: {
				typeUrl?: string;
				value?: Uint8Array;
			} & {
				typeUrl?: string;
				value?: Uint8Array;
			} & Record<Exclude<keyof I["validator"]["consensusPubkey"], keyof Any>, never>;
			jailed?: boolean;
			status?: BondStatus;
			tokens?: string;
			delegatorShares?: string;
			description?: {
				moniker?: string;
				identity?: string;
				website?: string;
				securityContact?: string;
				details?: string;
			} & {
				moniker?: string;
				identity?: string;
				website?: string;
				securityContact?: string;
				details?: string;
			} & Record<Exclude<keyof I["validator"]["description"], keyof Description>, never>;
			unbondingHeight?: string | number | (Long.Long & {
				high: number;
				low: number;
				unsigned: boolean;
				add: (addend: string | number | Long.Long) => Long.Long;
				and: (other: string | number | Long.Long) => Long.Long;
				compare: (other: string | number | Long.Long) => number;
				comp: (other: string | number | Long.Long) => number;
				divide: (divisor: string | number | Long.Long) => Long.Long;
				div: (divisor: string | number | Long.Long) => Long.Long;
				equals: (other: string | number | Long.Long) => boolean;
				eq: (other: string | number | Long.Long) => boolean;
				getHighBits: () => number;
				getHighBitsUnsigned: () => number;
				getLowBits: () => number;
				getLowBitsUnsigned: () => number;
				getNumBitsAbs: () => number;
				greaterThan: (other: string | number | Long.Long) => boolean;
				gt: (other: string | number | Long.Long) => boolean;
				greaterThanOrEqual: (other: string | number | Long.Long) => boolean;
				gte: (other: string | number | Long.Long) => boolean;
				isEven: () => boolean;
				isNegative: () => boolean;
				isOdd: () => boolean;
				isPositive: () => boolean;
				isZero: () => boolean;
				lessThan: (other: string | number | Long.Long) => boolean;
				lt: (other: string | number | Long.Long) => boolean;
				lessThanOrEqual: (other: string | number | Long.Long) => boolean;
				lte: (other: string | number | Long.Long) => boolean;
				modulo: (other: string | number | Long.Long) => Long.Long;
				mod: (other: string | number | Long.Long) => Long.Long;
				multiply: (multiplier: string | number | Long.Long) => Long.Long;
				mul: (multiplier: string | number | Long.Long) => Long.Long;
				negate: () => Long.Long;
				neg: () => Long.Long;
				not: () => Long.Long;
				notEquals: (other: string | number | Long.Long) => boolean;
				neq: (other: string | number | Long.Long) => boolean;
				or: (other: string | number | Long.Long) => Long.Long;
				shiftLeft: (numBits: number | Long.Long) => Long.Long;
				shl: (numBits: number | Long.Long) => Long.Long;
				shiftRight: (numBits: number | Long.Long) => Long.Long;
				shr: (numBits: number | Long.Long) => Long.Long;
				shiftRightUnsigned: (numBits: number | Long.Long) => Long.Long;
				shru: (numBits: number | Long.Long) => Long.Long;
				subtract: (subtrahend: string | number | Long.Long) => Long.Long;
				sub: (subtrahend: string | number | Long.Long) => Long.Long;
				toInt: () => number;
				toNumber: () => number;
				toBytes: (le?: boolean) => number[];
				toBytesLE: () => number[];
				toBytesBE: () => number[];
				toSigned: () => Long.Long;
				toString: (radix?: number) => string;
				toUnsigned: () => Long.Long;
				xor: (other: string | number | Long.Long) => Long.Long;
			} & Record<Exclude<keyof I["validator"]["unbondingHeight"], keyof Long.Long>, never>);
			unbondingTime?: Date;
			commission?: {
				commissionRates?: {
					rate?: string;
					maxRate?: string;
					maxChangeRate?: string;
				};
				updateTime?: Date;
			} & {
				commissionRates?: {
					rate?: string;
					maxRate?: string;
					maxChangeRate?: string;
				} & {
					rate?: string;
					maxRate?: string;
					maxChangeRate?: string;
				} & Record<Exclude<keyof I["validator"]["commission"]["commissionRates"], keyof CommissionRates>, never>;
				updateTime?: Date;
			} & Record<Exclude<keyof I["validator"]["commission"], keyof Commission>, never>;
			minSelfDelegation?: string;
		} & Record<Exclude<keyof I["validator"], keyof Validator>, never>;
	} & Record<Exclude<keyof I, "validator">, never>>(object: I): QueryValidatorResponse;
};
declare const QueryValidatorDelegationsRequest: {
	encode(message: QueryValidatorDelegationsRequest, writer?: _m0.Writer): _m0.Writer;
	decode(input: _m0.Reader | Uint8Array, length?: number): QueryValidatorDelegationsRequest;
	fromJSON(object: any): QueryValidatorDelegationsRequest;
	toJSON(message: QueryValidatorDelegationsRequest): unknown;
	fromPartial<I extends {
		validatorAddr?: string;
		pagination?: {
			key?: Uint8Array;
			offset?: string | number | Long.Long;
			limit?: string | number | Long.Long;
			countTotal?: boolean;
			reverse?: boolean;
		};
	} & {
		validatorAddr?: string;
		pagination?: {
			key?: Uint8Array;
			offset?: string | number | Long.Long;
			limit?: string | number | Long.Long;
			countTotal?: boolean;
			reverse?: boolean;
		} & {
			key?: Uint8Array;
			offset?: string | number | (Long.Long & {
				high: number;
				low: number;
				unsigned: boolean;
				add: (addend: string | number | Long.Long) => Long.Long;
				and: (other: string | number | Long.Long) => Long.Long;
				compare: (other: string | number | Long.Long) => number;
				comp: (other: string | number | Long.Long) => number;
				divide: (divisor: string | number | Long.Long) => Long.Long;
				div: (divisor: string | number | Long.Long) => Long.Long;
				equals: (other: string | number | Long.Long) => boolean;
				eq: (other: string | number | Long.Long) => boolean;
				getHighBits: () => number;
				getHighBitsUnsigned: () => number;
				getLowBits: () => number;
				getLowBitsUnsigned: () => number;
				getNumBitsAbs: () => number;
				greaterThan: (other: string | number | Long.Long) => boolean;
				gt: (other: string | number | Long.Long) => boolean;
				greaterThanOrEqual: (other: string | number | Long.Long) => boolean;
				gte: (other: string | number | Long.Long) => boolean;
				isEven: () => boolean;
				isNegative: () => boolean;
				isOdd: () => boolean;
				isPositive: () => boolean;
				isZero: () => boolean;
				lessThan: (other: string | number | Long.Long) => boolean;
				lt: (other: string | number | Long.Long) => boolean;
				lessThanOrEqual: (other: string | number | Long.Long) => boolean;
				lte: (other: string | number | Long.Long) => boolean;
				modulo: (other: string | number | Long.Long) => Long.Long;
				mod: (other: string | number | Long.Long) => Long.Long;
				multiply: (multiplier: string | number | Long.Long) => Long.Long;
				mul: (multiplier: string | number | Long.Long) => Long.Long;
				negate: () => Long.Long;
				neg: () => Long.Long;
				not: () => Long.Long;
				notEquals: (other: string | number | Long.Long) => boolean;
				neq: (other: string | number | Long.Long) => boolean;
				or: (other: string | number | Long.Long) => Long.Long;
				shiftLeft: (numBits: number | Long.Long) => Long.Long;
				shl: (numBits: number | Long.Long) => Long.Long;
				shiftRight: (numBits: number | Long.Long) => Long.Long;
				shr: (numBits: number | Long.Long) => Long.Long;
				shiftRightUnsigned: (numBits: number | Long.Long) => Long.Long;
				shru: (numBits: number | Long.Long) => Long.Long;
				subtract: (subtrahend: string | number | Long.Long) => Long.Long;
				sub: (subtrahend: string | number | Long.Long) => Long.Long;
				toInt: () => number;
				toNumber: () => number;
				toBytes: (le?: boolean) => number[];
				toBytesLE: () => number[];
				toBytesBE: () => number[];
				toSigned: () => Long.Long;
				toString: (radix?: number) => string;
				toUnsigned: () => Long.Long;
				xor: (other: string | number | Long.Long) => Long.Long;
			} & Record<Exclude<keyof I["pagination"]["offset"], keyof Long.Long>, never>);
			limit?: string | number | (Long.Long & {
				high: number;
				low: number;
				unsigned: boolean;
				add: (addend: string | number | Long.Long) => Long.Long;
				and: (other: string | number | Long.Long) => Long.Long;
				compare: (other: string | number | Long.Long) => number;
				comp: (other: string | number | Long.Long) => number;
				divide: (divisor: string | number | Long.Long) => Long.Long;
				div: (divisor: string | number | Long.Long) => Long.Long;
				equals: (other: string | number | Long.Long) => boolean;
				eq: (other: string | number | Long.Long) => boolean;
				getHighBits: () => number;
				getHighBitsUnsigned: () => number;
				getLowBits: () => number;
				getLowBitsUnsigned: () => number;
				getNumBitsAbs: () => number;
				greaterThan: (other: string | number | Long.Long) => boolean;
				gt: (other: string | number | Long.Long) => boolean;
				greaterThanOrEqual: (other: string | number | Long.Long) => boolean;
				gte: (other: string | number | Long.Long) => boolean;
				isEven: () => boolean;
				isNegative: () => boolean;
				isOdd: () => boolean;
				isPositive: () => boolean;
				isZero: () => boolean;
				lessThan: (other: string | number | Long.Long) => boolean;
				lt: (other: string | number | Long.Long) => boolean;
				lessThanOrEqual: (other: string | number | Long.Long) => boolean;
				lte: (other: string | number | Long.Long) => boolean;
				modulo: (other: string | number | Long.Long) => Long.Long;
				mod: (other: string | number | Long.Long) => Long.Long;
				multiply: (multiplier: string | number | Long.Long) => Long.Long;
				mul: (multiplier: string | number | Long.Long) => Long.Long;
				negate: () => Long.Long;
				neg: () => Long.Long;
				not: () => Long.Long;
				notEquals: (other: string | number | Long.Long) => boolean;
				neq: (other: string | number | Long.Long) => boolean;
				or: (other: string | number | Long.Long) => Long.Long;
				shiftLeft: (numBits: number | Long.Long) => Long.Long;
				shl: (numBits: number | Long.Long) => Long.Long;
				shiftRight: (numBits: number | Long.Long) => Long.Long;
				shr: (numBits: number | Long.Long) => Long.Long;
				shiftRightUnsigned: (numBits: number | Long.Long) => Long.Long;
				shru: (numBits: number | Long.Long) => Long.Long;
				subtract: (subtrahend: string | number | Long.Long) => Long.Long;
				sub: (subtrahend: string | number | Long.Long) => Long.Long;
				toInt: () => number;
				toNumber: () => number;
				toBytes: (le?: boolean) => number[];
				toBytesLE: () => number[];
				toBytesBE: () => number[];
				toSigned: () => Long.Long;
				toString: (radix?: number) => string;
				toUnsigned: () => Long.Long;
				xor: (other: string | number | Long.Long) => Long.Long;
			} & Record<Exclude<keyof I["pagination"]["limit"], keyof Long.Long>, never>);
			countTotal?: boolean;
			reverse?: boolean;
		} & Record<Exclude<keyof I["pagination"], keyof PageRequest>, never>;
	} & Record<Exclude<keyof I, keyof QueryValidatorDelegationsRequest>, never>>(object: I): QueryValidatorDelegationsRequest;
};
declare const QueryValidatorDelegationsResponse: {
	encode(message: QueryValidatorDelegationsResponse, writer?: _m0.Writer): _m0.Writer;
	decode(input: _m0.Reader | Uint8Array, length?: number): QueryValidatorDelegationsResponse;
	fromJSON(object: any): QueryValidatorDelegationsResponse;
	toJSON(message: QueryValidatorDelegationsResponse): unknown;
	fromPartial<I extends {
		delegationResponses?: {
			delegation?: {
				delegatorAddress?: string;
				validatorAddress?: string;
				shares?: string;
			};
			balance?: {
				denom?: string;
				amount?: string;
			};
		}[];
		pagination?: {
			nextKey?: Uint8Array;
			total?: string | number | Long.Long;
		};
	} & {
		delegationResponses?: {
			delegation?: {
				delegatorAddress?: string;
				validatorAddress?: string;
				shares?: string;
			};
			balance?: {
				denom?: string;
				amount?: string;
			};
		}[] & ({
			delegation?: {
				delegatorAddress?: string;
				validatorAddress?: string;
				shares?: string;
			};
			balance?: {
				denom?: string;
				amount?: string;
			};
		} & {
			delegation?: {
				delegatorAddress?: string;
				validatorAddress?: string;
				shares?: string;
			} & {
				delegatorAddress?: string;
				validatorAddress?: string;
				shares?: string;
			} & Record<Exclude<keyof I["delegationResponses"][number]["delegation"], keyof Delegation>, never>;
			balance?: {
				denom?: string;
				amount?: string;
			} & {
				denom?: string;
				amount?: string;
			} & Record<Exclude<keyof I["delegationResponses"][number]["balance"], keyof Coin>, never>;
		} & Record<Exclude<keyof I["delegationResponses"][number], keyof DelegationResponse>, never>)[] & Record<Exclude<keyof I["delegationResponses"], keyof {
			delegation?: {
				delegatorAddress?: string;
				validatorAddress?: string;
				shares?: string;
			};
			balance?: {
				denom?: string;
				amount?: string;
			};
		}[]>, never>;
		pagination?: {
			nextKey?: Uint8Array;
			total?: string | number | Long.Long;
		} & {
			nextKey?: Uint8Array;
			total?: string | number | (Long.Long & {
				high: number;
				low: number;
				unsigned: boolean;
				add: (addend: string | number | Long.Long) => Long.Long;
				and: (other: string | number | Long.Long) => Long.Long;
				compare: (other: string | number | Long.Long) => number;
				comp: (other: string | number | Long.Long) => number;
				divide: (divisor: string | number | Long.Long) => Long.Long;
				div: (divisor: string | number | Long.Long) => Long.Long;
				equals: (other: string | number | Long.Long) => boolean;
				eq: (other: string | number | Long.Long) => boolean;
				getHighBits: () => number;
				getHighBitsUnsigned: () => number;
				getLowBits: () => number;
				getLowBitsUnsigned: () => number;
				getNumBitsAbs: () => number;
				greaterThan: (other: string | number | Long.Long) => boolean;
				gt: (other: string | number | Long.Long) => boolean;
				greaterThanOrEqual: (other: string | number | Long.Long) => boolean;
				gte: (other: string | number | Long.Long) => boolean;
				isEven: () => boolean;
				isNegative: () => boolean;
				isOdd: () => boolean;
				isPositive: () => boolean;
				isZero: () => boolean;
				lessThan: (other: string | number | Long.Long) => boolean;
				lt: (other: string | number | Long.Long) => boolean;
				lessThanOrEqual: (other: string | number | Long.Long) => boolean;
				lte: (other: string | number | Long.Long) => boolean;
				modulo: (other: string | number | Long.Long) => Long.Long;
				mod: (other: string | number | Long.Long) => Long.Long;
				multiply: (multiplier: string | number | Long.Long) => Long.Long;
				mul: (multiplier: string | number | Long.Long) => Long.Long;
				negate: () => Long.Long;
				neg: () => Long.Long;
				not: () => Long.Long;
				notEquals: (other: string | number | Long.Long) => boolean;
				neq: (other: string | number | Long.Long) => boolean;
				or: (other: string | number | Long.Long) => Long.Long;
				shiftLeft: (numBits: number | Long.Long) => Long.Long;
				shl: (numBits: number | Long.Long) => Long.Long;
				shiftRight: (numBits: number | Long.Long) => Long.Long;
				shr: (numBits: number | Long.Long) => Long.Long;
				shiftRightUnsigned: (numBits: number | Long.Long) => Long.Long;
				shru: (numBits: number | Long.Long) => Long.Long;
				subtract: (subtrahend: string | number | Long.Long) => Long.Long;
				sub: (subtrahend: string | number | Long.Long) => Long.Long;
				toInt: () => number;
				toNumber: () => number;
				toBytes: (le?: boolean) => number[];
				toBytesLE: () => number[];
				toBytesBE: () => number[];
				toSigned: () => Long.Long;
				toString: (radix?: number) => string;
				toUnsigned: () => Long.Long;
				xor: (other: string | number | Long.Long) => Long.Long;
			} & Record<Exclude<keyof I["pagination"]["total"], keyof Long.Long>, never>);
		} & Record<Exclude<keyof I["pagination"], keyof PageResponse>, never>;
	} & Record<Exclude<keyof I, keyof QueryValidatorDelegationsResponse>, never>>(object: I): QueryValidatorDelegationsResponse;
};
declare const QueryValidatorUnbondingDelegationsRequest: {
	encode(message: QueryValidatorUnbondingDelegationsRequest, writer?: _m0.Writer): _m0.Writer;
	decode(input: _m0.Reader | Uint8Array, length?: number): QueryValidatorUnbondingDelegationsRequest;
	fromJSON(object: any): QueryValidatorUnbondingDelegationsRequest;
	toJSON(message: QueryValidatorUnbondingDelegationsRequest): unknown;
	fromPartial<I extends {
		validatorAddr?: string;
		pagination?: {
			key?: Uint8Array;
			offset?: string | number | Long.Long;
			limit?: string | number | Long.Long;
			countTotal?: boolean;
			reverse?: boolean;
		};
	} & {
		validatorAddr?: string;
		pagination?: {
			key?: Uint8Array;
			offset?: string | number | Long.Long;
			limit?: string | number | Long.Long;
			countTotal?: boolean;
			reverse?: boolean;
		} & {
			key?: Uint8Array;
			offset?: string | number | (Long.Long & {
				high: number;
				low: number;
				unsigned: boolean;
				add: (addend: string | number | Long.Long) => Long.Long;
				and: (other: string | number | Long.Long) => Long.Long;
				compare: (other: string | number | Long.Long) => number;
				comp: (other: string | number | Long.Long) => number;
				divide: (divisor: string | number | Long.Long) => Long.Long;
				div: (divisor: string | number | Long.Long) => Long.Long;
				equals: (other: string | number | Long.Long) => boolean;
				eq: (other: string | number | Long.Long) => boolean;
				getHighBits: () => number;
				getHighBitsUnsigned: () => number;
				getLowBits: () => number;
				getLowBitsUnsigned: () => number;
				getNumBitsAbs: () => number;
				greaterThan: (other: string | number | Long.Long) => boolean;
				gt: (other: string | number | Long.Long) => boolean;
				greaterThanOrEqual: (other: string | number | Long.Long) => boolean;
				gte: (other: string | number | Long.Long) => boolean;
				isEven: () => boolean;
				isNegative: () => boolean;
				isOdd: () => boolean;
				isPositive: () => boolean;
				isZero: () => boolean;
				lessThan: (other: string | number | Long.Long) => boolean;
				lt: (other: string | number | Long.Long) => boolean;
				lessThanOrEqual: (other: string | number | Long.Long) => boolean;
				lte: (other: string | number | Long.Long) => boolean;
				modulo: (other: string | number | Long.Long) => Long.Long;
				mod: (other: string | number | Long.Long) => Long.Long;
				multiply: (multiplier: string | number | Long.Long) => Long.Long;
				mul: (multiplier: string | number | Long.Long) => Long.Long;
				negate: () => Long.Long;
				neg: () => Long.Long;
				not: () => Long.Long;
				notEquals: (other: string | number | Long.Long) => boolean;
				neq: (other: string | number | Long.Long) => boolean;
				or: (other: string | number | Long.Long) => Long.Long;
				shiftLeft: (numBits: number | Long.Long) => Long.Long;
				shl: (numBits: number | Long.Long) => Long.Long;
				shiftRight: (numBits: number | Long.Long) => Long.Long;
				shr: (numBits: number | Long.Long) => Long.Long;
				shiftRightUnsigned: (numBits: number | Long.Long) => Long.Long;
				shru: (numBits: number | Long.Long) => Long.Long;
				subtract: (subtrahend: string | number | Long.Long) => Long.Long;
				sub: (subtrahend: string | number | Long.Long) => Long.Long;
				toInt: () => number;
				toNumber: () => number;
				toBytes: (le?: boolean) => number[];
				toBytesLE: () => number[];
				toBytesBE: () => number[];
				toSigned: () => Long.Long;
				toString: (radix?: number) => string;
				toUnsigned: () => Long.Long;
				xor: (other: string | number | Long.Long) => Long.Long;
			} & Record<Exclude<keyof I["pagination"]["offset"], keyof Long.Long>, never>);
			limit?: string | number | (Long.Long & {
				high: number;
				low: number;
				unsigned: boolean;
				add: (addend: string | number | Long.Long) => Long.Long;
				and: (other: string | number | Long.Long) => Long.Long;
				compare: (other: string | number | Long.Long) => number;
				comp: (other: string | number | Long.Long) => number;
				divide: (divisor: string | number | Long.Long) => Long.Long;
				div: (divisor: string | number | Long.Long) => Long.Long;
				equals: (other: string | number | Long.Long) => boolean;
				eq: (other: string | number | Long.Long) => boolean;
				getHighBits: () => number;
				getHighBitsUnsigned: () => number;
				getLowBits: () => number;
				getLowBitsUnsigned: () => number;
				getNumBitsAbs: () => number;
				greaterThan: (other: string | number | Long.Long) => boolean;
				gt: (other: string | number | Long.Long) => boolean;
				greaterThanOrEqual: (other: string | number | Long.Long) => boolean;
				gte: (other: string | number | Long.Long) => boolean;
				isEven: () => boolean;
				isNegative: () => boolean;
				isOdd: () => boolean;
				isPositive: () => boolean;
				isZero: () => boolean;
				lessThan: (other: string | number | Long.Long) => boolean;
				lt: (other: string | number | Long.Long) => boolean;
				lessThanOrEqual: (other: string | number | Long.Long) => boolean;
				lte: (other: string | number | Long.Long) => boolean;
				modulo: (other: string | number | Long.Long) => Long.Long;
				mod: (other: string | number | Long.Long) => Long.Long;
				multiply: (multiplier: string | number | Long.Long) => Long.Long;
				mul: (multiplier: string | number | Long.Long) => Long.Long;
				negate: () => Long.Long;
				neg: () => Long.Long;
				not: () => Long.Long;
				notEquals: (other: string | number | Long.Long) => boolean;
				neq: (other: string | number | Long.Long) => boolean;
				or: (other: string | number | Long.Long) => Long.Long;
				shiftLeft: (numBits: number | Long.Long) => Long.Long;
				shl: (numBits: number | Long.Long) => Long.Long;
				shiftRight: (numBits: number | Long.Long) => Long.Long;
				shr: (numBits: number | Long.Long) => Long.Long;
				shiftRightUnsigned: (numBits: number | Long.Long) => Long.Long;
				shru: (numBits: number | Long.Long) => Long.Long;
				subtract: (subtrahend: string | number | Long.Long) => Long.Long;
				sub: (subtrahend: string | number | Long.Long) => Long.Long;
				toInt: () => number;
				toNumber: () => number;
				toBytes: (le?: boolean) => number[];
				toBytesLE: () => number[];
				toBytesBE: () => number[];
				toSigned: () => Long.Long;
				toString: (radix?: number) => string;
				toUnsigned: () => Long.Long;
				xor: (other: string | number | Long.Long) => Long.Long;
			} & Record<Exclude<keyof I["pagination"]["limit"], keyof Long.Long>, never>);
			countTotal?: boolean;
			reverse?: boolean;
		} & Record<Exclude<keyof I["pagination"], keyof PageRequest>, never>;
	} & Record<Exclude<keyof I, keyof QueryValidatorUnbondingDelegationsRequest>, never>>(object: I): QueryValidatorUnbondingDelegationsRequest;
};
declare const QueryValidatorUnbondingDelegationsResponse: {
	encode(message: QueryValidatorUnbondingDelegationsResponse, writer?: _m0.Writer): _m0.Writer;
	decode(input: _m0.Reader | Uint8Array, length?: number): QueryValidatorUnbondingDelegationsResponse;
	fromJSON(object: any): QueryValidatorUnbondingDelegationsResponse;
	toJSON(message: QueryValidatorUnbondingDelegationsResponse): unknown;
	fromPartial<I extends {
		unbondingResponses?: {
			delegatorAddress?: string;
			validatorAddress?: string;
			entries?: {
				creationHeight?: string | number | Long.Long;
				completionTime?: Date;
				initialBalance?: string;
				balance?: string;
			}[];
		}[];
		pagination?: {
			nextKey?: Uint8Array;
			total?: string | number | Long.Long;
		};
	} & {
		unbondingResponses?: {
			delegatorAddress?: string;
			validatorAddress?: string;
			entries?: {
				creationHeight?: string | number | Long.Long;
				completionTime?: Date;
				initialBalance?: string;
				balance?: string;
			}[];
		}[] & ({
			delegatorAddress?: string;
			validatorAddress?: string;
			entries?: {
				creationHeight?: string | number | Long.Long;
				completionTime?: Date;
				initialBalance?: string;
				balance?: string;
			}[];
		} & {
			delegatorAddress?: string;
			validatorAddress?: string;
			entries?: {
				creationHeight?: string | number | Long.Long;
				completionTime?: Date;
				initialBalance?: string;
				balance?: string;
			}[] & ({
				creationHeight?: string | number | Long.Long;
				completionTime?: Date;
				initialBalance?: string;
				balance?: string;
			} & {
				creationHeight?: string | number | (Long.Long & {
					high: number;
					low: number;
					unsigned: boolean;
					add: (addend: string | number | Long.Long) => Long.Long;
					and: (other: string | number | Long.Long) => Long.Long;
					compare: (other: string | number | Long.Long) => number;
					comp: (other: string | number | Long.Long) => number;
					divide: (divisor: string | number | Long.Long) => Long.Long;
					div: (divisor: string | number | Long.Long) => Long.Long;
					equals: (other: string | number | Long.Long) => boolean;
					eq: (other: string | number | Long.Long) => boolean;
					getHighBits: () => number;
					getHighBitsUnsigned: () => number;
					getLowBits: () => number;
					getLowBitsUnsigned: () => number;
					getNumBitsAbs: () => number;
					greaterThan: (other: string | number | Long.Long) => boolean;
					gt: (other: string | number | Long.Long) => boolean;
					greaterThanOrEqual: (other: string | number | Long.Long) => boolean;
					gte: (other: string | number | Long.Long) => boolean;
					isEven: () => boolean;
					isNegative: () => boolean;
					isOdd: () => boolean;
					isPositive: () => boolean;
					isZero: () => boolean;
					lessThan: (other: string | number | Long.Long) => boolean;
					lt: (other: string | number | Long.Long) => boolean;
					lessThanOrEqual: (other: string | number | Long.Long) => boolean;
					lte: (other: string | number | Long.Long) => boolean;
					modulo: (other: string | number | Long.Long) => Long.Long;
					mod: (other: string | number | Long.Long) => Long.Long;
					multiply: (multiplier: string | number | Long.Long) => Long.Long;
					mul: (multiplier: string | number | Long.Long) => Long.Long;
					negate: () => Long.Long;
					neg: () => Long.Long;
					not: () => Long.Long;
					notEquals: (other: string | number | Long.Long) => boolean;
					neq: (other: string | number | Long.Long) => boolean;
					or: (other: string | number | Long.Long) => Long.Long;
					shiftLeft: (numBits: number | Long.Long) => Long.Long;
					shl: (numBits: number | Long.Long) => Long.Long;
					shiftRight: (numBits: number | Long.Long) => Long.Long;
					shr: (numBits: number | Long.Long) => Long.Long;
					shiftRightUnsigned: (numBits: number | Long.Long) => Long.Long;
					shru: (numBits: number | Long.Long) => Long.Long;
					subtract: (subtrahend: string | number | Long.Long) => Long.Long;
					sub: (subtrahend: string | number | Long.Long) => Long.Long;
					toInt: () => number;
					toNumber: () => number;
					toBytes: (le?: boolean) => number[];
					toBytesLE: () => number[];
					toBytesBE: () => number[];
					toSigned: () => Long.Long;
					toString: (radix?: number) => string;
					toUnsigned: () => Long.Long;
					xor: (other: string | number | Long.Long) => Long.Long;
				} & Record<Exclude<keyof I["unbondingResponses"][number]["entries"][number]["creationHeight"], keyof Long.Long>, never>);
				completionTime?: Date;
				initialBalance?: string;
				balance?: string;
			} & Record<Exclude<keyof I["unbondingResponses"][number]["entries"][number], keyof UnbondingDelegationEntry>, never>)[] & Record<Exclude<keyof I["unbondingResponses"][number]["entries"], keyof {
				creationHeight?: string | number | Long.Long;
				completionTime?: Date;
				initialBalance?: string;
				balance?: string;
			}[]>, never>;
		} & Record<Exclude<keyof I["unbondingResponses"][number], keyof UnbondingDelegation>, never>)[] & Record<Exclude<keyof I["unbondingResponses"], keyof {
			delegatorAddress?: string;
			validatorAddress?: string;
			entries?: {
				creationHeight?: string | number | Long.Long;
				completionTime?: Date;
				initialBalance?: string;
				balance?: string;
			}[];
		}[]>, never>;
		pagination?: {
			nextKey?: Uint8Array;
			total?: string | number | Long.Long;
		} & {
			nextKey?: Uint8Array;
			total?: string | number | (Long.Long & {
				high: number;
				low: number;
				unsigned: boolean;
				add: (addend: string | number | Long.Long) => Long.Long;
				and: (other: string | number | Long.Long) => Long.Long;
				compare: (other: string | number | Long.Long) => number;
				comp: (other: string | number | Long.Long) => number;
				divide: (divisor: string | number | Long.Long) => Long.Long;
				div: (divisor: string | number | Long.Long) => Long.Long;
				equals: (other: string | number | Long.Long) => boolean;
				eq: (other: string | number | Long.Long) => boolean;
				getHighBits: () => number;
				getHighBitsUnsigned: () => number;
				getLowBits: () => number;
				getLowBitsUnsigned: () => number;
				getNumBitsAbs: () => number;
				greaterThan: (other: string | number | Long.Long) => boolean;
				gt: (other: string | number | Long.Long) => boolean;
				greaterThanOrEqual: (other: string | number | Long.Long) => boolean;
				gte: (other: string | number | Long.Long) => boolean;
				isEven: () => boolean;
				isNegative: () => boolean;
				isOdd: () => boolean;
				isPositive: () => boolean;
				isZero: () => boolean;
				lessThan: (other: string | number | Long.Long) => boolean;
				lt: (other: string | number | Long.Long) => boolean;
				lessThanOrEqual: (other: string | number | Long.Long) => boolean;
				lte: (other: string | number | Long.Long) => boolean;
				modulo: (other: string | number | Long.Long) => Long.Long;
				mod: (other: string | number | Long.Long) => Long.Long;
				multiply: (multiplier: string | number | Long.Long) => Long.Long;
				mul: (multiplier: string | number | Long.Long) => Long.Long;
				negate: () => Long.Long;
				neg: () => Long.Long;
				not: () => Long.Long;
				notEquals: (other: string | number | Long.Long) => boolean;
				neq: (other: string | number | Long.Long) => boolean;
				or: (other: string | number | Long.Long) => Long.Long;
				shiftLeft: (numBits: number | Long.Long) => Long.Long;
				shl: (numBits: number | Long.Long) => Long.Long;
				shiftRight: (numBits: number | Long.Long) => Long.Long;
				shr: (numBits: number | Long.Long) => Long.Long;
				shiftRightUnsigned: (numBits: number | Long.Long) => Long.Long;
				shru: (numBits: number | Long.Long) => Long.Long;
				subtract: (subtrahend: string | number | Long.Long) => Long.Long;
				sub: (subtrahend: string | number | Long.Long) => Long.Long;
				toInt: () => number;
				toNumber: () => number;
				toBytes: (le?: boolean) => number[];
				toBytesLE: () => number[];
				toBytesBE: () => number[];
				toSigned: () => Long.Long;
				toString: (radix?: number) => string;
				toUnsigned: () => Long.Long;
				xor: (other: string | number | Long.Long) => Long.Long;
			} & Record<Exclude<keyof I["pagination"]["total"], keyof Long.Long>, never>);
		} & Record<Exclude<keyof I["pagination"], keyof PageResponse>, never>;
	} & Record<Exclude<keyof I, keyof QueryValidatorUnbondingDelegationsResponse>, never>>(object: I): QueryValidatorUnbondingDelegationsResponse;
};
declare const QueryDelegationRequest: {
	encode(message: QueryDelegationRequest, writer?: _m0.Writer): _m0.Writer;
	decode(input: _m0.Reader | Uint8Array, length?: number): QueryDelegationRequest;
	fromJSON(object: any): QueryDelegationRequest;
	toJSON(message: QueryDelegationRequest): unknown;
	fromPartial<I extends {
		delegatorAddr?: string;
		validatorAddr?: string;
	} & {
		delegatorAddr?: string;
		validatorAddr?: string;
	} & Record<Exclude<keyof I, keyof QueryDelegationRequest>, never>>(object: I): QueryDelegationRequest;
};
declare const QueryDelegationResponse: {
	encode(message: QueryDelegationResponse, writer?: _m0.Writer): _m0.Writer;
	decode(input: _m0.Reader | Uint8Array, length?: number): QueryDelegationResponse;
	fromJSON(object: any): QueryDelegationResponse;
	toJSON(message: QueryDelegationResponse): unknown;
	fromPartial<I extends {
		delegationResponse?: {
			delegation?: {
				delegatorAddress?: string;
				validatorAddress?: string;
				shares?: string;
			};
			balance?: {
				denom?: string;
				amount?: string;
			};
		};
	} & {
		delegationResponse?: {
			delegation?: {
				delegatorAddress?: string;
				validatorAddress?: string;
				shares?: string;
			};
			balance?: {
				denom?: string;
				amount?: string;
			};
		} & {
			delegation?: {
				delegatorAddress?: string;
				validatorAddress?: string;
				shares?: string;
			} & {
				delegatorAddress?: string;
				validatorAddress?: string;
				shares?: string;
			} & Record<Exclude<keyof I["delegationResponse"]["delegation"], keyof Delegation>, never>;
			balance?: {
				denom?: string;
				amount?: string;
			} & {
				denom?: string;
				amount?: string;
			} & Record<Exclude<keyof I["delegationResponse"]["balance"], keyof Coin>, never>;
		} & Record<Exclude<keyof I["delegationResponse"], keyof DelegationResponse>, never>;
	} & Record<Exclude<keyof I, "delegationResponse">, never>>(object: I): QueryDelegationResponse;
};
declare const QueryUnbondingDelegationRequest: {
	encode(message: QueryUnbondingDelegationRequest, writer?: _m0.Writer): _m0.Writer;
	decode(input: _m0.Reader | Uint8Array, length?: number): QueryUnbondingDelegationRequest;
	fromJSON(object: any): QueryUnbondingDelegationRequest;
	toJSON(message: QueryUnbondingDelegationRequest): unknown;
	fromPartial<I extends {
		delegatorAddr?: string;
		validatorAddr?: string;
	} & {
		delegatorAddr?: string;
		validatorAddr?: string;
	} & Record<Exclude<keyof I, keyof QueryUnbondingDelegationRequest>, never>>(object: I): QueryUnbondingDelegationRequest;
};
declare const QueryUnbondingDelegationResponse: {
	encode(message: QueryUnbondingDelegationResponse, writer?: _m0.Writer): _m0.Writer;
	decode(input: _m0.Reader | Uint8Array, length?: number): QueryUnbondingDelegationResponse;
	fromJSON(object: any): QueryUnbondingDelegationResponse;
	toJSON(message: QueryUnbondingDelegationResponse): unknown;
	fromPartial<I extends {
		unbond?: {
			delegatorAddress?: string;
			validatorAddress?: string;
			entries?: {
				creationHeight?: string | number | Long.Long;
				completionTime?: Date;
				initialBalance?: string;
				balance?: string;
			}[];
		};
	} & {
		unbond?: {
			delegatorAddress?: string;
			validatorAddress?: string;
			entries?: {
				creationHeight?: string | number | Long.Long;
				completionTime?: Date;
				initialBalance?: string;
				balance?: string;
			}[];
		} & {
			delegatorAddress?: string;
			validatorAddress?: string;
			entries?: {
				creationHeight?: string | number | Long.Long;
				completionTime?: Date;
				initialBalance?: string;
				balance?: string;
			}[] & ({
				creationHeight?: string | number | Long.Long;
				completionTime?: Date;
				initialBalance?: string;
				balance?: string;
			} & {
				creationHeight?: string | number | (Long.Long & {
					high: number;
					low: number;
					unsigned: boolean;
					add: (addend: string | number | Long.Long) => Long.Long;
					and: (other: string | number | Long.Long) => Long.Long;
					compare: (other: string | number | Long.Long) => number;
					comp: (other: string | number | Long.Long) => number;
					divide: (divisor: string | number | Long.Long) => Long.Long;
					div: (divisor: string | number | Long.Long) => Long.Long;
					equals: (other: string | number | Long.Long) => boolean;
					eq: (other: string | number | Long.Long) => boolean;
					getHighBits: () => number;
					getHighBitsUnsigned: () => number;
					getLowBits: () => number;
					getLowBitsUnsigned: () => number;
					getNumBitsAbs: () => number;
					greaterThan: (other: string | number | Long.Long) => boolean;
					gt: (other: string | number | Long.Long) => boolean;
					greaterThanOrEqual: (other: string | number | Long.Long) => boolean;
					gte: (other: string | number | Long.Long) => boolean;
					isEven: () => boolean;
					isNegative: () => boolean;
					isOdd: () => boolean;
					isPositive: () => boolean;
					isZero: () => boolean;
					lessThan: (other: string | number | Long.Long) => boolean;
					lt: (other: string | number | Long.Long) => boolean;
					lessThanOrEqual: (other: string | number | Long.Long) => boolean;
					lte: (other: string | number | Long.Long) => boolean;
					modulo: (other: string | number | Long.Long) => Long.Long;
					mod: (other: string | number | Long.Long) => Long.Long;
					multiply: (multiplier: string | number | Long.Long) => Long.Long;
					mul: (multiplier: string | number | Long.Long) => Long.Long;
					negate: () => Long.Long;
					neg: () => Long.Long;
					not: () => Long.Long;
					notEquals: (other: string | number | Long.Long) => boolean;
					neq: (other: string | number | Long.Long) => boolean;
					or: (other: string | number | Long.Long) => Long.Long;
					shiftLeft: (numBits: number | Long.Long) => Long.Long;
					shl: (numBits: number | Long.Long) => Long.Long;
					shiftRight: (numBits: number | Long.Long) => Long.Long;
					shr: (numBits: number | Long.Long) => Long.Long;
					shiftRightUnsigned: (numBits: number | Long.Long) => Long.Long;
					shru: (numBits: number | Long.Long) => Long.Long;
					subtract: (subtrahend: string | number | Long.Long) => Long.Long;
					sub: (subtrahend: string | number | Long.Long) => Long.Long;
					toInt: () => number;
					toNumber: () => number;
					toBytes: (le?: boolean) => number[];
					toBytesLE: () => number[];
					toBytesBE: () => number[];
					toSigned: () => Long.Long;
					toString: (radix?: number) => string;
					toUnsigned: () => Long.Long;
					xor: (other: string | number | Long.Long) => Long.Long;
				} & Record<Exclude<keyof I["unbond"]["entries"][number]["creationHeight"], keyof Long.Long>, never>);
				completionTime?: Date;
				initialBalance?: string;
				balance?: string;
			} & Record<Exclude<keyof I["unbond"]["entries"][number], keyof UnbondingDelegationEntry>, never>)[] & Record<Exclude<keyof I["unbond"]["entries"], keyof {
				creationHeight?: string | number | Long.Long;
				completionTime?: Date;
				initialBalance?: string;
				balance?: string;
			}[]>, never>;
		} & Record<Exclude<keyof I["unbond"], keyof UnbondingDelegation>, never>;
	} & Record<Exclude<keyof I, "unbond">, never>>(object: I): QueryUnbondingDelegationResponse;
};
declare const QueryDelegatorDelegationsRequest: {
	encode(message: QueryDelegatorDelegationsRequest, writer?: _m0.Writer): _m0.Writer;
	decode(input: _m0.Reader | Uint8Array, length?: number): QueryDelegatorDelegationsRequest;
	fromJSON(object: any): QueryDelegatorDelegationsRequest;
	toJSON(message: QueryDelegatorDelegationsRequest): unknown;
	fromPartial<I extends {
		delegatorAddr?: string;
		pagination?: {
			key?: Uint8Array;
			offset?: string | number | Long.Long;
			limit?: string | number | Long.Long;
			countTotal?: boolean;
			reverse?: boolean;
		};
	} & {
		delegatorAddr?: string;
		pagination?: {
			key?: Uint8Array;
			offset?: string | number | Long.Long;
			limit?: string | number | Long.Long;
			countTotal?: boolean;
			reverse?: boolean;
		} & {
			key?: Uint8Array;
			offset?: string | number | (Long.Long & {
				high: number;
				low: number;
				unsigned: boolean;
				add: (addend: string | number | Long.Long) => Long.Long;
				and: (other: string | number | Long.Long) => Long.Long;
				compare: (other: string | number | Long.Long) => number;
				comp: (other: string | number | Long.Long) => number;
				divide: (divisor: string | number | Long.Long) => Long.Long;
				div: (divisor: string | number | Long.Long) => Long.Long;
				equals: (other: string | number | Long.Long) => boolean;
				eq: (other: string | number | Long.Long) => boolean;
				getHighBits: () => number;
				getHighBitsUnsigned: () => number;
				getLowBits: () => number;
				getLowBitsUnsigned: () => number;
				getNumBitsAbs: () => number;
				greaterThan: (other: string | number | Long.Long) => boolean;
				gt: (other: string | number | Long.Long) => boolean;
				greaterThanOrEqual: (other: string | number | Long.Long) => boolean;
				gte: (other: string | number | Long.Long) => boolean;
				isEven: () => boolean;
				isNegative: () => boolean;
				isOdd: () => boolean;
				isPositive: () => boolean;
				isZero: () => boolean;
				lessThan: (other: string | number | Long.Long) => boolean;
				lt: (other: string | number | Long.Long) => boolean;
				lessThanOrEqual: (other: string | number | Long.Long) => boolean;
				lte: (other: string | number | Long.Long) => boolean;
				modulo: (other: string | number | Long.Long) => Long.Long;
				mod: (other: string | number | Long.Long) => Long.Long;
				multiply: (multiplier: string | number | Long.Long) => Long.Long;
				mul: (multiplier: string | number | Long.Long) => Long.Long;
				negate: () => Long.Long;
				neg: () => Long.Long;
				not: () => Long.Long;
				notEquals: (other: string | number | Long.Long) => boolean;
				neq: (other: string | number | Long.Long) => boolean;
				or: (other: string | number | Long.Long) => Long.Long;
				shiftLeft: (numBits: number | Long.Long) => Long.Long;
				shl: (numBits: number | Long.Long) => Long.Long;
				shiftRight: (numBits: number | Long.Long) => Long.Long;
				shr: (numBits: number | Long.Long) => Long.Long;
				shiftRightUnsigned: (numBits: number | Long.Long) => Long.Long;
				shru: (numBits: number | Long.Long) => Long.Long;
				subtract: (subtrahend: string | number | Long.Long) => Long.Long;
				sub: (subtrahend: string | number | Long.Long) => Long.Long;
				toInt: () => number;
				toNumber: () => number;
				toBytes: (le?: boolean) => number[];
				toBytesLE: () => number[];
				toBytesBE: () => number[];
				toSigned: () => Long.Long;
				toString: (radix?: number) => string;
				toUnsigned: () => Long.Long;
				xor: (other: string | number | Long.Long) => Long.Long;
			} & Record<Exclude<keyof I["pagination"]["offset"], keyof Long.Long>, never>);
			limit?: string | number | (Long.Long & {
				high: number;
				low: number;
				unsigned: boolean;
				add: (addend: string | number | Long.Long) => Long.Long;
				and: (other: string | number | Long.Long) => Long.Long;
				compare: (other: string | number | Long.Long) => number;
				comp: (other: string | number | Long.Long) => number;
				divide: (divisor: string | number | Long.Long) => Long.Long;
				div: (divisor: string | number | Long.Long) => Long.Long;
				equals: (other: string | number | Long.Long) => boolean;
				eq: (other: string | number | Long.Long) => boolean;
				getHighBits: () => number;
				getHighBitsUnsigned: () => number;
				getLowBits: () => number;
				getLowBitsUnsigned: () => number;
				getNumBitsAbs: () => number;
				greaterThan: (other: string | number | Long.Long) => boolean;
				gt: (other: string | number | Long.Long) => boolean;
				greaterThanOrEqual: (other: string | number | Long.Long) => boolean;
				gte: (other: string | number | Long.Long) => boolean;
				isEven: () => boolean;
				isNegative: () => boolean;
				isOdd: () => boolean;
				isPositive: () => boolean;
				isZero: () => boolean;
				lessThan: (other: string | number | Long.Long) => boolean;
				lt: (other: string | number | Long.Long) => boolean;
				lessThanOrEqual: (other: string | number | Long.Long) => boolean;
				lte: (other: string | number | Long.Long) => boolean;
				modulo: (other: string | number | Long.Long) => Long.Long;
				mod: (other: string | number | Long.Long) => Long.Long;
				multiply: (multiplier: string | number | Long.Long) => Long.Long;
				mul: (multiplier: string | number | Long.Long) => Long.Long;
				negate: () => Long.Long;
				neg: () => Long.Long;
				not: () => Long.Long;
				notEquals: (other: string | number | Long.Long) => boolean;
				neq: (other: string | number | Long.Long) => boolean;
				or: (other: string | number | Long.Long) => Long.Long;
				shiftLeft: (numBits: number | Long.Long) => Long.Long;
				shl: (numBits: number | Long.Long) => Long.Long;
				shiftRight: (numBits: number | Long.Long) => Long.Long;
				shr: (numBits: number | Long.Long) => Long.Long;
				shiftRightUnsigned: (numBits: number | Long.Long) => Long.Long;
				shru: (numBits: number | Long.Long) => Long.Long;
				subtract: (subtrahend: string | number | Long.Long) => Long.Long;
				sub: (subtrahend: string | number | Long.Long) => Long.Long;
				toInt: () => number;
				toNumber: () => number;
				toBytes: (le?: boolean) => number[];
				toBytesLE: () => number[];
				toBytesBE: () => number[];
				toSigned: () => Long.Long;
				toString: (radix?: number) => string;
				toUnsigned: () => Long.Long;
				xor: (other: string | number | Long.Long) => Long.Long;
			} & Record<Exclude<keyof I["pagination"]["limit"], keyof Long.Long>, never>);
			countTotal?: boolean;
			reverse?: boolean;
		} & Record<Exclude<keyof I["pagination"], keyof PageRequest>, never>;
	} & Record<Exclude<keyof I, keyof QueryDelegatorDelegationsRequest>, never>>(object: I): QueryDelegatorDelegationsRequest;
};
declare const QueryDelegatorDelegationsResponse: {
	encode(message: QueryDelegatorDelegationsResponse, writer?: _m0.Writer): _m0.Writer;
	decode(input: _m0.Reader | Uint8Array, length?: number): QueryDelegatorDelegationsResponse;
	fromJSON(object: any): QueryDelegatorDelegationsResponse;
	toJSON(message: QueryDelegatorDelegationsResponse): unknown;
	fromPartial<I extends {
		delegationResponses?: {
			delegation?: {
				delegatorAddress?: string;
				validatorAddress?: string;
				shares?: string;
			};
			balance?: {
				denom?: string;
				amount?: string;
			};
		}[];
		pagination?: {
			nextKey?: Uint8Array;
			total?: string | number | Long.Long;
		};
	} & {
		delegationResponses?: {
			delegation?: {
				delegatorAddress?: string;
				validatorAddress?: string;
				shares?: string;
			};
			balance?: {
				denom?: string;
				amount?: string;
			};
		}[] & ({
			delegation?: {
				delegatorAddress?: string;
				validatorAddress?: string;
				shares?: string;
			};
			balance?: {
				denom?: string;
				amount?: string;
			};
		} & {
			delegation?: {
				delegatorAddress?: string;
				validatorAddress?: string;
				shares?: string;
			} & {
				delegatorAddress?: string;
				validatorAddress?: string;
				shares?: string;
			} & Record<Exclude<keyof I["delegationResponses"][number]["delegation"], keyof Delegation>, never>;
			balance?: {
				denom?: string;
				amount?: string;
			} & {
				denom?: string;
				amount?: string;
			} & Record<Exclude<keyof I["delegationResponses"][number]["balance"], keyof Coin>, never>;
		} & Record<Exclude<keyof I["delegationResponses"][number], keyof DelegationResponse>, never>)[] & Record<Exclude<keyof I["delegationResponses"], keyof {
			delegation?: {
				delegatorAddress?: string;
				validatorAddress?: string;
				shares?: string;
			};
			balance?: {
				denom?: string;
				amount?: string;
			};
		}[]>, never>;
		pagination?: {
			nextKey?: Uint8Array;
			total?: string | number | Long.Long;
		} & {
			nextKey?: Uint8Array;
			total?: string | number | (Long.Long & {
				high: number;
				low: number;
				unsigned: boolean;
				add: (addend: string | number | Long.Long) => Long.Long;
				and: (other: string | number | Long.Long) => Long.Long;
				compare: (other: string | number | Long.Long) => number;
				comp: (other: string | number | Long.Long) => number;
				divide: (divisor: string | number | Long.Long) => Long.Long;
				div: (divisor: string | number | Long.Long) => Long.Long;
				equals: (other: string | number | Long.Long) => boolean;
				eq: (other: string | number | Long.Long) => boolean;
				getHighBits: () => number;
				getHighBitsUnsigned: () => number;
				getLowBits: () => number;
				getLowBitsUnsigned: () => number;
				getNumBitsAbs: () => number;
				greaterThan: (other: string | number | Long.Long) => boolean;
				gt: (other: string | number | Long.Long) => boolean;
				greaterThanOrEqual: (other: string | number | Long.Long) => boolean;
				gte: (other: string | number | Long.Long) => boolean;
				isEven: () => boolean;
				isNegative: () => boolean;
				isOdd: () => boolean;
				isPositive: () => boolean;
				isZero: () => boolean;
				lessThan: (other: string | number | Long.Long) => boolean;
				lt: (other: string | number | Long.Long) => boolean;
				lessThanOrEqual: (other: string | number | Long.Long) => boolean;
				lte: (other: string | number | Long.Long) => boolean;
				modulo: (other: string | number | Long.Long) => Long.Long;
				mod: (other: string | number | Long.Long) => Long.Long;
				multiply: (multiplier: string | number | Long.Long) => Long.Long;
				mul: (multiplier: string | number | Long.Long) => Long.Long;
				negate: () => Long.Long;
				neg: () => Long.Long;
				not: () => Long.Long;
				notEquals: (other: string | number | Long.Long) => boolean;
				neq: (other: string | number | Long.Long) => boolean;
				or: (other: string | number | Long.Long) => Long.Long;
				shiftLeft: (numBits: number | Long.Long) => Long.Long;
				shl: (numBits: number | Long.Long) => Long.Long;
				shiftRight: (numBits: number | Long.Long) => Long.Long;
				shr: (numBits: number | Long.Long) => Long.Long;
				shiftRightUnsigned: (numBits: number | Long.Long) => Long.Long;
				shru: (numBits: number | Long.Long) => Long.Long;
				subtract: (subtrahend: string | number | Long.Long) => Long.Long;
				sub: (subtrahend: string | number | Long.Long) => Long.Long;
				toInt: () => number;
				toNumber: () => number;
				toBytes: (le?: boolean) => number[];
				toBytesLE: () => number[];
				toBytesBE: () => number[];
				toSigned: () => Long.Long;
				toString: (radix?: number) => string;
				toUnsigned: () => Long.Long;
				xor: (other: string | number | Long.Long) => Long.Long;
			} & Record<Exclude<keyof I["pagination"]["total"], keyof Long.Long>, never>);
		} & Record<Exclude<keyof I["pagination"], keyof PageResponse>, never>;
	} & Record<Exclude<keyof I, keyof QueryDelegatorDelegationsResponse>, never>>(object: I): QueryDelegatorDelegationsResponse;
};
declare const QueryDelegatorUnbondingDelegationsRequest: {
	encode(message: QueryDelegatorUnbondingDelegationsRequest, writer?: _m0.Writer): _m0.Writer;
	decode(input: _m0.Reader | Uint8Array, length?: number): QueryDelegatorUnbondingDelegationsRequest;
	fromJSON(object: any): QueryDelegatorUnbondingDelegationsRequest;
	toJSON(message: QueryDelegatorUnbondingDelegationsRequest): unknown;
	fromPartial<I extends {
		delegatorAddr?: string;
		pagination?: {
			key?: Uint8Array;
			offset?: string | number | Long.Long;
			limit?: string | number | Long.Long;
			countTotal?: boolean;
			reverse?: boolean;
		};
	} & {
		delegatorAddr?: string;
		pagination?: {
			key?: Uint8Array;
			offset?: string | number | Long.Long;
			limit?: string | number | Long.Long;
			countTotal?: boolean;
			reverse?: boolean;
		} & {
			key?: Uint8Array;
			offset?: string | number | (Long.Long & {
				high: number;
				low: number;
				unsigned: boolean;
				add: (addend: string | number | Long.Long) => Long.Long;
				and: (other: string | number | Long.Long) => Long.Long;
				compare: (other: string | number | Long.Long) => number;
				comp: (other: string | number | Long.Long) => number;
				divide: (divisor: string | number | Long.Long) => Long.Long;
				div: (divisor: string | number | Long.Long) => Long.Long;
				equals: (other: string | number | Long.Long) => boolean;
				eq: (other: string | number | Long.Long) => boolean;
				getHighBits: () => number;
				getHighBitsUnsigned: () => number;
				getLowBits: () => number;
				getLowBitsUnsigned: () => number;
				getNumBitsAbs: () => number;
				greaterThan: (other: string | number | Long.Long) => boolean;
				gt: (other: string | number | Long.Long) => boolean;
				greaterThanOrEqual: (other: string | number | Long.Long) => boolean;
				gte: (other: string | number | Long.Long) => boolean;
				isEven: () => boolean;
				isNegative: () => boolean;
				isOdd: () => boolean;
				isPositive: () => boolean;
				isZero: () => boolean;
				lessThan: (other: string | number | Long.Long) => boolean;
				lt: (other: string | number | Long.Long) => boolean;
				lessThanOrEqual: (other: string | number | Long.Long) => boolean;
				lte: (other: string | number | Long.Long) => boolean;
				modulo: (other: string | number | Long.Long) => Long.Long;
				mod: (other: string | number | Long.Long) => Long.Long;
				multiply: (multiplier: string | number | Long.Long) => Long.Long;
				mul: (multiplier: string | number | Long.Long) => Long.Long;
				negate: () => Long.Long;
				neg: () => Long.Long;
				not: () => Long.Long;
				notEquals: (other: string | number | Long.Long) => boolean;
				neq: (other: string | number | Long.Long) => boolean;
				or: (other: string | number | Long.Long) => Long.Long;
				shiftLeft: (numBits: number | Long.Long) => Long.Long;
				shl: (numBits: number | Long.Long) => Long.Long;
				shiftRight: (numBits: number | Long.Long) => Long.Long;
				shr: (numBits: number | Long.Long) => Long.Long;
				shiftRightUnsigned: (numBits: number | Long.Long) => Long.Long;
				shru: (numBits: number | Long.Long) => Long.Long;
				subtract: (subtrahend: string | number | Long.Long) => Long.Long;
				sub: (subtrahend: string | number | Long.Long) => Long.Long;
				toInt: () => number;
				toNumber: () => number;
				toBytes: (le?: boolean) => number[];
				toBytesLE: () => number[];
				toBytesBE: () => number[];
				toSigned: () => Long.Long;
				toString: (radix?: number) => string;
				toUnsigned: () => Long.Long;
				xor: (other: string | number | Long.Long) => Long.Long;
			} & Record<Exclude<keyof I["pagination"]["offset"], keyof Long.Long>, never>);
			limit?: string | number | (Long.Long & {
				high: number;
				low: number;
				unsigned: boolean;
				add: (addend: string | number | Long.Long) => Long.Long;
				and: (other: string | number | Long.Long) => Long.Long;
				compare: (other: string | number | Long.Long) => number;
				comp: (other: string | number | Long.Long) => number;
				divide: (divisor: string | number | Long.Long) => Long.Long;
				div: (divisor: string | number | Long.Long) => Long.Long;
				equals: (other: string | number | Long.Long) => boolean;
				eq: (other: string | number | Long.Long) => boolean;
				getHighBits: () => number;
				getHighBitsUnsigned: () => number;
				getLowBits: () => number;
				getLowBitsUnsigned: () => number;
				getNumBitsAbs: () => number;
				greaterThan: (other: string | number | Long.Long) => boolean;
				gt: (other: string | number | Long.Long) => boolean;
				greaterThanOrEqual: (other: string | number | Long.Long) => boolean;
				gte: (other: string | number | Long.Long) => boolean;
				isEven: () => boolean;
				isNegative: () => boolean;
				isOdd: () => boolean;
				isPositive: () => boolean;
				isZero: () => boolean;
				lessThan: (other: string | number | Long.Long) => boolean;
				lt: (other: string | number | Long.Long) => boolean;
				lessThanOrEqual: (other: string | number | Long.Long) => boolean;
				lte: (other: string | number | Long.Long) => boolean;
				modulo: (other: string | number | Long.Long) => Long.Long;
				mod: (other: string | number | Long.Long) => Long.Long;
				multiply: (multiplier: string | number | Long.Long) => Long.Long;
				mul: (multiplier: string | number | Long.Long) => Long.Long;
				negate: () => Long.Long;
				neg: () => Long.Long;
				not: () => Long.Long;
				notEquals: (other: string | number | Long.Long) => boolean;
				neq: (other: string | number | Long.Long) => boolean;
				or: (other: string | number | Long.Long) => Long.Long;
				shiftLeft: (numBits: number | Long.Long) => Long.Long;
				shl: (numBits: number | Long.Long) => Long.Long;
				shiftRight: (numBits: number | Long.Long) => Long.Long;
				shr: (numBits: number | Long.Long) => Long.Long;
				shiftRightUnsigned: (numBits: number | Long.Long) => Long.Long;
				shru: (numBits: number | Long.Long) => Long.Long;
				subtract: (subtrahend: string | number | Long.Long) => Long.Long;
				sub: (subtrahend: string | number | Long.Long) => Long.Long;
				toInt: () => number;
				toNumber: () => number;
				toBytes: (le?: boolean) => number[];
				toBytesLE: () => number[];
				toBytesBE: () => number[];
				toSigned: () => Long.Long;
				toString: (radix?: number) => string;
				toUnsigned: () => Long.Long;
				xor: (other: string | number | Long.Long) => Long.Long;
			} & Record<Exclude<keyof I["pagination"]["limit"], keyof Long.Long>, never>);
			countTotal?: boolean;
			reverse?: boolean;
		} & Record<Exclude<keyof I["pagination"], keyof PageRequest>, never>;
	} & Record<Exclude<keyof I, keyof QueryDelegatorUnbondingDelegationsRequest>, never>>(object: I): QueryDelegatorUnbondingDelegationsRequest;
};
declare const QueryDelegatorUnbondingDelegationsResponse: {
	encode(message: QueryDelegatorUnbondingDelegationsResponse, writer?: _m0.Writer): _m0.Writer;
	decode(input: _m0.Reader | Uint8Array, length?: number): QueryDelegatorUnbondingDelegationsResponse;
	fromJSON(object: any): QueryDelegatorUnbondingDelegationsResponse;
	toJSON(message: QueryDelegatorUnbondingDelegationsResponse): unknown;
	fromPartial<I extends {
		unbondingResponses?: {
			delegatorAddress?: string;
			validatorAddress?: string;
			entries?: {
				creationHeight?: string | number | Long.Long;
				completionTime?: Date;
				initialBalance?: string;
				balance?: string;
			}[];
		}[];
		pagination?: {
			nextKey?: Uint8Array;
			total?: string | number | Long.Long;
		};
	} & {
		unbondingResponses?: {
			delegatorAddress?: string;
			validatorAddress?: string;
			entries?: {
				creationHeight?: string | number | Long.Long;
				completionTime?: Date;
				initialBalance?: string;
				balance?: string;
			}[];
		}[] & ({
			delegatorAddress?: string;
			validatorAddress?: string;
			entries?: {
				creationHeight?: string | number | Long.Long;
				completionTime?: Date;
				initialBalance?: string;
				balance?: string;
			}[];
		} & {
			delegatorAddress?: string;
			validatorAddress?: string;
			entries?: {
				creationHeight?: string | number | Long.Long;
				completionTime?: Date;
				initialBalance?: string;
				balance?: string;
			}[] & ({
				creationHeight?: string | number | Long.Long;
				completionTime?: Date;
				initialBalance?: string;
				balance?: string;
			} & {
				creationHeight?: string | number | (Long.Long & {
					high: number;
					low: number;
					unsigned: boolean;
					add: (addend: string | number | Long.Long) => Long.Long;
					and: (other: string | number | Long.Long) => Long.Long;
					compare: (other: string | number | Long.Long) => number;
					comp: (other: string | number | Long.Long) => number;
					divide: (divisor: string | number | Long.Long) => Long.Long;
					div: (divisor: string | number | Long.Long) => Long.Long;
					equals: (other: string | number | Long.Long) => boolean;
					eq: (other: string | number | Long.Long) => boolean;
					getHighBits: () => number;
					getHighBitsUnsigned: () => number;
					getLowBits: () => number;
					getLowBitsUnsigned: () => number;
					getNumBitsAbs: () => number;
					greaterThan: (other: string | number | Long.Long) => boolean;
					gt: (other: string | number | Long.Long) => boolean;
					greaterThanOrEqual: (other: string | number | Long.Long) => boolean;
					gte: (other: string | number | Long.Long) => boolean;
					isEven: () => boolean;
					isNegative: () => boolean;
					isOdd: () => boolean;
					isPositive: () => boolean;
					isZero: () => boolean;
					lessThan: (other: string | number | Long.Long) => boolean;
					lt: (other: string | number | Long.Long) => boolean;
					lessThanOrEqual: (other: string | number | Long.Long) => boolean;
					lte: (other: string | number | Long.Long) => boolean;
					modulo: (other: string | number | Long.Long) => Long.Long;
					mod: (other: string | number | Long.Long) => Long.Long;
					multiply: (multiplier: string | number | Long.Long) => Long.Long;
					mul: (multiplier: string | number | Long.Long) => Long.Long;
					negate: () => Long.Long;
					neg: () => Long.Long;
					not: () => Long.Long;
					notEquals: (other: string | number | Long.Long) => boolean;
					neq: (other: string | number | Long.Long) => boolean;
					or: (other: string | number | Long.Long) => Long.Long;
					shiftLeft: (numBits: number | Long.Long) => Long.Long;
					shl: (numBits: number | Long.Long) => Long.Long;
					shiftRight: (numBits: number | Long.Long) => Long.Long;
					shr: (numBits: number | Long.Long) => Long.Long;
					shiftRightUnsigned: (numBits: number | Long.Long) => Long.Long;
					shru: (numBits: number | Long.Long) => Long.Long;
					subtract: (subtrahend: string | number | Long.Long) => Long.Long;
					sub: (subtrahend: string | number | Long.Long) => Long.Long;
					toInt: () => number;
					toNumber: () => number;
					toBytes: (le?: boolean) => number[];
					toBytesLE: () => number[];
					toBytesBE: () => number[];
					toSigned: () => Long.Long;
					toString: (radix?: number) => string;
					toUnsigned: () => Long.Long;
					xor: (other: string | number | Long.Long) => Long.Long;
				} & Record<Exclude<keyof I["unbondingResponses"][number]["entries"][number]["creationHeight"], keyof Long.Long>, never>);
				completionTime?: Date;
				initialBalance?: string;
				balance?: string;
			} & Record<Exclude<keyof I["unbondingResponses"][number]["entries"][number], keyof UnbondingDelegationEntry>, never>)[] & Record<Exclude<keyof I["unbondingResponses"][number]["entries"], keyof {
				creationHeight?: string | number | Long.Long;
				completionTime?: Date;
				initialBalance?: string;
				balance?: string;
			}[]>, never>;
		} & Record<Exclude<keyof I["unbondingResponses"][number], keyof UnbondingDelegation>, never>)[] & Record<Exclude<keyof I["unbondingResponses"], keyof {
			delegatorAddress?: string;
			validatorAddress?: string;
			entries?: {
				creationHeight?: string | number | Long.Long;
				completionTime?: Date;
				initialBalance?: string;
				balance?: string;
			}[];
		}[]>, never>;
		pagination?: {
			nextKey?: Uint8Array;
			total?: string | number | Long.Long;
		} & {
			nextKey?: Uint8Array;
			total?: string | number | (Long.Long & {
				high: number;
				low: number;
				unsigned: boolean;
				add: (addend: string | number | Long.Long) => Long.Long;
				and: (other: string | number | Long.Long) => Long.Long;
				compare: (other: string | number | Long.Long) => number;
				comp: (other: string | number | Long.Long) => number;
				divide: (divisor: string | number | Long.Long) => Long.Long;
				div: (divisor: string | number | Long.Long) => Long.Long;
				equals: (other: string | number | Long.Long) => boolean;
				eq: (other: string | number | Long.Long) => boolean;
				getHighBits: () => number;
				getHighBitsUnsigned: () => number;
				getLowBits: () => number;
				getLowBitsUnsigned: () => number;
				getNumBitsAbs: () => number;
				greaterThan: (other: string | number | Long.Long) => boolean;
				gt: (other: string | number | Long.Long) => boolean;
				greaterThanOrEqual: (other: string | number | Long.Long) => boolean;
				gte: (other: string | number | Long.Long) => boolean;
				isEven: () => boolean;
				isNegative: () => boolean;
				isOdd: () => boolean;
				isPositive: () => boolean;
				isZero: () => boolean;
				lessThan: (other: string | number | Long.Long) => boolean;
				lt: (other: string | number | Long.Long) => boolean;
				lessThanOrEqual: (other: string | number | Long.Long) => boolean;
				lte: (other: string | number | Long.Long) => boolean;
				modulo: (other: string | number | Long.Long) => Long.Long;
				mod: (other: string | number | Long.Long) => Long.Long;
				multiply: (multiplier: string | number | Long.Long) => Long.Long;
				mul: (multiplier: string | number | Long.Long) => Long.Long;
				negate: () => Long.Long;
				neg: () => Long.Long;
				not: () => Long.Long;
				notEquals: (other: string | number | Long.Long) => boolean;
				neq: (other: string | number | Long.Long) => boolean;
				or: (other: string | number | Long.Long) => Long.Long;
				shiftLeft: (numBits: number | Long.Long) => Long.Long;
				shl: (numBits: number | Long.Long) => Long.Long;
				shiftRight: (numBits: number | Long.Long) => Long.Long;
				shr: (numBits: number | Long.Long) => Long.Long;
				shiftRightUnsigned: (numBits: number | Long.Long) => Long.Long;
				shru: (numBits: number | Long.Long) => Long.Long;
				subtract: (subtrahend: string | number | Long.Long) => Long.Long;
				sub: (subtrahend: string | number | Long.Long) => Long.Long;
				toInt: () => number;
				toNumber: () => number;
				toBytes: (le?: boolean) => number[];
				toBytesLE: () => number[];
				toBytesBE: () => number[];
				toSigned: () => Long.Long;
				toString: (radix?: number) => string;
				toUnsigned: () => Long.Long;
				xor: (other: string | number | Long.Long) => Long.Long;
			} & Record<Exclude<keyof I["pagination"]["total"], keyof Long.Long>, never>);
		} & Record<Exclude<keyof I["pagination"], keyof PageResponse>, never>;
	} & Record<Exclude<keyof I, keyof QueryDelegatorUnbondingDelegationsResponse>, never>>(object: I): QueryDelegatorUnbondingDelegationsResponse;
};
declare const QueryRedelegationsRequest: {
	encode(message: QueryRedelegationsRequest, writer?: _m0.Writer): _m0.Writer;
	decode(input: _m0.Reader | Uint8Array, length?: number): QueryRedelegationsRequest;
	fromJSON(object: any): QueryRedelegationsRequest;
	toJSON(message: QueryRedelegationsRequest): unknown;
	fromPartial<I extends {
		delegatorAddr?: string;
		srcValidatorAddr?: string;
		dstValidatorAddr?: string;
		pagination?: {
			key?: Uint8Array;
			offset?: string | number | Long.Long;
			limit?: string | number | Long.Long;
			countTotal?: boolean;
			reverse?: boolean;
		};
	} & {
		delegatorAddr?: string;
		srcValidatorAddr?: string;
		dstValidatorAddr?: string;
		pagination?: {
			key?: Uint8Array;
			offset?: string | number | Long.Long;
			limit?: string | number | Long.Long;
			countTotal?: boolean;
			reverse?: boolean;
		} & {
			key?: Uint8Array;
			offset?: string | number | (Long.Long & {
				high: number;
				low: number;
				unsigned: boolean;
				add: (addend: string | number | Long.Long) => Long.Long;
				and: (other: string | number | Long.Long) => Long.Long;
				compare: (other: string | number | Long.Long) => number;
				comp: (other: string | number | Long.Long) => number;
				divide: (divisor: string | number | Long.Long) => Long.Long;
				div: (divisor: string | number | Long.Long) => Long.Long;
				equals: (other: string | number | Long.Long) => boolean;
				eq: (other: string | number | Long.Long) => boolean;
				getHighBits: () => number;
				getHighBitsUnsigned: () => number;
				getLowBits: () => number;
				getLowBitsUnsigned: () => number;
				getNumBitsAbs: () => number;
				greaterThan: (other: string | number | Long.Long) => boolean;
				gt: (other: string | number | Long.Long) => boolean;
				greaterThanOrEqual: (other: string | number | Long.Long) => boolean;
				gte: (other: string | number | Long.Long) => boolean;
				isEven: () => boolean;
				isNegative: () => boolean;
				isOdd: () => boolean;
				isPositive: () => boolean;
				isZero: () => boolean;
				lessThan: (other: string | number | Long.Long) => boolean;
				lt: (other: string | number | Long.Long) => boolean;
				lessThanOrEqual: (other: string | number | Long.Long) => boolean;
				lte: (other: string | number | Long.Long) => boolean;
				modulo: (other: string | number | Long.Long) => Long.Long;
				mod: (other: string | number | Long.Long) => Long.Long;
				multiply: (multiplier: string | number | Long.Long) => Long.Long;
				mul: (multiplier: string | number | Long.Long) => Long.Long;
				negate: () => Long.Long;
				neg: () => Long.Long;
				not: () => Long.Long;
				notEquals: (other: string | number | Long.Long) => boolean;
				neq: (other: string | number | Long.Long) => boolean;
				or: (other: string | number | Long.Long) => Long.Long;
				shiftLeft: (numBits: number | Long.Long) => Long.Long;
				shl: (numBits: number | Long.Long) => Long.Long;
				shiftRight: (numBits: number | Long.Long) => Long.Long;
				shr: (numBits: number | Long.Long) => Long.Long;
				shiftRightUnsigned: (numBits: number | Long.Long) => Long.Long;
				shru: (numBits: number | Long.Long) => Long.Long;
				subtract: (subtrahend: string | number | Long.Long) => Long.Long;
				sub: (subtrahend: string | number | Long.Long) => Long.Long;
				toInt: () => number;
				toNumber: () => number;
				toBytes: (le?: boolean) => number[];
				toBytesLE: () => number[];
				toBytesBE: () => number[];
				toSigned: () => Long.Long;
				toString: (radix?: number) => string;
				toUnsigned: () => Long.Long;
				xor: (other: string | number | Long.Long) => Long.Long;
			} & Record<Exclude<keyof I["pagination"]["offset"], keyof Long.Long>, never>);
			limit?: string | number | (Long.Long & {
				high: number;
				low: number;
				unsigned: boolean;
				add: (addend: string | number | Long.Long) => Long.Long;
				and: (other: string | number | Long.Long) => Long.Long;
				compare: (other: string | number | Long.Long) => number;
				comp: (other: string | number | Long.Long) => number;
				divide: (divisor: string | number | Long.Long) => Long.Long;
				div: (divisor: string | number | Long.Long) => Long.Long;
				equals: (other: string | number | Long.Long) => boolean;
				eq: (other: string | number | Long.Long) => boolean;
				getHighBits: () => number;
				getHighBitsUnsigned: () => number;
				getLowBits: () => number;
				getLowBitsUnsigned: () => number;
				getNumBitsAbs: () => number;
				greaterThan: (other: string | number | Long.Long) => boolean;
				gt: (other: string | number | Long.Long) => boolean;
				greaterThanOrEqual: (other: string | number | Long.Long) => boolean;
				gte: (other: string | number | Long.Long) => boolean;
				isEven: () => boolean;
				isNegative: () => boolean;
				isOdd: () => boolean;
				isPositive: () => boolean;
				isZero: () => boolean;
				lessThan: (other: string | number | Long.Long) => boolean;
				lt: (other: string | number | Long.Long) => boolean;
				lessThanOrEqual: (other: string | number | Long.Long) => boolean;
				lte: (other: string | number | Long.Long) => boolean;
				modulo: (other: string | number | Long.Long) => Long.Long;
				mod: (other: string | number | Long.Long) => Long.Long;
				multiply: (multiplier: string | number | Long.Long) => Long.Long;
				mul: (multiplier: string | number | Long.Long) => Long.Long;
				negate: () => Long.Long;
				neg: () => Long.Long;
				not: () => Long.Long;
				notEquals: (other: string | number | Long.Long) => boolean;
				neq: (other: string | number | Long.Long) => boolean;
				or: (other: string | number | Long.Long) => Long.Long;
				shiftLeft: (numBits: number | Long.Long) => Long.Long;
				shl: (numBits: number | Long.Long) => Long.Long;
				shiftRight: (numBits: number | Long.Long) => Long.Long;
				shr: (numBits: number | Long.Long) => Long.Long;
				shiftRightUnsigned: (numBits: number | Long.Long) => Long.Long;
				shru: (numBits: number | Long.Long) => Long.Long;
				subtract: (subtrahend: string | number | Long.Long) => Long.Long;
				sub: (subtrahend: string | number | Long.Long) => Long.Long;
				toInt: () => number;
				toNumber: () => number;
				toBytes: (le?: boolean) => number[];
				toBytesLE: () => number[];
				toBytesBE: () => number[];
				toSigned: () => Long.Long;
				toString: (radix?: number) => string;
				toUnsigned: () => Long.Long;
				xor: (other: string | number | Long.Long) => Long.Long;
			} & Record<Exclude<keyof I["pagination"]["limit"], keyof Long.Long>, never>);
			countTotal?: boolean;
			reverse?: boolean;
		} & Record<Exclude<keyof I["pagination"], keyof PageRequest>, never>;
	} & Record<Exclude<keyof I, keyof QueryRedelegationsRequest>, never>>(object: I): QueryRedelegationsRequest;
};
declare const QueryRedelegationsResponse: {
	encode(message: QueryRedelegationsResponse, writer?: _m0.Writer): _m0.Writer;
	decode(input: _m0.Reader | Uint8Array, length?: number): QueryRedelegationsResponse;
	fromJSON(object: any): QueryRedelegationsResponse;
	toJSON(message: QueryRedelegationsResponse): unknown;
	fromPartial<I extends {
		redelegationResponses?: {
			redelegation?: {
				delegatorAddress?: string;
				validatorSrcAddress?: string;
				validatorDstAddress?: string;
				entries?: {
					creationHeight?: string | number | Long.Long;
					completionTime?: Date;
					initialBalance?: string;
					sharesDst?: string;
				}[];
			};
			entries?: {
				redelegationEntry?: {
					creationHeight?: string | number | Long.Long;
					completionTime?: Date;
					initialBalance?: string;
					sharesDst?: string;
				};
				balance?: string;
			}[];
		}[];
		pagination?: {
			nextKey?: Uint8Array;
			total?: string | number | Long.Long;
		};
	} & {
		redelegationResponses?: {
			redelegation?: {
				delegatorAddress?: string;
				validatorSrcAddress?: string;
				validatorDstAddress?: string;
				entries?: {
					creationHeight?: string | number | Long.Long;
					completionTime?: Date;
					initialBalance?: string;
					sharesDst?: string;
				}[];
			};
			entries?: {
				redelegationEntry?: {
					creationHeight?: string | number | Long.Long;
					completionTime?: Date;
					initialBalance?: string;
					sharesDst?: string;
				};
				balance?: string;
			}[];
		}[] & ({
			redelegation?: {
				delegatorAddress?: string;
				validatorSrcAddress?: string;
				validatorDstAddress?: string;
				entries?: {
					creationHeight?: string | number | Long.Long;
					completionTime?: Date;
					initialBalance?: string;
					sharesDst?: string;
				}[];
			};
			entries?: {
				redelegationEntry?: {
					creationHeight?: string | number | Long.Long;
					completionTime?: Date;
					initialBalance?: string;
					sharesDst?: string;
				};
				balance?: string;
			}[];
		} & {
			redelegation?: {
				delegatorAddress?: string;
				validatorSrcAddress?: string;
				validatorDstAddress?: string;
				entries?: {
					creationHeight?: string | number | Long.Long;
					completionTime?: Date;
					initialBalance?: string;
					sharesDst?: string;
				}[];
			} & {
				delegatorAddress?: string;
				validatorSrcAddress?: string;
				validatorDstAddress?: string;
				entries?: {
					creationHeight?: string | number | Long.Long;
					completionTime?: Date;
					initialBalance?: string;
					sharesDst?: string;
				}[] & ({
					creationHeight?: string | number | Long.Long;
					completionTime?: Date;
					initialBalance?: string;
					sharesDst?: string;
				} & {
					creationHeight?: string | number | (Long.Long & {
						high: number;
						low: number;
						unsigned: boolean;
						add: (addend: string | number | Long.Long) => Long.Long;
						and: (other: string | number | Long.Long) => Long.Long;
						compare: (other: string | number | Long.Long) => number;
						comp: (other: string | number | Long.Long) => number;
						divide: (divisor: string | number | Long.Long) => Long.Long;
						div: (divisor: string | number | Long.Long) => Long.Long;
						equals: (other: string | number | Long.Long) => boolean;
						eq: (other: string | number | Long.Long) => boolean;
						getHighBits: () => number;
						getHighBitsUnsigned: () => number;
						getLowBits: () => number;
						getLowBitsUnsigned: () => number;
						getNumBitsAbs: () => number;
						greaterThan: (other: string | number | Long.Long) => boolean;
						gt: (other: string | number | Long.Long) => boolean;
						greaterThanOrEqual: (other: string | number | Long.Long) => boolean;
						gte: (other: string | number | Long.Long) => boolean;
						isEven: () => boolean;
						isNegative: () => boolean;
						isOdd: () => boolean;
						isPositive: () => boolean;
						isZero: () => boolean;
						lessThan: (other: string | number | Long.Long) => boolean;
						lt: (other: string | number | Long.Long) => boolean;
						lessThanOrEqual: (other: string | number | Long.Long) => boolean;
						lte: (other: string | number | Long.Long) => boolean;
						modulo: (other: string | number | Long.Long) => Long.Long;
						mod: (other: string | number | Long.Long) => Long.Long;
						multiply: (multiplier: string | number | Long.Long) => Long.Long;
						mul: (multiplier: string | number | Long.Long) => Long.Long;
						negate: () => Long.Long;
						neg: () => Long.Long;
						not: () => Long.Long;
						notEquals: (other: string | number | Long.Long) => boolean;
						neq: (other: string | number | Long.Long) => boolean;
						or: (other: string | number | Long.Long) => Long.Long;
						shiftLeft: (numBits: number | Long.Long) => Long.Long;
						shl: (numBits: number | Long.Long) => Long.Long;
						shiftRight: (numBits: number | Long.Long) => Long.Long;
						shr: (numBits: number | Long.Long) => Long.Long;
						shiftRightUnsigned: (numBits: number | Long.Long) => Long.Long;
						shru: (numBits: number | Long.Long) => Long.Long;
						subtract: (subtrahend: string | number | Long.Long) => Long.Long;
						sub: (subtrahend: string | number | Long.Long) => Long.Long;
						toInt: () => number;
						toNumber: () => number;
						toBytes: (le?: boolean) => number[];
						toBytesLE: () => number[];
						toBytesBE: () => number[];
						toSigned: () => Long.Long;
						toString: (radix?: number) => string;
						toUnsigned: () => Long.Long;
						xor: (other: string | number | Long.Long) => Long.Long;
					} & Record<Exclude<keyof I["redelegationResponses"][number]["redelegation"]["entries"][number]["creationHeight"], keyof Long.Long>, never>);
					completionTime?: Date;
					initialBalance?: string;
					sharesDst?: string;
				} & Record<Exclude<keyof I["redelegationResponses"][number]["redelegation"]["entries"][number], keyof RedelegationEntry>, never>)[] & Record<Exclude<keyof I["redelegationResponses"][number]["redelegation"]["entries"], keyof {
					creationHeight?: string | number | Long.Long;
					completionTime?: Date;
					initialBalance?: string;
					sharesDst?: string;
				}[]>, never>;
			} & Record<Exclude<keyof I["redelegationResponses"][number]["redelegation"], keyof Redelegation>, never>;
			entries?: {
				redelegationEntry?: {
					creationHeight?: string | number | Long.Long;
					completionTime?: Date;
					initialBalance?: string;
					sharesDst?: string;
				};
				balance?: string;
			}[] & ({
				redelegationEntry?: {
					creationHeight?: string | number | Long.Long;
					completionTime?: Date;
					initialBalance?: string;
					sharesDst?: string;
				};
				balance?: string;
			} & {
				redelegationEntry?: {
					creationHeight?: string | number | Long.Long;
					completionTime?: Date;
					initialBalance?: string;
					sharesDst?: string;
				} & {
					creationHeight?: string | number | (Long.Long & {
						high: number;
						low: number;
						unsigned: boolean;
						add: (addend: string | number | Long.Long) => Long.Long;
						and: (other: string | number | Long.Long) => Long.Long;
						compare: (other: string | number | Long.Long) => number;
						comp: (other: string | number | Long.Long) => number;
						divide: (divisor: string | number | Long.Long) => Long.Long;
						div: (divisor: string | number | Long.Long) => Long.Long;
						equals: (other: string | number | Long.Long) => boolean;
						eq: (other: string | number | Long.Long) => boolean;
						getHighBits: () => number;
						getHighBitsUnsigned: () => number;
						getLowBits: () => number;
						getLowBitsUnsigned: () => number;
						getNumBitsAbs: () => number;
						greaterThan: (other: string | number | Long.Long) => boolean;
						gt: (other: string | number | Long.Long) => boolean;
						greaterThanOrEqual: (other: string | number | Long.Long) => boolean;
						gte: (other: string | number | Long.Long) => boolean;
						isEven: () => boolean;
						isNegative: () => boolean;
						isOdd: () => boolean;
						isPositive: () => boolean;
						isZero: () => boolean;
						lessThan: (other: string | number | Long.Long) => boolean;
						lt: (other: string | number | Long.Long) => boolean;
						lessThanOrEqual: (other: string | number | Long.Long) => boolean;
						lte: (other: string | number | Long.Long) => boolean;
						modulo: (other: string | number | Long.Long) => Long.Long;
						mod: (other: string | number | Long.Long) => Long.Long;
						multiply: (multiplier: string | number | Long.Long) => Long.Long;
						mul: (multiplier: string | number | Long.Long) => Long.Long;
						negate: () => Long.Long;
						neg: () => Long.Long;
						not: () => Long.Long;
						notEquals: (other: string | number | Long.Long) => boolean;
						neq: (other: string | number | Long.Long) => boolean;
						or: (other: string | number | Long.Long) => Long.Long;
						shiftLeft: (numBits: number | Long.Long) => Long.Long;
						shl: (numBits: number | Long.Long) => Long.Long;
						shiftRight: (numBits: number | Long.Long) => Long.Long;
						shr: (numBits: number | Long.Long) => Long.Long;
						shiftRightUnsigned: (numBits: number | Long.Long) => Long.Long;
						shru: (numBits: number | Long.Long) => Long.Long;
						subtract: (subtrahend: string | number | Long.Long) => Long.Long;
						sub: (subtrahend: string | number | Long.Long) => Long.Long;
						toInt: () => number;
						toNumber: () => number;
						toBytes: (le?: boolean) => number[];
						toBytesLE: () => number[];
						toBytesBE: () => number[];
						toSigned: () => Long.Long;
						toString: (radix?: number) => string;
						toUnsigned: () => Long.Long;
						xor: (other: string | number | Long.Long) => Long.Long;
					} & Record<Exclude<keyof I["redelegationResponses"][number]["entries"][number]["redelegationEntry"]["creationHeight"], keyof Long.Long>, never>);
					completionTime?: Date;
					initialBalance?: string;
					sharesDst?: string;
				} & Record<Exclude<keyof I["redelegationResponses"][number]["entries"][number]["redelegationEntry"], keyof RedelegationEntry>, never>;
				balance?: string;
			} & Record<Exclude<keyof I["redelegationResponses"][number]["entries"][number], keyof RedelegationEntryResponse>, never>)[] & Record<Exclude<keyof I["redelegationResponses"][number]["entries"], keyof {
				redelegationEntry?: {
					creationHeight?: string | number | Long.Long;
					completionTime?: Date;
					initialBalance?: string;
					sharesDst?: string;
				};
				balance?: string;
			}[]>, never>;
		} & Record<Exclude<keyof I["redelegationResponses"][number], keyof RedelegationResponse>, never>)[] & Record<Exclude<keyof I["redelegationResponses"], keyof {
			redelegation?: {
				delegatorAddress?: string;
				validatorSrcAddress?: string;
				validatorDstAddress?: string;
				entries?: {
					creationHeight?: string | number | Long.Long;
					completionTime?: Date;
					initialBalance?: string;
					sharesDst?: string;
				}[];
			};
			entries?: {
				redelegationEntry?: {
					creationHeight?: string | number | Long.Long;
					completionTime?: Date;
					initialBalance?: string;
					sharesDst?: string;
				};
				balance?: string;
			}[];
		}[]>, never>;
		pagination?: {
			nextKey?: Uint8Array;
			total?: string | number | Long.Long;
		} & {
			nextKey?: Uint8Array;
			total?: string | number | (Long.Long & {
				high: number;
				low: number;
				unsigned: boolean;
				add: (addend: string | number | Long.Long) => Long.Long;
				and: (other: string | number | Long.Long) => Long.Long;
				compare: (other: string | number | Long.Long) => number;
				comp: (other: string | number | Long.Long) => number;
				divide: (divisor: string | number | Long.Long) => Long.Long;
				div: (divisor: string | number | Long.Long) => Long.Long;
				equals: (other: string | number | Long.Long) => boolean;
				eq: (other: string | number | Long.Long) => boolean;
				getHighBits: () => number;
				getHighBitsUnsigned: () => number;
				getLowBits: () => number;
				getLowBitsUnsigned: () => number;
				getNumBitsAbs: () => number;
				greaterThan: (other: string | number | Long.Long) => boolean;
				gt: (other: string | number | Long.Long) => boolean;
				greaterThanOrEqual: (other: string | number | Long.Long) => boolean;
				gte: (other: string | number | Long.Long) => boolean;
				isEven: () => boolean;
				isNegative: () => boolean;
				isOdd: () => boolean;
				isPositive: () => boolean;
				isZero: () => boolean;
				lessThan: (other: string | number | Long.Long) => boolean;
				lt: (other: string | number | Long.Long) => boolean;
				lessThanOrEqual: (other: string | number | Long.Long) => boolean;
				lte: (other: string | number | Long.Long) => boolean;
				modulo: (other: string | number | Long.Long) => Long.Long;
				mod: (other: string | number | Long.Long) => Long.Long;
				multiply: (multiplier: string | number | Long.Long) => Long.Long;
				mul: (multiplier: string | number | Long.Long) => Long.Long;
				negate: () => Long.Long;
				neg: () => Long.Long;
				not: () => Long.Long;
				notEquals: (other: string | number | Long.Long) => boolean;
				neq: (other: string | number | Long.Long) => boolean;
				or: (other: string | number | Long.Long) => Long.Long;
				shiftLeft: (numBits: number | Long.Long) => Long.Long;
				shl: (numBits: number | Long.Long) => Long.Long;
				shiftRight: (numBits: number | Long.Long) => Long.Long;
				shr: (numBits: number | Long.Long) => Long.Long;
				shiftRightUnsigned: (numBits: number | Long.Long) => Long.Long;
				shru: (numBits: number | Long.Long) => Long.Long;
				subtract: (subtrahend: string | number | Long.Long) => Long.Long;
				sub: (subtrahend: string | number | Long.Long) => Long.Long;
				toInt: () => number;
				toNumber: () => number;
				toBytes: (le?: boolean) => number[];
				toBytesLE: () => number[];
				toBytesBE: () => number[];
				toSigned: () => Long.Long;
				toString: (radix?: number) => string;
				toUnsigned: () => Long.Long;
				xor: (other: string | number | Long.Long) => Long.Long;
			} & Record<Exclude<keyof I["pagination"]["total"], keyof Long.Long>, never>);
		} & Record<Exclude<keyof I["pagination"], keyof PageResponse>, never>;
	} & Record<Exclude<keyof I, keyof QueryRedelegationsResponse>, never>>(object: I): QueryRedelegationsResponse;
};
declare const QueryDelegatorValidatorsRequest: {
	encode(message: QueryDelegatorValidatorsRequest, writer?: _m0.Writer): _m0.Writer;
	decode(input: _m0.Reader | Uint8Array, length?: number): QueryDelegatorValidatorsRequest;
	fromJSON(object: any): QueryDelegatorValidatorsRequest;
	toJSON(message: QueryDelegatorValidatorsRequest): unknown;
	fromPartial<I extends {
		delegatorAddr?: string;
		pagination?: {
			key?: Uint8Array;
			offset?: string | number | Long.Long;
			limit?: string | number | Long.Long;
			countTotal?: boolean;
			reverse?: boolean;
		};
	} & {
		delegatorAddr?: string;
		pagination?: {
			key?: Uint8Array;
			offset?: string | number | Long.Long;
			limit?: string | number | Long.Long;
			countTotal?: boolean;
			reverse?: boolean;
		} & {
			key?: Uint8Array;
			offset?: string | number | (Long.Long & {
				high: number;
				low: number;
				unsigned: boolean;
				add: (addend: string | number | Long.Long) => Long.Long;
				and: (other: string | number | Long.Long) => Long.Long;
				compare: (other: string | number | Long.Long) => number;
				comp: (other: string | number | Long.Long) => number;
				divide: (divisor: string | number | Long.Long) => Long.Long;
				div: (divisor: string | number | Long.Long) => Long.Long;
				equals: (other: string | number | Long.Long) => boolean;
				eq: (other: string | number | Long.Long) => boolean;
				getHighBits: () => number;
				getHighBitsUnsigned: () => number;
				getLowBits: () => number;
				getLowBitsUnsigned: () => number;
				getNumBitsAbs: () => number;
				greaterThan: (other: string | number | Long.Long) => boolean;
				gt: (other: string | number | Long.Long) => boolean;
				greaterThanOrEqual: (other: string | number | Long.Long) => boolean;
				gte: (other: string | number | Long.Long) => boolean;
				isEven: () => boolean;
				isNegative: () => boolean;
				isOdd: () => boolean;
				isPositive: () => boolean;
				isZero: () => boolean;
				lessThan: (other: string | number | Long.Long) => boolean;
				lt: (other: string | number | Long.Long) => boolean;
				lessThanOrEqual: (other: string | number | Long.Long) => boolean;
				lte: (other: string | number | Long.Long) => boolean;
				modulo: (other: string | number | Long.Long) => Long.Long;
				mod: (other: string | number | Long.Long) => Long.Long;
				multiply: (multiplier: string | number | Long.Long) => Long.Long;
				mul: (multiplier: string | number | Long.Long) => Long.Long;
				negate: () => Long.Long;
				neg: () => Long.Long;
				not: () => Long.Long;
				notEquals: (other: string | number | Long.Long) => boolean;
				neq: (other: string | number | Long.Long) => boolean;
				or: (other: string | number | Long.Long) => Long.Long;
				shiftLeft: (numBits: number | Long.Long) => Long.Long;
				shl: (numBits: number | Long.Long) => Long.Long;
				shiftRight: (numBits: number | Long.Long) => Long.Long;
				shr: (numBits: number | Long.Long) => Long.Long;
				shiftRightUnsigned: (numBits: number | Long.Long) => Long.Long;
				shru: (numBits: number | Long.Long) => Long.Long;
				subtract: (subtrahend: string | number | Long.Long) => Long.Long;
				sub: (subtrahend: string | number | Long.Long) => Long.Long;
				toInt: () => number;
				toNumber: () => number;
				toBytes: (le?: boolean) => number[];
				toBytesLE: () => number[];
				toBytesBE: () => number[];
				toSigned: () => Long.Long;
				toString: (radix?: number) => string;
				toUnsigned: () => Long.Long;
				xor: (other: string | number | Long.Long) => Long.Long;
			} & Record<Exclude<keyof I["pagination"]["offset"], keyof Long.Long>, never>);
			limit?: string | number | (Long.Long & {
				high: number;
				low: number;
				unsigned: boolean;
				add: (addend: string | number | Long.Long) => Long.Long;
				and: (other: string | number | Long.Long) => Long.Long;
				compare: (other: string | number | Long.Long) => number;
				comp: (other: string | number | Long.Long) => number;
				divide: (divisor: string | number | Long.Long) => Long.Long;
				div: (divisor: string | number | Long.Long) => Long.Long;
				equals: (other: string | number | Long.Long) => boolean;
				eq: (other: string | number | Long.Long) => boolean;
				getHighBits: () => number;
				getHighBitsUnsigned: () => number;
				getLowBits: () => number;
				getLowBitsUnsigned: () => number;
				getNumBitsAbs: () => number;
				greaterThan: (other: string | number | Long.Long) => boolean;
				gt: (other: string | number | Long.Long) => boolean;
				greaterThanOrEqual: (other: string | number | Long.Long) => boolean;
				gte: (other: string | number | Long.Long) => boolean;
				isEven: () => boolean;
				isNegative: () => boolean;
				isOdd: () => boolean;
				isPositive: () => boolean;
				isZero: () => boolean;
				lessThan: (other: string | number | Long.Long) => boolean;
				lt: (other: string | number | Long.Long) => boolean;
				lessThanOrEqual: (other: string | number | Long.Long) => boolean;
				lte: (other: string | number | Long.Long) => boolean;
				modulo: (other: string | number | Long.Long) => Long.Long;
				mod: (other: string | number | Long.Long) => Long.Long;
				multiply: (multiplier: string | number | Long.Long) => Long.Long;
				mul: (multiplier: string | number | Long.Long) => Long.Long;
				negate: () => Long.Long;
				neg: () => Long.Long;
				not: () => Long.Long;
				notEquals: (other: string | number | Long.Long) => boolean;
				neq: (other: string | number | Long.Long) => boolean;
				or: (other: string | number | Long.Long) => Long.Long;
				shiftLeft: (numBits: number | Long.Long) => Long.Long;
				shl: (numBits: number | Long.Long) => Long.Long;
				shiftRight: (numBits: number | Long.Long) => Long.Long;
				shr: (numBits: number | Long.Long) => Long.Long;
				shiftRightUnsigned: (numBits: number | Long.Long) => Long.Long;
				shru: (numBits: number | Long.Long) => Long.Long;
				subtract: (subtrahend: string | number | Long.Long) => Long.Long;
				sub: (subtrahend: string | number | Long.Long) => Long.Long;
				toInt: () => number;
				toNumber: () => number;
				toBytes: (le?: boolean) => number[];
				toBytesLE: () => number[];
				toBytesBE: () => number[];
				toSigned: () => Long.Long;
				toString: (radix?: number) => string;
				toUnsigned: () => Long.Long;
				xor: (other: string | number | Long.Long) => Long.Long;
			} & Record<Exclude<keyof I["pagination"]["limit"], keyof Long.Long>, never>);
			countTotal?: boolean;
			reverse?: boolean;
		} & Record<Exclude<keyof I["pagination"], keyof PageRequest>, never>;
	} & Record<Exclude<keyof I, keyof QueryDelegatorValidatorsRequest>, never>>(object: I): QueryDelegatorValidatorsRequest;
};
declare const QueryDelegatorValidatorsResponse: {
	encode(message: QueryDelegatorValidatorsResponse, writer?: _m0.Writer): _m0.Writer;
	decode(input: _m0.Reader | Uint8Array, length?: number): QueryDelegatorValidatorsResponse;
	fromJSON(object: any): QueryDelegatorValidatorsResponse;
	toJSON(message: QueryDelegatorValidatorsResponse): unknown;
	fromPartial<I extends {
		validators?: {
			operatorAddress?: string;
			consensusPubkey?: {
				typeUrl?: string;
				value?: Uint8Array;
			};
			jailed?: boolean;
			status?: BondStatus;
			tokens?: string;
			delegatorShares?: string;
			description?: {
				moniker?: string;
				identity?: string;
				website?: string;
				securityContact?: string;
				details?: string;
			};
			unbondingHeight?: string | number | Long.Long;
			unbondingTime?: Date;
			commission?: {
				commissionRates?: {
					rate?: string;
					maxRate?: string;
					maxChangeRate?: string;
				};
				updateTime?: Date;
			};
			minSelfDelegation?: string;
		}[];
		pagination?: {
			nextKey?: Uint8Array;
			total?: string | number | Long.Long;
		};
	} & {
		validators?: {
			operatorAddress?: string;
			consensusPubkey?: {
				typeUrl?: string;
				value?: Uint8Array;
			};
			jailed?: boolean;
			status?: BondStatus;
			tokens?: string;
			delegatorShares?: string;
			description?: {
				moniker?: string;
				identity?: string;
				website?: string;
				securityContact?: string;
				details?: string;
			};
			unbondingHeight?: string | number | Long.Long;
			unbondingTime?: Date;
			commission?: {
				commissionRates?: {
					rate?: string;
					maxRate?: string;
					maxChangeRate?: string;
				};
				updateTime?: Date;
			};
			minSelfDelegation?: string;
		}[] & ({
			operatorAddress?: string;
			consensusPubkey?: {
				typeUrl?: string;
				value?: Uint8Array;
			};
			jailed?: boolean;
			status?: BondStatus;
			tokens?: string;
			delegatorShares?: string;
			description?: {
				moniker?: string;
				identity?: string;
				website?: string;
				securityContact?: string;
				details?: string;
			};
			unbondingHeight?: string | number | Long.Long;
			unbondingTime?: Date;
			commission?: {
				commissionRates?: {
					rate?: string;
					maxRate?: string;
					maxChangeRate?: string;
				};
				updateTime?: Date;
			};
			minSelfDelegation?: string;
		} & {
			operatorAddress?: string;
			consensusPubkey?: {
				typeUrl?: string;
				value?: Uint8Array;
			} & {
				typeUrl?: string;
				value?: Uint8Array;
			} & Record<Exclude<keyof I["validators"][number]["consensusPubkey"], keyof Any>, never>;
			jailed?: boolean;
			status?: BondStatus;
			tokens?: string;
			delegatorShares?: string;
			description?: {
				moniker?: string;
				identity?: string;
				website?: string;
				securityContact?: string;
				details?: string;
			} & {
				moniker?: string;
				identity?: string;
				website?: string;
				securityContact?: string;
				details?: string;
			} & Record<Exclude<keyof I["validators"][number]["description"], keyof Description>, never>;
			unbondingHeight?: string | number | (Long.Long & {
				high: number;
				low: number;
				unsigned: boolean;
				add: (addend: string | number | Long.Long) => Long.Long;
				and: (other: string | number | Long.Long) => Long.Long;
				compare: (other: string | number | Long.Long) => number;
				comp: (other: string | number | Long.Long) => number;
				divide: (divisor: string | number | Long.Long) => Long.Long;
				div: (divisor: string | number | Long.Long) => Long.Long;
				equals: (other: string | number | Long.Long) => boolean;
				eq: (other: string | number | Long.Long) => boolean;
				getHighBits: () => number;
				getHighBitsUnsigned: () => number;
				getLowBits: () => number;
				getLowBitsUnsigned: () => number;
				getNumBitsAbs: () => number;
				greaterThan: (other: string | number | Long.Long) => boolean;
				gt: (other: string | number | Long.Long) => boolean;
				greaterThanOrEqual: (other: string | number | Long.Long) => boolean;
				gte: (other: string | number | Long.Long) => boolean;
				isEven: () => boolean;
				isNegative: () => boolean;
				isOdd: () => boolean;
				isPositive: () => boolean;
				isZero: () => boolean;
				lessThan: (other: string | number | Long.Long) => boolean;
				lt: (other: string | number | Long.Long) => boolean;
				lessThanOrEqual: (other: string | number | Long.Long) => boolean;
				lte: (other: string | number | Long.Long) => boolean;
				modulo: (other: string | number | Long.Long) => Long.Long;
				mod: (other: string | number | Long.Long) => Long.Long;
				multiply: (multiplier: string | number | Long.Long) => Long.Long;
				mul: (multiplier: string | number | Long.Long) => Long.Long;
				negate: () => Long.Long;
				neg: () => Long.Long;
				not: () => Long.Long;
				notEquals: (other: string | number | Long.Long) => boolean;
				neq: (other: string | number | Long.Long) => boolean;
				or: (other: string | number | Long.Long) => Long.Long;
				shiftLeft: (numBits: number | Long.Long) => Long.Long;
				shl: (numBits: number | Long.Long) => Long.Long;
				shiftRight: (numBits: number | Long.Long) => Long.Long;
				shr: (numBits: number | Long.Long) => Long.Long;
				shiftRightUnsigned: (numBits: number | Long.Long) => Long.Long;
				shru: (numBits: number | Long.Long) => Long.Long;
				subtract: (subtrahend: string | number | Long.Long) => Long.Long;
				sub: (subtrahend: string | number | Long.Long) => Long.Long;
				toInt: () => number;
				toNumber: () => number;
				toBytes: (le?: boolean) => number[];
				toBytesLE: () => number[];
				toBytesBE: () => number[];
				toSigned: () => Long.Long;
				toString: (radix?: number) => string;
				toUnsigned: () => Long.Long;
				xor: (other: string | number | Long.Long) => Long.Long;
			} & Record<Exclude<keyof I["validators"][number]["unbondingHeight"], keyof Long.Long>, never>);
			unbondingTime?: Date;
			commission?: {
				commissionRates?: {
					rate?: string;
					maxRate?: string;
					maxChangeRate?: string;
				};
				updateTime?: Date;
			} & {
				commissionRates?: {
					rate?: string;
					maxRate?: string;
					maxChangeRate?: string;
				} & {
					rate?: string;
					maxRate?: string;
					maxChangeRate?: string;
				} & Record<Exclude<keyof I["validators"][number]["commission"]["commissionRates"], keyof CommissionRates>, never>;
				updateTime?: Date;
			} & Record<Exclude<keyof I["validators"][number]["commission"], keyof Commission>, never>;
			minSelfDelegation?: string;
		} & Record<Exclude<keyof I["validators"][number], keyof Validator>, never>)[] & Record<Exclude<keyof I["validators"], keyof {
			operatorAddress?: string;
			consensusPubkey?: {
				typeUrl?: string;
				value?: Uint8Array;
			};
			jailed?: boolean;
			status?: BondStatus;
			tokens?: string;
			delegatorShares?: string;
			description?: {
				moniker?: string;
				identity?: string;
				website?: string;
				securityContact?: string;
				details?: string;
			};
			unbondingHeight?: string | number | Long.Long;
			unbondingTime?: Date;
			commission?: {
				commissionRates?: {
					rate?: string;
					maxRate?: string;
					maxChangeRate?: string;
				};
				updateTime?: Date;
			};
			minSelfDelegation?: string;
		}[]>, never>;
		pagination?: {
			nextKey?: Uint8Array;
			total?: string | number | Long.Long;
		} & {
			nextKey?: Uint8Array;
			total?: string | number | (Long.Long & {
				high: number;
				low: number;
				unsigned: boolean;
				add: (addend: string | number | Long.Long) => Long.Long;
				and: (other: string | number | Long.Long) => Long.Long;
				compare: (other: string | number | Long.Long) => number;
				comp: (other: string | number | Long.Long) => number;
				divide: (divisor: string | number | Long.Long) => Long.Long;
				div: (divisor: string | number | Long.Long) => Long.Long;
				equals: (other: string | number | Long.Long) => boolean;
				eq: (other: string | number | Long.Long) => boolean;
				getHighBits: () => number;
				getHighBitsUnsigned: () => number;
				getLowBits: () => number;
				getLowBitsUnsigned: () => number;
				getNumBitsAbs: () => number;
				greaterThan: (other: string | number | Long.Long) => boolean;
				gt: (other: string | number | Long.Long) => boolean;
				greaterThanOrEqual: (other: string | number | Long.Long) => boolean;
				gte: (other: string | number | Long.Long) => boolean;
				isEven: () => boolean;
				isNegative: () => boolean;
				isOdd: () => boolean;
				isPositive: () => boolean;
				isZero: () => boolean;
				lessThan: (other: string | number | Long.Long) => boolean;
				lt: (other: string | number | Long.Long) => boolean;
				lessThanOrEqual: (other: string | number | Long.Long) => boolean;
				lte: (other: string | number | Long.Long) => boolean;
				modulo: (other: string | number | Long.Long) => Long.Long;
				mod: (other: string | number | Long.Long) => Long.Long;
				multiply: (multiplier: string | number | Long.Long) => Long.Long;
				mul: (multiplier: string | number | Long.Long) => Long.Long;
				negate: () => Long.Long;
				neg: () => Long.Long;
				not: () => Long.Long;
				notEquals: (other: string | number | Long.Long) => boolean;
				neq: (other: string | number | Long.Long) => boolean;
				or: (other: string | number | Long.Long) => Long.Long;
				shiftLeft: (numBits: number | Long.Long) => Long.Long;
				shl: (numBits: number | Long.Long) => Long.Long;
				shiftRight: (numBits: number | Long.Long) => Long.Long;
				shr: (numBits: number | Long.Long) => Long.Long;
				shiftRightUnsigned: (numBits: number | Long.Long) => Long.Long;
				shru: (numBits: number | Long.Long) => Long.Long;
				subtract: (subtrahend: string | number | Long.Long) => Long.Long;
				sub: (subtrahend: string | number | Long.Long) => Long.Long;
				toInt: () => number;
				toNumber: () => number;
				toBytes: (le?: boolean) => number[];
				toBytesLE: () => number[];
				toBytesBE: () => number[];
				toSigned: () => Long.Long;
				toString: (radix?: number) => string;
				toUnsigned: () => Long.Long;
				xor: (other: string | number | Long.Long) => Long.Long;
			} & Record<Exclude<keyof I["pagination"]["total"], keyof Long.Long>, never>);
		} & Record<Exclude<keyof I["pagination"], keyof PageResponse>, never>;
	} & Record<Exclude<keyof I, keyof QueryDelegatorValidatorsResponse>, never>>(object: I): QueryDelegatorValidatorsResponse;
};
declare const QueryDelegatorValidatorRequest: {
	encode(message: QueryDelegatorValidatorRequest, writer?: _m0.Writer): _m0.Writer;
	decode(input: _m0.Reader | Uint8Array, length?: number): QueryDelegatorValidatorRequest;
	fromJSON(object: any): QueryDelegatorValidatorRequest;
	toJSON(message: QueryDelegatorValidatorRequest): unknown;
	fromPartial<I extends {
		delegatorAddr?: string;
		validatorAddr?: string;
	} & {
		delegatorAddr?: string;
		validatorAddr?: string;
	} & Record<Exclude<keyof I, keyof QueryDelegatorValidatorRequest>, never>>(object: I): QueryDelegatorValidatorRequest;
};
declare const QueryDelegatorValidatorResponse: {
	encode(message: QueryDelegatorValidatorResponse, writer?: _m0.Writer): _m0.Writer;
	decode(input: _m0.Reader | Uint8Array, length?: number): QueryDelegatorValidatorResponse;
	fromJSON(object: any): QueryDelegatorValidatorResponse;
	toJSON(message: QueryDelegatorValidatorResponse): unknown;
	fromPartial<I extends {
		validator?: {
			operatorAddress?: string;
			consensusPubkey?: {
				typeUrl?: string;
				value?: Uint8Array;
			};
			jailed?: boolean;
			status?: BondStatus;
			tokens?: string;
			delegatorShares?: string;
			description?: {
				moniker?: string;
				identity?: string;
				website?: string;
				securityContact?: string;
				details?: string;
			};
			unbondingHeight?: string | number | Long.Long;
			unbondingTime?: Date;
			commission?: {
				commissionRates?: {
					rate?: string;
					maxRate?: string;
					maxChangeRate?: string;
				};
				updateTime?: Date;
			};
			minSelfDelegation?: string;
		};
	} & {
		validator?: {
			operatorAddress?: string;
			consensusPubkey?: {
				typeUrl?: string;
				value?: Uint8Array;
			};
			jailed?: boolean;
			status?: BondStatus;
			tokens?: string;
			delegatorShares?: string;
			description?: {
				moniker?: string;
				identity?: string;
				website?: string;
				securityContact?: string;
				details?: string;
			};
			unbondingHeight?: string | number | Long.Long;
			unbondingTime?: Date;
			commission?: {
				commissionRates?: {
					rate?: string;
					maxRate?: string;
					maxChangeRate?: string;
				};
				updateTime?: Date;
			};
			minSelfDelegation?: string;
		} & {
			operatorAddress?: string;
			consensusPubkey?: {
				typeUrl?: string;
				value?: Uint8Array;
			} & {
				typeUrl?: string;
				value?: Uint8Array;
			} & Record<Exclude<keyof I["validator"]["consensusPubkey"], keyof Any>, never>;
			jailed?: boolean;
			status?: BondStatus;
			tokens?: string;
			delegatorShares?: string;
			description?: {
				moniker?: string;
				identity?: string;
				website?: string;
				securityContact?: string;
				details?: string;
			} & {
				moniker?: string;
				identity?: string;
				website?: string;
				securityContact?: string;
				details?: string;
			} & Record<Exclude<keyof I["validator"]["description"], keyof Description>, never>;
			unbondingHeight?: string | number | (Long.Long & {
				high: number;
				low: number;
				unsigned: boolean;
				add: (addend: string | number | Long.Long) => Long.Long;
				and: (other: string | number | Long.Long) => Long.Long;
				compare: (other: string | number | Long.Long) => number;
				comp: (other: string | number | Long.Long) => number;
				divide: (divisor: string | number | Long.Long) => Long.Long;
				div: (divisor: string | number | Long.Long) => Long.Long;
				equals: (other: string | number | Long.Long) => boolean;
				eq: (other: string | number | Long.Long) => boolean;
				getHighBits: () => number;
				getHighBitsUnsigned: () => number;
				getLowBits: () => number;
				getLowBitsUnsigned: () => number;
				getNumBitsAbs: () => number;
				greaterThan: (other: string | number | Long.Long) => boolean;
				gt: (other: string | number | Long.Long) => boolean;
				greaterThanOrEqual: (other: string | number | Long.Long) => boolean;
				gte: (other: string | number | Long.Long) => boolean;
				isEven: () => boolean;
				isNegative: () => boolean;
				isOdd: () => boolean;
				isPositive: () => boolean;
				isZero: () => boolean;
				lessThan: (other: string | number | Long.Long) => boolean;
				lt: (other: string | number | Long.Long) => boolean;
				lessThanOrEqual: (other: string | number | Long.Long) => boolean;
				lte: (other: string | number | Long.Long) => boolean;
				modulo: (other: string | number | Long.Long) => Long.Long;
				mod: (other: string | number | Long.Long) => Long.Long;
				multiply: (multiplier: string | number | Long.Long) => Long.Long;
				mul: (multiplier: string | number | Long.Long) => Long.Long;
				negate: () => Long.Long;
				neg: () => Long.Long;
				not: () => Long.Long;
				notEquals: (other: string | number | Long.Long) => boolean;
				neq: (other: string | number | Long.Long) => boolean;
				or: (other: string | number | Long.Long) => Long.Long;
				shiftLeft: (numBits: number | Long.Long) => Long.Long;
				shl: (numBits: number | Long.Long) => Long.Long;
				shiftRight: (numBits: number | Long.Long) => Long.Long;
				shr: (numBits: number | Long.Long) => Long.Long;
				shiftRightUnsigned: (numBits: number | Long.Long) => Long.Long;
				shru: (numBits: number | Long.Long) => Long.Long;
				subtract: (subtrahend: string | number | Long.Long) => Long.Long;
				sub: (subtrahend: string | number | Long.Long) => Long.Long;
				toInt: () => number;
				toNumber: () => number;
				toBytes: (le?: boolean) => number[];
				toBytesLE: () => number[];
				toBytesBE: () => number[];
				toSigned: () => Long.Long;
				toString: (radix?: number) => string;
				toUnsigned: () => Long.Long;
				xor: (other: string | number | Long.Long) => Long.Long;
			} & Record<Exclude<keyof I["validator"]["unbondingHeight"], keyof Long.Long>, never>);
			unbondingTime?: Date;
			commission?: {
				commissionRates?: {
					rate?: string;
					maxRate?: string;
					maxChangeRate?: string;
				};
				updateTime?: Date;
			} & {
				commissionRates?: {
					rate?: string;
					maxRate?: string;
					maxChangeRate?: string;
				} & {
					rate?: string;
					maxRate?: string;
					maxChangeRate?: string;
				} & Record<Exclude<keyof I["validator"]["commission"]["commissionRates"], keyof CommissionRates>, never>;
				updateTime?: Date;
			} & Record<Exclude<keyof I["validator"]["commission"], keyof Commission>, never>;
			minSelfDelegation?: string;
		} & Record<Exclude<keyof I["validator"], keyof Validator>, never>;
	} & Record<Exclude<keyof I, "validator">, never>>(object: I): QueryDelegatorValidatorResponse;
};
declare const QueryHistoricalInfoRequest: {
	encode(message: QueryHistoricalInfoRequest, writer?: _m0.Writer): _m0.Writer;
	decode(input: _m0.Reader | Uint8Array, length?: number): QueryHistoricalInfoRequest;
	fromJSON(object: any): QueryHistoricalInfoRequest;
	toJSON(message: QueryHistoricalInfoRequest): unknown;
	fromPartial<I extends {
		height?: string | number | Long.Long;
	} & {
		height?: string | number | (Long.Long & {
			high: number;
			low: number;
			unsigned: boolean;
			add: (addend: string | number | Long.Long) => Long.Long;
			and: (other: string | number | Long.Long) => Long.Long;
			compare: (other: string | number | Long.Long) => number;
			comp: (other: string | number | Long.Long) => number;
			divide: (divisor: string | number | Long.Long) => Long.Long;
			div: (divisor: string | number | Long.Long) => Long.Long;
			equals: (other: string | number | Long.Long) => boolean;
			eq: (other: string | number | Long.Long) => boolean;
			getHighBits: () => number;
			getHighBitsUnsigned: () => number;
			getLowBits: () => number;
			getLowBitsUnsigned: () => number;
			getNumBitsAbs: () => number;
			greaterThan: (other: string | number | Long.Long) => boolean;
			gt: (other: string | number | Long.Long) => boolean;
			greaterThanOrEqual: (other: string | number | Long.Long) => boolean;
			gte: (other: string | number | Long.Long) => boolean;
			isEven: () => boolean;
			isNegative: () => boolean;
			isOdd: () => boolean;
			isPositive: () => boolean;
			isZero: () => boolean;
			lessThan: (other: string | number | Long.Long) => boolean;
			lt: (other: string | number | Long.Long) => boolean;
			lessThanOrEqual: (other: string | number | Long.Long) => boolean;
			lte: (other: string | number | Long.Long) => boolean;
			modulo: (other: string | number | Long.Long) => Long.Long;
			mod: (other: string | number | Long.Long) => Long.Long;
			multiply: (multiplier: string | number | Long.Long) => Long.Long;
			mul: (multiplier: string | number | Long.Long) => Long.Long;
			negate: () => Long.Long;
			neg: () => Long.Long;
			not: () => Long.Long;
			notEquals: (other: string | number | Long.Long) => boolean;
			neq: (other: string | number | Long.Long) => boolean;
			or: (other: string | number | Long.Long) => Long.Long;
			shiftLeft: (numBits: number | Long.Long) => Long.Long;
			shl: (numBits: number | Long.Long) => Long.Long;
			shiftRight: (numBits: number | Long.Long) => Long.Long;
			shr: (numBits: number | Long.Long) => Long.Long;
			shiftRightUnsigned: (numBits: number | Long.Long) => Long.Long;
			shru: (numBits: number | Long.Long) => Long.Long;
			subtract: (subtrahend: string | number | Long.Long) => Long.Long;
			sub: (subtrahend: string | number | Long.Long) => Long.Long;
			toInt: () => number;
			toNumber: () => number;
			toBytes: (le?: boolean) => number[];
			toBytesLE: () => number[];
			toBytesBE: () => number[];
			toSigned: () => Long.Long;
			toString: (radix?: number) => string;
			toUnsigned: () => Long.Long;
			xor: (other: string | number | Long.Long) => Long.Long;
		} & Record<Exclude<keyof I["height"], keyof Long.Long>, never>);
	} & Record<Exclude<keyof I, "height">, never>>(object: I): QueryHistoricalInfoRequest;
};
declare const QueryHistoricalInfoResponse: {
	encode(message: QueryHistoricalInfoResponse, writer?: _m0.Writer): _m0.Writer;
	decode(input: _m0.Reader | Uint8Array, length?: number): QueryHistoricalInfoResponse;
	fromJSON(object: any): QueryHistoricalInfoResponse;
	toJSON(message: QueryHistoricalInfoResponse): unknown;
	fromPartial<I extends {
		hist?: {
			header?: {
				version?: {
					block?: string | number | Long.Long;
					app?: string | number | Long.Long;
				};
				chainId?: string;
				height?: string | number | Long.Long;
				time?: Date;
				lastBlockId?: {
					hash?: Uint8Array;
					partSetHeader?: {
						total?: number;
						hash?: Uint8Array;
					};
				};
				lastCommitHash?: Uint8Array;
				dataHash?: Uint8Array;
				validatorsHash?: Uint8Array;
				nextValidatorsHash?: Uint8Array;
				consensusHash?: Uint8Array;
				appHash?: Uint8Array;
				lastResultsHash?: Uint8Array;
				evidenceHash?: Uint8Array;
				proposerAddress?: Uint8Array;
			};
			valset?: {
				operatorAddress?: string;
				consensusPubkey?: {
					typeUrl?: string;
					value?: Uint8Array;
				};
				jailed?: boolean;
				status?: BondStatus;
				tokens?: string;
				delegatorShares?: string;
				description?: {
					moniker?: string;
					identity?: string;
					website?: string;
					securityContact?: string;
					details?: string;
				};
				unbondingHeight?: string | number | Long.Long;
				unbondingTime?: Date;
				commission?: {
					commissionRates?: {
						rate?: string;
						maxRate?: string;
						maxChangeRate?: string;
					};
					updateTime?: Date;
				};
				minSelfDelegation?: string;
			}[];
		};
	} & {
		hist?: {
			header?: {
				version?: {
					block?: string | number | Long.Long;
					app?: string | number | Long.Long;
				};
				chainId?: string;
				height?: string | number | Long.Long;
				time?: Date;
				lastBlockId?: {
					hash?: Uint8Array;
					partSetHeader?: {
						total?: number;
						hash?: Uint8Array;
					};
				};
				lastCommitHash?: Uint8Array;
				dataHash?: Uint8Array;
				validatorsHash?: Uint8Array;
				nextValidatorsHash?: Uint8Array;
				consensusHash?: Uint8Array;
				appHash?: Uint8Array;
				lastResultsHash?: Uint8Array;
				evidenceHash?: Uint8Array;
				proposerAddress?: Uint8Array;
			};
			valset?: {
				operatorAddress?: string;
				consensusPubkey?: {
					typeUrl?: string;
					value?: Uint8Array;
				};
				jailed?: boolean;
				status?: BondStatus;
				tokens?: string;
				delegatorShares?: string;
				description?: {
					moniker?: string;
					identity?: string;
					website?: string;
					securityContact?: string;
					details?: string;
				};
				unbondingHeight?: string | number | Long.Long;
				unbondingTime?: Date;
				commission?: {
					commissionRates?: {
						rate?: string;
						maxRate?: string;
						maxChangeRate?: string;
					};
					updateTime?: Date;
				};
				minSelfDelegation?: string;
			}[];
		} & {
			header?: {
				version?: {
					block?: string | number | Long.Long;
					app?: string | number | Long.Long;
				};
				chainId?: string;
				height?: string | number | Long.Long;
				time?: Date;
				lastBlockId?: {
					hash?: Uint8Array;
					partSetHeader?: {
						total?: number;
						hash?: Uint8Array;
					};
				};
				lastCommitHash?: Uint8Array;
				dataHash?: Uint8Array;
				validatorsHash?: Uint8Array;
				nextValidatorsHash?: Uint8Array;
				consensusHash?: Uint8Array;
				appHash?: Uint8Array;
				lastResultsHash?: Uint8Array;
				evidenceHash?: Uint8Array;
				proposerAddress?: Uint8Array;
			} & {
				version?: {
					block?: string | number | Long.Long;
					app?: string | number | Long.Long;
				} & {
					block?: string | number | (Long.Long & {
						high: number;
						low: number;
						unsigned: boolean;
						add: (addend: string | number | Long.Long) => Long.Long;
						and: (other: string | number | Long.Long) => Long.Long;
						compare: (other: string | number | Long.Long) => number;
						comp: (other: string | number | Long.Long) => number;
						divide: (divisor: string | number | Long.Long) => Long.Long;
						div: (divisor: string | number | Long.Long) => Long.Long;
						equals: (other: string | number | Long.Long) => boolean;
						eq: (other: string | number | Long.Long) => boolean;
						getHighBits: () => number;
						getHighBitsUnsigned: () => number;
						getLowBits: () => number;
						getLowBitsUnsigned: () => number;
						getNumBitsAbs: () => number;
						greaterThan: (other: string | number | Long.Long) => boolean;
						gt: (other: string | number | Long.Long) => boolean;
						greaterThanOrEqual: (other: string | number | Long.Long) => boolean;
						gte: (other: string | number | Long.Long) => boolean;
						isEven: () => boolean;
						isNegative: () => boolean;
						isOdd: () => boolean;
						isPositive: () => boolean;
						isZero: () => boolean;
						lessThan: (other: string | number | Long.Long) => boolean;
						lt: (other: string | number | Long.Long) => boolean;
						lessThanOrEqual: (other: string | number | Long.Long) => boolean;
						lte: (other: string | number | Long.Long) => boolean;
						modulo: (other: string | number | Long.Long) => Long.Long;
						mod: (other: string | number | Long.Long) => Long.Long;
						multiply: (multiplier: string | number | Long.Long) => Long.Long;
						mul: (multiplier: string | number | Long.Long) => Long.Long;
						negate: () => Long.Long;
						neg: () => Long.Long;
						not: () => Long.Long;
						notEquals: (other: string | number | Long.Long) => boolean;
						neq: (other: string | number | Long.Long) => boolean;
						or: (other: string | number | Long.Long) => Long.Long;
						shiftLeft: (numBits: number | Long.Long) => Long.Long;
						shl: (numBits: number | Long.Long) => Long.Long;
						shiftRight: (numBits: number | Long.Long) => Long.Long;
						shr: (numBits: number | Long.Long) => Long.Long;
						shiftRightUnsigned: (numBits: number | Long.Long) => Long.Long;
						shru: (numBits: number | Long.Long) => Long.Long;
						subtract: (subtrahend: string | number | Long.Long) => Long.Long;
						sub: (subtrahend: string | number | Long.Long) => Long.Long;
						toInt: () => number;
						toNumber: () => number;
						toBytes: (le?: boolean) => number[];
						toBytesLE: () => number[];
						toBytesBE: () => number[];
						toSigned: () => Long.Long;
						toString: (radix?: number) => string;
						toUnsigned: () => Long.Long;
						xor: (other: string | number | Long.Long) => Long.Long;
					} & Record<Exclude<keyof I["hist"]["header"]["version"]["block"], keyof Long.Long>, never>);
					app?: string | number | (Long.Long & {
						high: number;
						low: number;
						unsigned: boolean;
						add: (addend: string | number | Long.Long) => Long.Long;
						and: (other: string | number | Long.Long) => Long.Long;
						compare: (other: string | number | Long.Long) => number;
						comp: (other: string | number | Long.Long) => number;
						divide: (divisor: string | number | Long.Long) => Long.Long;
						div: (divisor: string | number | Long.Long) => Long.Long;
						equals: (other: string | number | Long.Long) => boolean;
						eq: (other: string | number | Long.Long) => boolean;
						getHighBits: () => number;
						getHighBitsUnsigned: () => number;
						getLowBits: () => number;
						getLowBitsUnsigned: () => number;
						getNumBitsAbs: () => number;
						greaterThan: (other: string | number | Long.Long) => boolean;
						gt: (other: string | number | Long.Long) => boolean;
						greaterThanOrEqual: (other: string | number | Long.Long) => boolean;
						gte: (other: string | number | Long.Long) => boolean;
						isEven: () => boolean;
						isNegative: () => boolean;
						isOdd: () => boolean;
						isPositive: () => boolean;
						isZero: () => boolean;
						lessThan: (other: string | number | Long.Long) => boolean;
						lt: (other: string | number | Long.Long) => boolean;
						lessThanOrEqual: (other: string | number | Long.Long) => boolean;
						lte: (other: string | number | Long.Long) => boolean;
						modulo: (other: string | number | Long.Long) => Long.Long;
						mod: (other: string | number | Long.Long) => Long.Long;
						multiply: (multiplier: string | number | Long.Long) => Long.Long;
						mul: (multiplier: string | number | Long.Long) => Long.Long;
						negate: () => Long.Long;
						neg: () => Long.Long;
						not: () => Long.Long;
						notEquals: (other: string | number | Long.Long) => boolean;
						neq: (other: string | number | Long.Long) => boolean;
						or: (other: string | number | Long.Long) => Long.Long;
						shiftLeft: (numBits: number | Long.Long) => Long.Long;
						shl: (numBits: number | Long.Long) => Long.Long;
						shiftRight: (numBits: number | Long.Long) => Long.Long;
						shr: (numBits: number | Long.Long) => Long.Long;
						shiftRightUnsigned: (numBits: number | Long.Long) => Long.Long;
						shru: (numBits: number | Long.Long) => Long.Long;
						subtract: (subtrahend: string | number | Long.Long) => Long.Long;
						sub: (subtrahend: string | number | Long.Long) => Long.Long;
						toInt: () => number;
						toNumber: () => number;
						toBytes: (le?: boolean) => number[];
						toBytesLE: () => number[];
						toBytesBE: () => number[];
						toSigned: () => Long.Long;
						toString: (radix?: number) => string;
						toUnsigned: () => Long.Long;
						xor: (other: string | number | Long.Long) => Long.Long;
					} & Record<Exclude<keyof I["hist"]["header"]["version"]["app"], keyof Long.Long>, never>);
				} & Record<Exclude<keyof I["hist"]["header"]["version"], keyof Consensus>, never>;
				chainId?: string;
				height?: string | number | (Long.Long & {
					high: number;
					low: number;
					unsigned: boolean;
					add: (addend: string | number | Long.Long) => Long.Long;
					and: (other: string | number | Long.Long) => Long.Long;
					compare: (other: string | number | Long.Long) => number;
					comp: (other: string | number | Long.Long) => number;
					divide: (divisor: string | number | Long.Long) => Long.Long;
					div: (divisor: string | number | Long.Long) => Long.Long;
					equals: (other: string | number | Long.Long) => boolean;
					eq: (other: string | number | Long.Long) => boolean;
					getHighBits: () => number;
					getHighBitsUnsigned: () => number;
					getLowBits: () => number;
					getLowBitsUnsigned: () => number;
					getNumBitsAbs: () => number;
					greaterThan: (other: string | number | Long.Long) => boolean;
					gt: (other: string | number | Long.Long) => boolean;
					greaterThanOrEqual: (other: string | number | Long.Long) => boolean;
					gte: (other: string | number | Long.Long) => boolean;
					isEven: () => boolean;
					isNegative: () => boolean;
					isOdd: () => boolean;
					isPositive: () => boolean;
					isZero: () => boolean;
					lessThan: (other: string | number | Long.Long) => boolean;
					lt: (other: string | number | Long.Long) => boolean;
					lessThanOrEqual: (other: string | number | Long.Long) => boolean;
					lte: (other: string | number | Long.Long) => boolean;
					modulo: (other: string | number | Long.Long) => Long.Long;
					mod: (other: string | number | Long.Long) => Long.Long;
					multiply: (multiplier: string | number | Long.Long) => Long.Long;
					mul: (multiplier: string | number | Long.Long) => Long.Long;
					negate: () => Long.Long;
					neg: () => Long.Long;
					not: () => Long.Long;
					notEquals: (other: string | number | Long.Long) => boolean;
					neq: (other: string | number | Long.Long) => boolean;
					or: (other: string | number | Long.Long) => Long.Long;
					shiftLeft: (numBits: number | Long.Long) => Long.Long;
					shl: (numBits: number | Long.Long) => Long.Long;
					shiftRight: (numBits: number | Long.Long) => Long.Long;
					shr: (numBits: number | Long.Long) => Long.Long;
					shiftRightUnsigned: (numBits: number | Long.Long) => Long.Long;
					shru: (numBits: number | Long.Long) => Long.Long;
					subtract: (subtrahend: string | number | Long.Long) => Long.Long;
					sub: (subtrahend: string | number | Long.Long) => Long.Long;
					toInt: () => number;
					toNumber: () => number;
					toBytes: (le?: boolean) => number[];
					toBytesLE: () => number[];
					toBytesBE: () => number[];
					toSigned: () => Long.Long;
					toString: (radix?: number) => string;
					toUnsigned: () => Long.Long;
					xor: (other: string | number | Long.Long) => Long.Long;
				} & Record<Exclude<keyof I["hist"]["header"]["height"], keyof Long.Long>, never>);
				time?: Date;
				lastBlockId?: {
					hash?: Uint8Array;
					partSetHeader?: {
						total?: number;
						hash?: Uint8Array;
					};
				} & {
					hash?: Uint8Array;
					partSetHeader?: {
						total?: number;
						hash?: Uint8Array;
					} & {
						total?: number;
						hash?: Uint8Array;
					} & Record<Exclude<keyof I["hist"]["header"]["lastBlockId"]["partSetHeader"], keyof PartSetHeader>, never>;
				} & Record<Exclude<keyof I["hist"]["header"]["lastBlockId"], keyof BlockID>, never>;
				lastCommitHash?: Uint8Array;
				dataHash?: Uint8Array;
				validatorsHash?: Uint8Array;
				nextValidatorsHash?: Uint8Array;
				consensusHash?: Uint8Array;
				appHash?: Uint8Array;
				lastResultsHash?: Uint8Array;
				evidenceHash?: Uint8Array;
				proposerAddress?: Uint8Array;
			} & Record<Exclude<keyof I["hist"]["header"], keyof Header>, never>;
			valset?: {
				operatorAddress?: string;
				consensusPubkey?: {
					typeUrl?: string;
					value?: Uint8Array;
				};
				jailed?: boolean;
				status?: BondStatus;
				tokens?: string;
				delegatorShares?: string;
				description?: {
					moniker?: string;
					identity?: string;
					website?: string;
					securityContact?: string;
					details?: string;
				};
				unbondingHeight?: string | number | Long.Long;
				unbondingTime?: Date;
				commission?: {
					commissionRates?: {
						rate?: string;
						maxRate?: string;
						maxChangeRate?: string;
					};
					updateTime?: Date;
				};
				minSelfDelegation?: string;
			}[] & ({
				operatorAddress?: string;
				consensusPubkey?: {
					typeUrl?: string;
					value?: Uint8Array;
				};
				jailed?: boolean;
				status?: BondStatus;
				tokens?: string;
				delegatorShares?: string;
				description?: {
					moniker?: string;
					identity?: string;
					website?: string;
					securityContact?: string;
					details?: string;
				};
				unbondingHeight?: string | number | Long.Long;
				unbondingTime?: Date;
				commission?: {
					commissionRates?: {
						rate?: string;
						maxRate?: string;
						maxChangeRate?: string;
					};
					updateTime?: Date;
				};
				minSelfDelegation?: string;
			} & {
				operatorAddress?: string;
				consensusPubkey?: {
					typeUrl?: string;
					value?: Uint8Array;
				} & {
					typeUrl?: string;
					value?: Uint8Array;
				} & Record<Exclude<keyof I["hist"]["valset"][number]["consensusPubkey"], keyof Any>, never>;
				jailed?: boolean;
				status?: BondStatus;
				tokens?: string;
				delegatorShares?: string;
				description?: {
					moniker?: string;
					identity?: string;
					website?: string;
					securityContact?: string;
					details?: string;
				} & {
					moniker?: string;
					identity?: string;
					website?: string;
					securityContact?: string;
					details?: string;
				} & Record<Exclude<keyof I["hist"]["valset"][number]["description"], keyof Description>, never>;
				unbondingHeight?: string | number | (Long.Long & {
					high: number;
					low: number;
					unsigned: boolean;
					add: (addend: string | number | Long.Long) => Long.Long;
					and: (other: string | number | Long.Long) => Long.Long;
					compare: (other: string | number | Long.Long) => number;
					comp: (other: string | number | Long.Long) => number;
					divide: (divisor: string | number | Long.Long) => Long.Long;
					div: (divisor: string | number | Long.Long) => Long.Long;
					equals: (other: string | number | Long.Long) => boolean;
					eq: (other: string | number | Long.Long) => boolean;
					getHighBits: () => number;
					getHighBitsUnsigned: () => number;
					getLowBits: () => number;
					getLowBitsUnsigned: () => number;
					getNumBitsAbs: () => number;
					greaterThan: (other: string | number | Long.Long) => boolean;
					gt: (other: string | number | Long.Long) => boolean;
					greaterThanOrEqual: (other: string | number | Long.Long) => boolean;
					gte: (other: string | number | Long.Long) => boolean;
					isEven: () => boolean;
					isNegative: () => boolean;
					isOdd: () => boolean;
					isPositive: () => boolean;
					isZero: () => boolean;
					lessThan: (other: string | number | Long.Long) => boolean;
					lt: (other: string | number | Long.Long) => boolean;
					lessThanOrEqual: (other: string | number | Long.Long) => boolean;
					lte: (other: string | number | Long.Long) => boolean;
					modulo: (other: string | number | Long.Long) => Long.Long;
					mod: (other: string | number | Long.Long) => Long.Long;
					multiply: (multiplier: string | number | Long.Long) => Long.Long;
					mul: (multiplier: string | number | Long.Long) => Long.Long;
					negate: () => Long.Long;
					neg: () => Long.Long;
					not: () => Long.Long;
					notEquals: (other: string | number | Long.Long) => boolean;
					neq: (other: string | number | Long.Long) => boolean;
					or: (other: string | number | Long.Long) => Long.Long;
					shiftLeft: (numBits: number | Long.Long) => Long.Long;
					shl: (numBits: number | Long.Long) => Long.Long;
					shiftRight: (numBits: number | Long.Long) => Long.Long;
					shr: (numBits: number | Long.Long) => Long.Long;
					shiftRightUnsigned: (numBits: number | Long.Long) => Long.Long;
					shru: (numBits: number | Long.Long) => Long.Long;
					subtract: (subtrahend: string | number | Long.Long) => Long.Long;
					sub: (subtrahend: string | number | Long.Long) => Long.Long;
					toInt: () => number;
					toNumber: () => number;
					toBytes: (le?: boolean) => number[];
					toBytesLE: () => number[];
					toBytesBE: () => number[];
					toSigned: () => Long.Long;
					toString: (radix?: number) => string;
					toUnsigned: () => Long.Long;
					xor: (other: string | number | Long.Long) => Long.Long;
				} & Record<Exclude<keyof I["hist"]["valset"][number]["unbondingHeight"], keyof Long.Long>, never>);
				unbondingTime?: Date;
				commission?: {
					commissionRates?: {
						rate?: string;
						maxRate?: string;
						maxChangeRate?: string;
					};
					updateTime?: Date;
				} & {
					commissionRates?: {
						rate?: string;
						maxRate?: string;
						maxChangeRate?: string;
					} & {
						rate?: string;
						maxRate?: string;
						maxChangeRate?: string;
					} & Record<Exclude<keyof I["hist"]["valset"][number]["commission"]["commissionRates"], keyof CommissionRates>, never>;
					updateTime?: Date;
				} & Record<Exclude<keyof I["hist"]["valset"][number]["commission"], keyof Commission>, never>;
				minSelfDelegation?: string;
			} & Record<Exclude<keyof I["hist"]["valset"][number], keyof Validator>, never>)[] & Record<Exclude<keyof I["hist"]["valset"], keyof {
				operatorAddress?: string;
				consensusPubkey?: {
					typeUrl?: string;
					value?: Uint8Array;
				};
				jailed?: boolean;
				status?: BondStatus;
				tokens?: string;
				delegatorShares?: string;
				description?: {
					moniker?: string;
					identity?: string;
					website?: string;
					securityContact?: string;
					details?: string;
				};
				unbondingHeight?: string | number | Long.Long;
				unbondingTime?: Date;
				commission?: {
					commissionRates?: {
						rate?: string;
						maxRate?: string;
						maxChangeRate?: string;
					};
					updateTime?: Date;
				};
				minSelfDelegation?: string;
			}[]>, never>;
		} & Record<Exclude<keyof I["hist"], keyof HistoricalInfo>, never>;
	} & Record<Exclude<keyof I, "hist">, never>>(object: I): QueryHistoricalInfoResponse;
};
declare const QueryPoolRequest: {
	encode(_: QueryPoolRequest, writer?: _m0.Writer): _m0.Writer;
	decode(input: _m0.Reader | Uint8Array, length?: number): QueryPoolRequest;
	fromJSON(_: any): QueryPoolRequest;
	toJSON(_: QueryPoolRequest): unknown;
	fromPartial<I extends {} & {} & Record<Exclude<keyof I, never>, never>>(_: I): QueryPoolRequest;
};
declare const QueryPoolResponse: {
	encode(message: QueryPoolResponse, writer?: _m0.Writer): _m0.Writer;
	decode(input: _m0.Reader | Uint8Array, length?: number): QueryPoolResponse;
	fromJSON(object: any): QueryPoolResponse;
	toJSON(message: QueryPoolResponse): unknown;
	fromPartial<I extends {
		pool?: {
			notBondedTokens?: string;
			bondedTokens?: string;
		};
	} & {
		pool?: {
			notBondedTokens?: string;
			bondedTokens?: string;
		} & {
			notBondedTokens?: string;
			bondedTokens?: string;
		} & Record<Exclude<keyof I["pool"], keyof Pool>, never>;
	} & Record<Exclude<keyof I, "pool">, never>>(object: I): QueryPoolResponse;
};
declare const QueryParamsRequest: {
	encode(_: QueryParamsRequest, writer?: _m0.Writer): _m0.Writer;
	decode(input: _m0.Reader | Uint8Array, length?: number): QueryParamsRequest;
	fromJSON(_: any): QueryParamsRequest;
	toJSON(_: QueryParamsRequest): unknown;
	fromPartial<I extends {} & {} & Record<Exclude<keyof I, never>, never>>(_: I): QueryParamsRequest;
};
declare const QueryParamsResponse: {
	encode(message: QueryParamsResponse, writer?: _m0.Writer): _m0.Writer;
	decode(input: _m0.Reader | Uint8Array, length?: number): QueryParamsResponse;
	fromJSON(object: any): QueryParamsResponse;
	toJSON(message: QueryParamsResponse): unknown;
	fromPartial<I extends {
		params?: {
			unbondingTime?: {
				seconds?: string | number | Long.Long;
				nanos?: number;
			};
			maxValidators?: number;
			maxEntries?: number;
			historicalEntries?: number;
			bondDenom?: string;
		};
	} & {
		params?: {
			unbondingTime?: {
				seconds?: string | number | Long.Long;
				nanos?: number;
			};
			maxValidators?: number;
			maxEntries?: number;
			historicalEntries?: number;
			bondDenom?: string;
		} & {
			unbondingTime?: {
				seconds?: string | number | Long.Long;
				nanos?: number;
			} & {
				seconds?: string | number | (Long.Long & {
					high: number;
					low: number;
					unsigned: boolean;
					add: (addend: string | number | Long.Long) => Long.Long;
					and: (other: string | number | Long.Long) => Long.Long;
					compare: (other: string | number | Long.Long) => number;
					comp: (other: string | number | Long.Long) => number;
					divide: (divisor: string | number | Long.Long) => Long.Long;
					div: (divisor: string | number | Long.Long) => Long.Long;
					equals: (other: string | number | Long.Long) => boolean;
					eq: (other: string | number | Long.Long) => boolean;
					getHighBits: () => number;
					getHighBitsUnsigned: () => number;
					getLowBits: () => number;
					getLowBitsUnsigned: () => number;
					getNumBitsAbs: () => number;
					greaterThan: (other: string | number | Long.Long) => boolean;
					gt: (other: string | number | Long.Long) => boolean;
					greaterThanOrEqual: (other: string | number | Long.Long) => boolean;
					gte: (other: string | number | Long.Long) => boolean;
					isEven: () => boolean;
					isNegative: () => boolean;
					isOdd: () => boolean;
					isPositive: () => boolean;
					isZero: () => boolean;
					lessThan: (other: string | number | Long.Long) => boolean;
					lt: (other: string | number | Long.Long) => boolean;
					lessThanOrEqual: (other: string | number | Long.Long) => boolean;
					lte: (other: string | number | Long.Long) => boolean;
					modulo: (other: string | number | Long.Long) => Long.Long;
					mod: (other: string | number | Long.Long) => Long.Long;
					multiply: (multiplier: string | number | Long.Long) => Long.Long;
					mul: (multiplier: string | number | Long.Long) => Long.Long;
					negate: () => Long.Long;
					neg: () => Long.Long;
					not: () => Long.Long;
					notEquals: (other: string | number | Long.Long) => boolean;
					neq: (other: string | number | Long.Long) => boolean;
					or: (other: string | number | Long.Long) => Long.Long;
					shiftLeft: (numBits: number | Long.Long) => Long.Long;
					shl: (numBits: number | Long.Long) => Long.Long;
					shiftRight: (numBits: number | Long.Long) => Long.Long;
					shr: (numBits: number | Long.Long) => Long.Long;
					shiftRightUnsigned: (numBits: number | Long.Long) => Long.Long;
					shru: (numBits: number | Long.Long) => Long.Long;
					subtract: (subtrahend: string | number | Long.Long) => Long.Long;
					sub: (subtrahend: string | number | Long.Long) => Long.Long;
					toInt: () => number;
					toNumber: () => number;
					toBytes: (le?: boolean) => number[];
					toBytesLE: () => number[];
					toBytesBE: () => number[];
					toSigned: () => Long.Long;
					toString: (radix?: number) => string;
					toUnsigned: () => Long.Long;
					xor: (other: string | number | Long.Long) => Long.Long;
				} & Record<Exclude<keyof I["params"]["unbondingTime"]["seconds"], keyof Long.Long>, never>);
				nanos?: number;
			} & Record<Exclude<keyof I["params"]["unbondingTime"], keyof Duration>, never>;
			maxValidators?: number;
			maxEntries?: number;
			historicalEntries?: number;
			bondDenom?: string;
		} & Record<Exclude<keyof I["params"], keyof Params>, never>;
	} & Record<Exclude<keyof I, "params">, never>>(object: I): QueryParamsResponse;
};
/** Query defines the gRPC querier service. */
export interface Query {
	/** Validators queries all validators that match the given status. */
	Validators(request: QueryValidatorsRequest): Promise<QueryValidatorsResponse>;
	/** Validator queries validator info for given validator address. */
	Validator(request: QueryValidatorRequest): Promise<QueryValidatorResponse>;
	/** ValidatorDelegations queries delegate info for given validator. */
	ValidatorDelegations(request: QueryValidatorDelegationsRequest): Promise<QueryValidatorDelegationsResponse>;
	/** ValidatorUnbondingDelegations queries unbonding delegations of a validator. */
	ValidatorUnbondingDelegations(request: QueryValidatorUnbondingDelegationsRequest): Promise<QueryValidatorUnbondingDelegationsResponse>;
	/** Delegation queries delegate info for given validator delegator pair. */
	Delegation(request: QueryDelegationRequest): Promise<QueryDelegationResponse>;
	/**
	 * UnbondingDelegation queries unbonding info for given validator delegator
	 * pair.
	 */
	UnbondingDelegation(request: QueryUnbondingDelegationRequest): Promise<QueryUnbondingDelegationResponse>;
	/** DelegatorDelegations queries all delegations of a given delegator address. */
	DelegatorDelegations(request: QueryDelegatorDelegationsRequest): Promise<QueryDelegatorDelegationsResponse>;
	/**
	 * DelegatorUnbondingDelegations queries all unbonding delegations of a given
	 * delegator address.
	 */
	DelegatorUnbondingDelegations(request: QueryDelegatorUnbondingDelegationsRequest): Promise<QueryDelegatorUnbondingDelegationsResponse>;
	/** Redelegations queries redelegations of given address. */
	Redelegations(request: QueryRedelegationsRequest): Promise<QueryRedelegationsResponse>;
	/**
	 * DelegatorValidators queries all validators info for given delegator
	 * address.
	 */
	DelegatorValidators(request: QueryDelegatorValidatorsRequest): Promise<QueryDelegatorValidatorsResponse>;
	/**
	 * DelegatorValidator queries validator info for given delegator validator
	 * pair.
	 */
	DelegatorValidator(request: QueryDelegatorValidatorRequest): Promise<QueryDelegatorValidatorResponse>;
	/** HistoricalInfo queries the historical info for given height. */
	HistoricalInfo(request: QueryHistoricalInfoRequest): Promise<QueryHistoricalInfoResponse>;
	/** Pool queries the pool info. */
	Pool(request: QueryPoolRequest): Promise<QueryPoolResponse>;
	/** Parameters queries the staking parameters. */
	Params(request: QueryParamsRequest): Promise<QueryParamsResponse>;
}
declare class QueryClientImpl implements Query {
	private readonly rpc;
	constructor(rpc: Rpc);
	Validators(request: QueryValidatorsRequest): Promise<QueryValidatorsResponse>;
	Validator(request: QueryValidatorRequest): Promise<QueryValidatorResponse>;
	ValidatorDelegations(request: QueryValidatorDelegationsRequest): Promise<QueryValidatorDelegationsResponse>;
	ValidatorUnbondingDelegations(request: QueryValidatorUnbondingDelegationsRequest): Promise<QueryValidatorUnbondingDelegationsResponse>;
	Delegation(request: QueryDelegationRequest): Promise<QueryDelegationResponse>;
	UnbondingDelegation(request: QueryUnbondingDelegationRequest): Promise<QueryUnbondingDelegationResponse>;
	DelegatorDelegations(request: QueryDelegatorDelegationsRequest): Promise<QueryDelegatorDelegationsResponse>;
	DelegatorUnbondingDelegations(request: QueryDelegatorUnbondingDelegationsRequest): Promise<QueryDelegatorUnbondingDelegationsResponse>;
	Redelegations(request: QueryRedelegationsRequest): Promise<QueryRedelegationsResponse>;
	DelegatorValidators(request: QueryDelegatorValidatorsRequest): Promise<QueryDelegatorValidatorsResponse>;
	DelegatorValidator(request: QueryDelegatorValidatorRequest): Promise<QueryDelegatorValidatorResponse>;
	HistoricalInfo(request: QueryHistoricalInfoRequest): Promise<QueryHistoricalInfoResponse>;
	Pool(request: QueryPoolRequest): Promise<QueryPoolResponse>;
	Params(request: QueryParamsRequest): Promise<QueryParamsResponse>;
}
export interface Rpc {
	request(service: string, method: string, data: Uint8Array): Promise<Uint8Array>;
}
/** Params defines the set of params for the distribution module. */
export interface Params {
	communityTax: string;
	baseProposerReward: string;
	bonusProposerReward: string;
	withdrawAddrEnabled: boolean;
}
/**
 * ValidatorAccumulatedCommission represents accumulated commission
 * for a validator kept as a running counter, can be withdrawn at any time.
 */
export interface ValidatorAccumulatedCommission {
	commission: DecCoin[];
}
/**
 * ValidatorOutstandingRewards represents outstanding (un-withdrawn) rewards
 * for a validator inexpensive to track, allows simple sanity checks.
 */
export interface ValidatorOutstandingRewards {
	rewards: DecCoin[];
}
/**
 * ValidatorSlashEvent represents a validator slash event.
 * Height is implicit within the store key.
 * This is needed to calculate appropriate amount of staking tokens
 * for delegations which are withdrawn after a slash has occurred.
 */
export interface ValidatorSlashEvent {
	validatorPeriod: Long;
	fraction: string;
}
/**
 * DelegationDelegatorReward represents the properties
 * of a delegator's delegation reward.
 */
export interface DelegationDelegatorReward {
	validatorAddress: string;
	reward: DecCoin[];
}
declare const Params: {
	encode(message: Params, writer?: _m0.Writer): _m0.Writer;
	decode(input: _m0.Reader | Uint8Array, length?: number): Params;
	fromJSON(object: any): Params;
	toJSON(message: Params): unknown;
	fromPartial<I extends {
		communityTax?: string;
		baseProposerReward?: string;
		bonusProposerReward?: string;
		withdrawAddrEnabled?: boolean;
	} & {
		communityTax?: string;
		baseProposerReward?: string;
		bonusProposerReward?: string;
		withdrawAddrEnabled?: boolean;
	} & Record<Exclude<keyof I, keyof Params>, never>>(object: I): Params;
};
declare const ValidatorAccumulatedCommission: {
	encode(message: ValidatorAccumulatedCommission, writer?: _m0.Writer): _m0.Writer;
	decode(input: _m0.Reader | Uint8Array, length?: number): ValidatorAccumulatedCommission;
	fromJSON(object: any): ValidatorAccumulatedCommission;
	toJSON(message: ValidatorAccumulatedCommission): unknown;
	fromPartial<I extends {
		commission?: {
			denom?: string;
			amount?: string;
		}[];
	} & {
		commission?: {
			denom?: string;
			amount?: string;
		}[] & ({
			denom?: string;
			amount?: string;
		} & {
			denom?: string;
			amount?: string;
		} & Record<Exclude<keyof I["commission"][number], keyof DecCoin>, never>)[] & Record<Exclude<keyof I["commission"], keyof {
			denom?: string;
			amount?: string;
		}[]>, never>;
	} & Record<Exclude<keyof I, "commission">, never>>(object: I): ValidatorAccumulatedCommission;
};
declare const ValidatorOutstandingRewards: {
	encode(message: ValidatorOutstandingRewards, writer?: _m0.Writer): _m0.Writer;
	decode(input: _m0.Reader | Uint8Array, length?: number): ValidatorOutstandingRewards;
	fromJSON(object: any): ValidatorOutstandingRewards;
	toJSON(message: ValidatorOutstandingRewards): unknown;
	fromPartial<I extends {
		rewards?: {
			denom?: string;
			amount?: string;
		}[];
	} & {
		rewards?: {
			denom?: string;
			amount?: string;
		}[] & ({
			denom?: string;
			amount?: string;
		} & {
			denom?: string;
			amount?: string;
		} & Record<Exclude<keyof I["rewards"][number], keyof DecCoin>, never>)[] & Record<Exclude<keyof I["rewards"], keyof {
			denom?: string;
			amount?: string;
		}[]>, never>;
	} & Record<Exclude<keyof I, "rewards">, never>>(object: I): ValidatorOutstandingRewards;
};
declare const ValidatorSlashEvent: {
	encode(message: ValidatorSlashEvent, writer?: _m0.Writer): _m0.Writer;
	decode(input: _m0.Reader | Uint8Array, length?: number): ValidatorSlashEvent;
	fromJSON(object: any): ValidatorSlashEvent;
	toJSON(message: ValidatorSlashEvent): unknown;
	fromPartial<I extends {
		validatorPeriod?: string | number | Long.Long;
		fraction?: string;
	} & {
		validatorPeriod?: string | number | (Long.Long & {
			high: number;
			low: number;
			unsigned: boolean;
			add: (addend: string | number | Long.Long) => Long.Long;
			and: (other: string | number | Long.Long) => Long.Long;
			compare: (other: string | number | Long.Long) => number;
			comp: (other: string | number | Long.Long) => number;
			divide: (divisor: string | number | Long.Long) => Long.Long;
			div: (divisor: string | number | Long.Long) => Long.Long;
			equals: (other: string | number | Long.Long) => boolean;
			eq: (other: string | number | Long.Long) => boolean;
			getHighBits: () => number;
			getHighBitsUnsigned: () => number;
			getLowBits: () => number;
			getLowBitsUnsigned: () => number;
			getNumBitsAbs: () => number;
			greaterThan: (other: string | number | Long.Long) => boolean;
			gt: (other: string | number | Long.Long) => boolean;
			greaterThanOrEqual: (other: string | number | Long.Long) => boolean;
			gte: (other: string | number | Long.Long) => boolean;
			isEven: () => boolean;
			isNegative: () => boolean;
			isOdd: () => boolean;
			isPositive: () => boolean;
			isZero: () => boolean;
			lessThan: (other: string | number | Long.Long) => boolean;
			lt: (other: string | number | Long.Long) => boolean;
			lessThanOrEqual: (other: string | number | Long.Long) => boolean;
			lte: (other: string | number | Long.Long) => boolean;
			modulo: (other: string | number | Long.Long) => Long.Long;
			mod: (other: string | number | Long.Long) => Long.Long;
			multiply: (multiplier: string | number | Long.Long) => Long.Long;
			mul: (multiplier: string | number | Long.Long) => Long.Long;
			negate: () => Long.Long;
			neg: () => Long.Long;
			not: () => Long.Long;
			notEquals: (other: string | number | Long.Long) => boolean;
			neq: (other: string | number | Long.Long) => boolean;
			or: (other: string | number | Long.Long) => Long.Long;
			shiftLeft: (numBits: number | Long.Long) => Long.Long;
			shl: (numBits: number | Long.Long) => Long.Long;
			shiftRight: (numBits: number | Long.Long) => Long.Long;
			shr: (numBits: number | Long.Long) => Long.Long;
			shiftRightUnsigned: (numBits: number | Long.Long) => Long.Long;
			shru: (numBits: number | Long.Long) => Long.Long;
			subtract: (subtrahend: string | number | Long.Long) => Long.Long;
			sub: (subtrahend: string | number | Long.Long) => Long.Long;
			toInt: () => number;
			toNumber: () => number;
			toBytes: (le?: boolean) => number[];
			toBytesLE: () => number[];
			toBytesBE: () => number[];
			toSigned: () => Long.Long;
			toString: (radix?: number) => string;
			toUnsigned: () => Long.Long;
			xor: (other: string | number | Long.Long) => Long.Long;
		} & Record<Exclude<keyof I["validatorPeriod"], keyof Long.Long>, never>);
		fraction?: string;
	} & Record<Exclude<keyof I, keyof ValidatorSlashEvent>, never>>(object: I): ValidatorSlashEvent;
};
declare const DelegationDelegatorReward: {
	encode(message: DelegationDelegatorReward, writer?: _m0.Writer): _m0.Writer;
	decode(input: _m0.Reader | Uint8Array, length?: number): DelegationDelegatorReward;
	fromJSON(object: any): DelegationDelegatorReward;
	toJSON(message: DelegationDelegatorReward): unknown;
	fromPartial<I extends {
		validatorAddress?: string;
		reward?: {
			denom?: string;
			amount?: string;
		}[];
	} & {
		validatorAddress?: string;
		reward?: {
			denom?: string;
			amount?: string;
		}[] & ({
			denom?: string;
			amount?: string;
		} & {
			denom?: string;
			amount?: string;
		} & Record<Exclude<keyof I["reward"][number], keyof DecCoin>, never>)[] & Record<Exclude<keyof I["reward"], keyof {
			denom?: string;
			amount?: string;
		}[]>, never>;
	} & Record<Exclude<keyof I, keyof DelegationDelegatorReward>, never>>(object: I): DelegationDelegatorReward;
};
/** QueryParamsRequest is the request type for the Query/Params RPC method. */
export interface QueryParamsRequest {
}
/** QueryParamsResponse is the response type for the Query/Params RPC method. */
export interface QueryParamsResponse {
	/** params defines the parameters of the module. */
	params?: Params;
}
/**
 * QueryValidatorOutstandingRewardsRequest is the request type for the
 * Query/ValidatorOutstandingRewards RPC method.
 */
export interface QueryValidatorOutstandingRewardsRequest {
	/** validator_address defines the validator address to query for. */
	validatorAddress: string;
}
/**
 * QueryValidatorOutstandingRewardsResponse is the response type for the
 * Query/ValidatorOutstandingRewards RPC method.
 */
export interface QueryValidatorOutstandingRewardsResponse {
	rewards?: ValidatorOutstandingRewards;
}
/**
 * QueryValidatorCommissionRequest is the request type for the
 * Query/ValidatorCommission RPC method
 */
export interface QueryValidatorCommissionRequest {
	/** validator_address defines the validator address to query for. */
	validatorAddress: string;
}
/**
 * QueryValidatorCommissionResponse is the response type for the
 * Query/ValidatorCommission RPC method
 */
export interface QueryValidatorCommissionResponse {
	/** commission defines the commision the validator received. */
	commission?: ValidatorAccumulatedCommission;
}
/**
 * QueryValidatorSlashesRequest is the request type for the
 * Query/ValidatorSlashes RPC method
 */
export interface QueryValidatorSlashesRequest {
	/** validator_address defines the validator address to query for. */
	validatorAddress: string;
	/** starting_height defines the optional starting height to query the slashes. */
	startingHeight: Long;
	/** starting_height defines the optional ending height to query the slashes. */
	endingHeight: Long;
	/** pagination defines an optional pagination for the request. */
	pagination?: PageRequest;
}
/**
 * QueryValidatorSlashesResponse is the response type for the
 * Query/ValidatorSlashes RPC method.
 */
export interface QueryValidatorSlashesResponse {
	/** slashes defines the slashes the validator received. */
	slashes: ValidatorSlashEvent[];
	/** pagination defines the pagination in the response. */
	pagination?: PageResponse;
}
/**
 * QueryDelegationRewardsRequest is the request type for the
 * Query/DelegationRewards RPC method.
 */
export interface QueryDelegationRewardsRequest {
	/** delegator_address defines the delegator address to query for. */
	delegatorAddress: string;
	/** validator_address defines the validator address to query for. */
	validatorAddress: string;
}
/**
 * QueryDelegationRewardsResponse is the response type for the
 * Query/DelegationRewards RPC method.
 */
export interface QueryDelegationRewardsResponse {
	/** rewards defines the rewards accrued by a delegation. */
	rewards: DecCoin[];
}
/**
 * QueryDelegationTotalRewardsRequest is the request type for the
 * Query/DelegationTotalRewards RPC method.
 */
export interface QueryDelegationTotalRewardsRequest {
	/** delegator_address defines the delegator address to query for. */
	delegatorAddress: string;
}
/**
 * QueryDelegationTotalRewardsResponse is the response type for the
 * Query/DelegationTotalRewards RPC method.
 */
export interface QueryDelegationTotalRewardsResponse {
	/** rewards defines all the rewards accrued by a delegator. */
	rewards: DelegationDelegatorReward[];
	/** total defines the sum of all the rewards. */
	total: DecCoin[];
}
/**
 * QueryDelegatorValidatorsRequest is the request type for the
 * Query/DelegatorValidators RPC method.
 */
export interface QueryDelegatorValidatorsRequest {
	/** delegator_address defines the delegator address to query for. */
	delegatorAddress: string;
}
/**
 * QueryDelegatorValidatorsResponse is the response type for the
 * Query/DelegatorValidators RPC method.
 */
export interface QueryDelegatorValidatorsResponse {
	/** validators defines the validators a delegator is delegating for. */
	validators: string[];
}
/**
 * QueryDelegatorWithdrawAddressRequest is the request type for the
 * Query/DelegatorWithdrawAddress RPC method.
 */
export interface QueryDelegatorWithdrawAddressRequest {
	/** delegator_address defines the delegator address to query for. */
	delegatorAddress: string;
}
/**
 * QueryDelegatorWithdrawAddressResponse is the response type for the
 * Query/DelegatorWithdrawAddress RPC method.
 */
export interface QueryDelegatorWithdrawAddressResponse {
	/** withdraw_address defines the delegator address to query for. */
	withdrawAddress: string;
}
/**
 * QueryCommunityPoolRequest is the request type for the Query/CommunityPool RPC
 * method.
 */
export interface QueryCommunityPoolRequest {
}
/**
 * QueryCommunityPoolResponse is the response type for the Query/CommunityPool
 * RPC method.
 */
export interface QueryCommunityPoolResponse {
	/** pool defines community pool's coins. */
	pool: DecCoin[];
}
declare const QueryParamsRequest: {
	encode(_: QueryParamsRequest, writer?: _m0.Writer): _m0.Writer;
	decode(input: _m0.Reader | Uint8Array, length?: number): QueryParamsRequest;
	fromJSON(_: any): QueryParamsRequest;
	toJSON(_: QueryParamsRequest): unknown;
	fromPartial<I extends {} & {} & Record<Exclude<keyof I, never>, never>>(_: I): QueryParamsRequest;
};
declare const QueryParamsResponse: {
	encode(message: QueryParamsResponse, writer?: _m0.Writer): _m0.Writer;
	decode(input: _m0.Reader | Uint8Array, length?: number): QueryParamsResponse;
	fromJSON(object: any): QueryParamsResponse;
	toJSON(message: QueryParamsResponse): unknown;
	fromPartial<I extends {
		params?: {
			communityTax?: string;
			baseProposerReward?: string;
			bonusProposerReward?: string;
			withdrawAddrEnabled?: boolean;
		};
	} & {
		params?: {
			communityTax?: string;
			baseProposerReward?: string;
			bonusProposerReward?: string;
			withdrawAddrEnabled?: boolean;
		} & {
			communityTax?: string;
			baseProposerReward?: string;
			bonusProposerReward?: string;
			withdrawAddrEnabled?: boolean;
		} & Record<Exclude<keyof I["params"], keyof Params>, never>;
	} & Record<Exclude<keyof I, "params">, never>>(object: I): QueryParamsResponse;
};
declare const QueryValidatorOutstandingRewardsRequest: {
	encode(message: QueryValidatorOutstandingRewardsRequest, writer?: _m0.Writer): _m0.Writer;
	decode(input: _m0.Reader | Uint8Array, length?: number): QueryValidatorOutstandingRewardsRequest;
	fromJSON(object: any): QueryValidatorOutstandingRewardsRequest;
	toJSON(message: QueryValidatorOutstandingRewardsRequest): unknown;
	fromPartial<I extends {
		validatorAddress?: string;
	} & {
		validatorAddress?: string;
	} & Record<Exclude<keyof I, "validatorAddress">, never>>(object: I): QueryValidatorOutstandingRewardsRequest;
};
declare const QueryValidatorOutstandingRewardsResponse: {
	encode(message: QueryValidatorOutstandingRewardsResponse, writer?: _m0.Writer): _m0.Writer;
	decode(input: _m0.Reader | Uint8Array, length?: number): QueryValidatorOutstandingRewardsResponse;
	fromJSON(object: any): QueryValidatorOutstandingRewardsResponse;
	toJSON(message: QueryValidatorOutstandingRewardsResponse): unknown;
	fromPartial<I extends {
		rewards?: {
			rewards?: {
				denom?: string;
				amount?: string;
			}[];
		};
	} & {
		rewards?: {
			rewards?: {
				denom?: string;
				amount?: string;
			}[];
		} & {
			rewards?: {
				denom?: string;
				amount?: string;
			}[] & ({
				denom?: string;
				amount?: string;
			} & {
				denom?: string;
				amount?: string;
			} & Record<Exclude<keyof I["rewards"]["rewards"][number], keyof DecCoin>, never>)[] & Record<Exclude<keyof I["rewards"]["rewards"], keyof {
				denom?: string;
				amount?: string;
			}[]>, never>;
		} & Record<Exclude<keyof I["rewards"], "rewards">, never>;
	} & Record<Exclude<keyof I, "rewards">, never>>(object: I): QueryValidatorOutstandingRewardsResponse;
};
declare const QueryValidatorCommissionRequest: {
	encode(message: QueryValidatorCommissionRequest, writer?: _m0.Writer): _m0.Writer;
	decode(input: _m0.Reader | Uint8Array, length?: number): QueryValidatorCommissionRequest;
	fromJSON(object: any): QueryValidatorCommissionRequest;
	toJSON(message: QueryValidatorCommissionRequest): unknown;
	fromPartial<I extends {
		validatorAddress?: string;
	} & {
		validatorAddress?: string;
	} & Record<Exclude<keyof I, "validatorAddress">, never>>(object: I): QueryValidatorCommissionRequest;
};
declare const QueryValidatorCommissionResponse: {
	encode(message: QueryValidatorCommissionResponse, writer?: _m0.Writer): _m0.Writer;
	decode(input: _m0.Reader | Uint8Array, length?: number): QueryValidatorCommissionResponse;
	fromJSON(object: any): QueryValidatorCommissionResponse;
	toJSON(message: QueryValidatorCommissionResponse): unknown;
	fromPartial<I extends {
		commission?: {
			commission?: {
				denom?: string;
				amount?: string;
			}[];
		};
	} & {
		commission?: {
			commission?: {
				denom?: string;
				amount?: string;
			}[];
		} & {
			commission?: {
				denom?: string;
				amount?: string;
			}[] & ({
				denom?: string;
				amount?: string;
			} & {
				denom?: string;
				amount?: string;
			} & Record<Exclude<keyof I["commission"]["commission"][number], keyof DecCoin>, never>)[] & Record<Exclude<keyof I["commission"]["commission"], keyof {
				denom?: string;
				amount?: string;
			}[]>, never>;
		} & Record<Exclude<keyof I["commission"], "commission">, never>;
	} & Record<Exclude<keyof I, "commission">, never>>(object: I): QueryValidatorCommissionResponse;
};
declare const QueryValidatorSlashesRequest: {
	encode(message: QueryValidatorSlashesRequest, writer?: _m0.Writer): _m0.Writer;
	decode(input: _m0.Reader | Uint8Array, length?: number): QueryValidatorSlashesRequest;
	fromJSON(object: any): QueryValidatorSlashesRequest;
	toJSON(message: QueryValidatorSlashesRequest): unknown;
	fromPartial<I extends {
		validatorAddress?: string;
		startingHeight?: string | number | Long.Long;
		endingHeight?: string | number | Long.Long;
		pagination?: {
			key?: Uint8Array;
			offset?: string | number | Long.Long;
			limit?: string | number | Long.Long;
			countTotal?: boolean;
			reverse?: boolean;
		};
	} & {
		validatorAddress?: string;
		startingHeight?: string | number | (Long.Long & {
			high: number;
			low: number;
			unsigned: boolean;
			add: (addend: string | number | Long.Long) => Long.Long;
			and: (other: string | number | Long.Long) => Long.Long;
			compare: (other: string | number | Long.Long) => number;
			comp: (other: string | number | Long.Long) => number;
			divide: (divisor: string | number | Long.Long) => Long.Long;
			div: (divisor: string | number | Long.Long) => Long.Long;
			equals: (other: string | number | Long.Long) => boolean;
			eq: (other: string | number | Long.Long) => boolean;
			getHighBits: () => number;
			getHighBitsUnsigned: () => number;
			getLowBits: () => number;
			getLowBitsUnsigned: () => number;
			getNumBitsAbs: () => number;
			greaterThan: (other: string | number | Long.Long) => boolean;
			gt: (other: string | number | Long.Long) => boolean;
			greaterThanOrEqual: (other: string | number | Long.Long) => boolean;
			gte: (other: string | number | Long.Long) => boolean;
			isEven: () => boolean;
			isNegative: () => boolean;
			isOdd: () => boolean;
			isPositive: () => boolean;
			isZero: () => boolean;
			lessThan: (other: string | number | Long.Long) => boolean;
			lt: (other: string | number | Long.Long) => boolean;
			lessThanOrEqual: (other: string | number | Long.Long) => boolean;
			lte: (other: string | number | Long.Long) => boolean;
			modulo: (other: string | number | Long.Long) => Long.Long;
			mod: (other: string | number | Long.Long) => Long.Long;
			multiply: (multiplier: string | number | Long.Long) => Long.Long;
			mul: (multiplier: string | number | Long.Long) => Long.Long;
			negate: () => Long.Long;
			neg: () => Long.Long;
			not: () => Long.Long;
			notEquals: (other: string | number | Long.Long) => boolean;
			neq: (other: string | number | Long.Long) => boolean;
			or: (other: string | number | Long.Long) => Long.Long;
			shiftLeft: (numBits: number | Long.Long) => Long.Long;
			shl: (numBits: number | Long.Long) => Long.Long;
			shiftRight: (numBits: number | Long.Long) => Long.Long;
			shr: (numBits: number | Long.Long) => Long.Long;
			shiftRightUnsigned: (numBits: number | Long.Long) => Long.Long;
			shru: (numBits: number | Long.Long) => Long.Long;
			subtract: (subtrahend: string | number | Long.Long) => Long.Long;
			sub: (subtrahend: string | number | Long.Long) => Long.Long;
			toInt: () => number;
			toNumber: () => number;
			toBytes: (le?: boolean) => number[];
			toBytesLE: () => number[];
			toBytesBE: () => number[];
			toSigned: () => Long.Long;
			toString: (radix?: number) => string;
			toUnsigned: () => Long.Long;
			xor: (other: string | number | Long.Long) => Long.Long;
		} & Record<Exclude<keyof I["startingHeight"], keyof Long.Long>, never>);
		endingHeight?: string | number | (Long.Long & {
			high: number;
			low: number;
			unsigned: boolean;
			add: (addend: string | number | Long.Long) => Long.Long;
			and: (other: string | number | Long.Long) => Long.Long;
			compare: (other: string | number | Long.Long) => number;
			comp: (other: string | number | Long.Long) => number;
			divide: (divisor: string | number | Long.Long) => Long.Long;
			div: (divisor: string | number | Long.Long) => Long.Long;
			equals: (other: string | number | Long.Long) => boolean;
			eq: (other: string | number | Long.Long) => boolean;
			getHighBits: () => number;
			getHighBitsUnsigned: () => number;
			getLowBits: () => number;
			getLowBitsUnsigned: () => number;
			getNumBitsAbs: () => number;
			greaterThan: (other: string | number | Long.Long) => boolean;
			gt: (other: string | number | Long.Long) => boolean;
			greaterThanOrEqual: (other: string | number | Long.Long) => boolean;
			gte: (other: string | number | Long.Long) => boolean;
			isEven: () => boolean;
			isNegative: () => boolean;
			isOdd: () => boolean;
			isPositive: () => boolean;
			isZero: () => boolean;
			lessThan: (other: string | number | Long.Long) => boolean;
			lt: (other: string | number | Long.Long) => boolean;
			lessThanOrEqual: (other: string | number | Long.Long) => boolean;
			lte: (other: string | number | Long.Long) => boolean;
			modulo: (other: string | number | Long.Long) => Long.Long;
			mod: (other: string | number | Long.Long) => Long.Long;
			multiply: (multiplier: string | number | Long.Long) => Long.Long;
			mul: (multiplier: string | number | Long.Long) => Long.Long;
			negate: () => Long.Long;
			neg: () => Long.Long;
			not: () => Long.Long;
			notEquals: (other: string | number | Long.Long) => boolean;
			neq: (other: string | number | Long.Long) => boolean;
			or: (other: string | number | Long.Long) => Long.Long;
			shiftLeft: (numBits: number | Long.Long) => Long.Long;
			shl: (numBits: number | Long.Long) => Long.Long;
			shiftRight: (numBits: number | Long.Long) => Long.Long;
			shr: (numBits: number | Long.Long) => Long.Long;
			shiftRightUnsigned: (numBits: number | Long.Long) => Long.Long;
			shru: (numBits: number | Long.Long) => Long.Long;
			subtract: (subtrahend: string | number | Long.Long) => Long.Long;
			sub: (subtrahend: string | number | Long.Long) => Long.Long;
			toInt: () => number;
			toNumber: () => number;
			toBytes: (le?: boolean) => number[];
			toBytesLE: () => number[];
			toBytesBE: () => number[];
			toSigned: () => Long.Long;
			toString: (radix?: number) => string;
			toUnsigned: () => Long.Long;
			xor: (other: string | number | Long.Long) => Long.Long;
		} & Record<Exclude<keyof I["endingHeight"], keyof Long.Long>, never>);
		pagination?: {
			key?: Uint8Array;
			offset?: string | number | Long.Long;
			limit?: string | number | Long.Long;
			countTotal?: boolean;
			reverse?: boolean;
		} & {
			key?: Uint8Array;
			offset?: string | number | (Long.Long & {
				high: number;
				low: number;
				unsigned: boolean;
				add: (addend: string | number | Long.Long) => Long.Long;
				and: (other: string | number | Long.Long) => Long.Long;
				compare: (other: string | number | Long.Long) => number;
				comp: (other: string | number | Long.Long) => number;
				divide: (divisor: string | number | Long.Long) => Long.Long;
				div: (divisor: string | number | Long.Long) => Long.Long;
				equals: (other: string | number | Long.Long) => boolean;
				eq: (other: string | number | Long.Long) => boolean;
				getHighBits: () => number;
				getHighBitsUnsigned: () => number;
				getLowBits: () => number;
				getLowBitsUnsigned: () => number;
				getNumBitsAbs: () => number;
				greaterThan: (other: string | number | Long.Long) => boolean;
				gt: (other: string | number | Long.Long) => boolean;
				greaterThanOrEqual: (other: string | number | Long.Long) => boolean;
				gte: (other: string | number | Long.Long) => boolean;
				isEven: () => boolean;
				isNegative: () => boolean;
				isOdd: () => boolean;
				isPositive: () => boolean;
				isZero: () => boolean;
				lessThan: (other: string | number | Long.Long) => boolean;
				lt: (other: string | number | Long.Long) => boolean;
				lessThanOrEqual: (other: string | number | Long.Long) => boolean;
				lte: (other: string | number | Long.Long) => boolean;
				modulo: (other: string | number | Long.Long) => Long.Long;
				mod: (other: string | number | Long.Long) => Long.Long;
				multiply: (multiplier: string | number | Long.Long) => Long.Long;
				mul: (multiplier: string | number | Long.Long) => Long.Long;
				negate: () => Long.Long;
				neg: () => Long.Long;
				not: () => Long.Long;
				notEquals: (other: string | number | Long.Long) => boolean;
				neq: (other: string | number | Long.Long) => boolean;
				or: (other: string | number | Long.Long) => Long.Long;
				shiftLeft: (numBits: number | Long.Long) => Long.Long;
				shl: (numBits: number | Long.Long) => Long.Long;
				shiftRight: (numBits: number | Long.Long) => Long.Long;
				shr: (numBits: number | Long.Long) => Long.Long;
				shiftRightUnsigned: (numBits: number | Long.Long) => Long.Long;
				shru: (numBits: number | Long.Long) => Long.Long;
				subtract: (subtrahend: string | number | Long.Long) => Long.Long;
				sub: (subtrahend: string | number | Long.Long) => Long.Long;
				toInt: () => number;
				toNumber: () => number;
				toBytes: (le?: boolean) => number[];
				toBytesLE: () => number[];
				toBytesBE: () => number[];
				toSigned: () => Long.Long;
				toString: (radix?: number) => string;
				toUnsigned: () => Long.Long;
				xor: (other: string | number | Long.Long) => Long.Long;
			} & Record<Exclude<keyof I["pagination"]["offset"], keyof Long.Long>, never>);
			limit?: string | number | (Long.Long & {
				high: number;
				low: number;
				unsigned: boolean;
				add: (addend: string | number | Long.Long) => Long.Long;
				and: (other: string | number | Long.Long) => Long.Long;
				compare: (other: string | number | Long.Long) => number;
				comp: (other: string | number | Long.Long) => number;
				divide: (divisor: string | number | Long.Long) => Long.Long;
				div: (divisor: string | number | Long.Long) => Long.Long;
				equals: (other: string | number | Long.Long) => boolean;
				eq: (other: string | number | Long.Long) => boolean;
				getHighBits: () => number;
				getHighBitsUnsigned: () => number;
				getLowBits: () => number;
				getLowBitsUnsigned: () => number;
				getNumBitsAbs: () => number;
				greaterThan: (other: string | number | Long.Long) => boolean;
				gt: (other: string | number | Long.Long) => boolean;
				greaterThanOrEqual: (other: string | number | Long.Long) => boolean;
				gte: (other: string | number | Long.Long) => boolean;
				isEven: () => boolean;
				isNegative: () => boolean;
				isOdd: () => boolean;
				isPositive: () => boolean;
				isZero: () => boolean;
				lessThan: (other: string | number | Long.Long) => boolean;
				lt: (other: string | number | Long.Long) => boolean;
				lessThanOrEqual: (other: string | number | Long.Long) => boolean;
				lte: (other: string | number | Long.Long) => boolean;
				modulo: (other: string | number | Long.Long) => Long.Long;
				mod: (other: string | number | Long.Long) => Long.Long;
				multiply: (multiplier: string | number | Long.Long) => Long.Long;
				mul: (multiplier: string | number | Long.Long) => Long.Long;
				negate: () => Long.Long;
				neg: () => Long.Long;
				not: () => Long.Long;
				notEquals: (other: string | number | Long.Long) => boolean;
				neq: (other: string | number | Long.Long) => boolean;
				or: (other: string | number | Long.Long) => Long.Long;
				shiftLeft: (numBits: number | Long.Long) => Long.Long;
				shl: (numBits: number | Long.Long) => Long.Long;
				shiftRight: (numBits: number | Long.Long) => Long.Long;
				shr: (numBits: number | Long.Long) => Long.Long;
				shiftRightUnsigned: (numBits: number | Long.Long) => Long.Long;
				shru: (numBits: number | Long.Long) => Long.Long;
				subtract: (subtrahend: string | number | Long.Long) => Long.Long;
				sub: (subtrahend: string | number | Long.Long) => Long.Long;
				toInt: () => number;
				toNumber: () => number;
				toBytes: (le?: boolean) => number[];
				toBytesLE: () => number[];
				toBytesBE: () => number[];
				toSigned: () => Long.Long;
				toString: (radix?: number) => string;
				toUnsigned: () => Long.Long;
				xor: (other: string | number | Long.Long) => Long.Long;
			} & Record<Exclude<keyof I["pagination"]["limit"], keyof Long.Long>, never>);
			countTotal?: boolean;
			reverse?: boolean;
		} & Record<Exclude<keyof I["pagination"], keyof PageRequest>, never>;
	} & Record<Exclude<keyof I, keyof QueryValidatorSlashesRequest>, never>>(object: I): QueryValidatorSlashesRequest;
};
declare const QueryValidatorSlashesResponse: {
	encode(message: QueryValidatorSlashesResponse, writer?: _m0.Writer): _m0.Writer;
	decode(input: _m0.Reader | Uint8Array, length?: number): QueryValidatorSlashesResponse;
	fromJSON(object: any): QueryValidatorSlashesResponse;
	toJSON(message: QueryValidatorSlashesResponse): unknown;
	fromPartial<I extends {
		slashes?: {
			validatorPeriod?: string | number | Long.Long;
			fraction?: string;
		}[];
		pagination?: {
			nextKey?: Uint8Array;
			total?: string | number | Long.Long;
		};
	} & {
		slashes?: {
			validatorPeriod?: string | number | Long.Long;
			fraction?: string;
		}[] & ({
			validatorPeriod?: string | number | Long.Long;
			fraction?: string;
		} & {
			validatorPeriod?: string | number | (Long.Long & {
				high: number;
				low: number;
				unsigned: boolean;
				add: (addend: string | number | Long.Long) => Long.Long;
				and: (other: string | number | Long.Long) => Long.Long;
				compare: (other: string | number | Long.Long) => number;
				comp: (other: string | number | Long.Long) => number;
				divide: (divisor: string | number | Long.Long) => Long.Long;
				div: (divisor: string | number | Long.Long) => Long.Long;
				equals: (other: string | number | Long.Long) => boolean;
				eq: (other: string | number | Long.Long) => boolean;
				getHighBits: () => number;
				getHighBitsUnsigned: () => number;
				getLowBits: () => number;
				getLowBitsUnsigned: () => number;
				getNumBitsAbs: () => number;
				greaterThan: (other: string | number | Long.Long) => boolean;
				gt: (other: string | number | Long.Long) => boolean;
				greaterThanOrEqual: (other: string | number | Long.Long) => boolean;
				gte: (other: string | number | Long.Long) => boolean;
				isEven: () => boolean;
				isNegative: () => boolean;
				isOdd: () => boolean;
				isPositive: () => boolean;
				isZero: () => boolean;
				lessThan: (other: string | number | Long.Long) => boolean;
				lt: (other: string | number | Long.Long) => boolean;
				lessThanOrEqual: (other: string | number | Long.Long) => boolean;
				lte: (other: string | number | Long.Long) => boolean;
				modulo: (other: string | number | Long.Long) => Long.Long;
				mod: (other: string | number | Long.Long) => Long.Long;
				multiply: (multiplier: string | number | Long.Long) => Long.Long;
				mul: (multiplier: string | number | Long.Long) => Long.Long;
				negate: () => Long.Long;
				neg: () => Long.Long;
				not: () => Long.Long;
				notEquals: (other: string | number | Long.Long) => boolean;
				neq: (other: string | number | Long.Long) => boolean;
				or: (other: string | number | Long.Long) => Long.Long;
				shiftLeft: (numBits: number | Long.Long) => Long.Long;
				shl: (numBits: number | Long.Long) => Long.Long;
				shiftRight: (numBits: number | Long.Long) => Long.Long;
				shr: (numBits: number | Long.Long) => Long.Long;
				shiftRightUnsigned: (numBits: number | Long.Long) => Long.Long;
				shru: (numBits: number | Long.Long) => Long.Long;
				subtract: (subtrahend: string | number | Long.Long) => Long.Long;
				sub: (subtrahend: string | number | Long.Long) => Long.Long;
				toInt: () => number;
				toNumber: () => number;
				toBytes: (le?: boolean) => number[];
				toBytesLE: () => number[];
				toBytesBE: () => number[];
				toSigned: () => Long.Long;
				toString: (radix?: number) => string;
				toUnsigned: () => Long.Long;
				xor: (other: string | number | Long.Long) => Long.Long;
			} & Record<Exclude<keyof I["slashes"][number]["validatorPeriod"], keyof Long.Long>, never>);
			fraction?: string;
		} & Record<Exclude<keyof I["slashes"][number], keyof ValidatorSlashEvent>, never>)[] & Record<Exclude<keyof I["slashes"], keyof {
			validatorPeriod?: string | number | Long.Long;
			fraction?: string;
		}[]>, never>;
		pagination?: {
			nextKey?: Uint8Array;
			total?: string | number | Long.Long;
		} & {
			nextKey?: Uint8Array;
			total?: string | number | (Long.Long & {
				high: number;
				low: number;
				unsigned: boolean;
				add: (addend: string | number | Long.Long) => Long.Long;
				and: (other: string | number | Long.Long) => Long.Long;
				compare: (other: string | number | Long.Long) => number;
				comp: (other: string | number | Long.Long) => number;
				divide: (divisor: string | number | Long.Long) => Long.Long;
				div: (divisor: string | number | Long.Long) => Long.Long;
				equals: (other: string | number | Long.Long) => boolean;
				eq: (other: string | number | Long.Long) => boolean;
				getHighBits: () => number;
				getHighBitsUnsigned: () => number;
				getLowBits: () => number;
				getLowBitsUnsigned: () => number;
				getNumBitsAbs: () => number;
				greaterThan: (other: string | number | Long.Long) => boolean;
				gt: (other: string | number | Long.Long) => boolean;
				greaterThanOrEqual: (other: string | number | Long.Long) => boolean;
				gte: (other: string | number | Long.Long) => boolean;
				isEven: () => boolean;
				isNegative: () => boolean;
				isOdd: () => boolean;
				isPositive: () => boolean;
				isZero: () => boolean;
				lessThan: (other: string | number | Long.Long) => boolean;
				lt: (other: string | number | Long.Long) => boolean;
				lessThanOrEqual: (other: string | number | Long.Long) => boolean;
				lte: (other: string | number | Long.Long) => boolean;
				modulo: (other: string | number | Long.Long) => Long.Long;
				mod: (other: string | number | Long.Long) => Long.Long;
				multiply: (multiplier: string | number | Long.Long) => Long.Long;
				mul: (multiplier: string | number | Long.Long) => Long.Long;
				negate: () => Long.Long;
				neg: () => Long.Long;
				not: () => Long.Long;
				notEquals: (other: string | number | Long.Long) => boolean;
				neq: (other: string | number | Long.Long) => boolean;
				or: (other: string | number | Long.Long) => Long.Long;
				shiftLeft: (numBits: number | Long.Long) => Long.Long;
				shl: (numBits: number | Long.Long) => Long.Long;
				shiftRight: (numBits: number | Long.Long) => Long.Long;
				shr: (numBits: number | Long.Long) => Long.Long;
				shiftRightUnsigned: (numBits: number | Long.Long) => Long.Long;
				shru: (numBits: number | Long.Long) => Long.Long;
				subtract: (subtrahend: string | number | Long.Long) => Long.Long;
				sub: (subtrahend: string | number | Long.Long) => Long.Long;
				toInt: () => number;
				toNumber: () => number;
				toBytes: (le?: boolean) => number[];
				toBytesLE: () => number[];
				toBytesBE: () => number[];
				toSigned: () => Long.Long;
				toString: (radix?: number) => string;
				toUnsigned: () => Long.Long;
				xor: (other: string | number | Long.Long) => Long.Long;
			} & Record<Exclude<keyof I["pagination"]["total"], keyof Long.Long>, never>);
		} & Record<Exclude<keyof I["pagination"], keyof PageResponse>, never>;
	} & Record<Exclude<keyof I, keyof QueryValidatorSlashesResponse>, never>>(object: I): QueryValidatorSlashesResponse;
};
declare const QueryDelegationRewardsRequest: {
	encode(message: QueryDelegationRewardsRequest, writer?: _m0.Writer): _m0.Writer;
	decode(input: _m0.Reader | Uint8Array, length?: number): QueryDelegationRewardsRequest;
	fromJSON(object: any): QueryDelegationRewardsRequest;
	toJSON(message: QueryDelegationRewardsRequest): unknown;
	fromPartial<I extends {
		delegatorAddress?: string;
		validatorAddress?: string;
	} & {
		delegatorAddress?: string;
		validatorAddress?: string;
	} & Record<Exclude<keyof I, keyof QueryDelegationRewardsRequest>, never>>(object: I): QueryDelegationRewardsRequest;
};
declare const QueryDelegationRewardsResponse: {
	encode(message: QueryDelegationRewardsResponse, writer?: _m0.Writer): _m0.Writer;
	decode(input: _m0.Reader | Uint8Array, length?: number): QueryDelegationRewardsResponse;
	fromJSON(object: any): QueryDelegationRewardsResponse;
	toJSON(message: QueryDelegationRewardsResponse): unknown;
	fromPartial<I extends {
		rewards?: {
			denom?: string;
			amount?: string;
		}[];
	} & {
		rewards?: {
			denom?: string;
			amount?: string;
		}[] & ({
			denom?: string;
			amount?: string;
		} & {
			denom?: string;
			amount?: string;
		} & Record<Exclude<keyof I["rewards"][number], keyof DecCoin>, never>)[] & Record<Exclude<keyof I["rewards"], keyof {
			denom?: string;
			amount?: string;
		}[]>, never>;
	} & Record<Exclude<keyof I, "rewards">, never>>(object: I): QueryDelegationRewardsResponse;
};
declare const QueryDelegationTotalRewardsRequest: {
	encode(message: QueryDelegationTotalRewardsRequest, writer?: _m0.Writer): _m0.Writer;
	decode(input: _m0.Reader | Uint8Array, length?: number): QueryDelegationTotalRewardsRequest;
	fromJSON(object: any): QueryDelegationTotalRewardsRequest;
	toJSON(message: QueryDelegationTotalRewardsRequest): unknown;
	fromPartial<I extends {
		delegatorAddress?: string;
	} & {
		delegatorAddress?: string;
	} & Record<Exclude<keyof I, "delegatorAddress">, never>>(object: I): QueryDelegationTotalRewardsRequest;
};
declare const QueryDelegationTotalRewardsResponse: {
	encode(message: QueryDelegationTotalRewardsResponse, writer?: _m0.Writer): _m0.Writer;
	decode(input: _m0.Reader | Uint8Array, length?: number): QueryDelegationTotalRewardsResponse;
	fromJSON(object: any): QueryDelegationTotalRewardsResponse;
	toJSON(message: QueryDelegationTotalRewardsResponse): unknown;
	fromPartial<I extends {
		rewards?: {
			validatorAddress?: string;
			reward?: {
				denom?: string;
				amount?: string;
			}[];
		}[];
		total?: {
			denom?: string;
			amount?: string;
		}[];
	} & {
		rewards?: {
			validatorAddress?: string;
			reward?: {
				denom?: string;
				amount?: string;
			}[];
		}[] & ({
			validatorAddress?: string;
			reward?: {
				denom?: string;
				amount?: string;
			}[];
		} & {
			validatorAddress?: string;
			reward?: {
				denom?: string;
				amount?: string;
			}[] & ({
				denom?: string;
				amount?: string;
			} & {
				denom?: string;
				amount?: string;
			} & Record<Exclude<keyof I["rewards"][number]["reward"][number], keyof DecCoin>, never>)[] & Record<Exclude<keyof I["rewards"][number]["reward"], keyof {
				denom?: string;
				amount?: string;
			}[]>, never>;
		} & Record<Exclude<keyof I["rewards"][number], keyof DelegationDelegatorReward>, never>)[] & Record<Exclude<keyof I["rewards"], keyof {
			validatorAddress?: string;
			reward?: {
				denom?: string;
				amount?: string;
			}[];
		}[]>, never>;
		total?: {
			denom?: string;
			amount?: string;
		}[] & ({
			denom?: string;
			amount?: string;
		} & {
			denom?: string;
			amount?: string;
		} & Record<Exclude<keyof I["total"][number], keyof DecCoin>, never>)[] & Record<Exclude<keyof I["total"], keyof {
			denom?: string;
			amount?: string;
		}[]>, never>;
	} & Record<Exclude<keyof I, keyof QueryDelegationTotalRewardsResponse>, never>>(object: I): QueryDelegationTotalRewardsResponse;
};
declare const QueryDelegatorValidatorsRequest: {
	encode(message: QueryDelegatorValidatorsRequest, writer?: _m0.Writer): _m0.Writer;
	decode(input: _m0.Reader | Uint8Array, length?: number): QueryDelegatorValidatorsRequest;
	fromJSON(object: any): QueryDelegatorValidatorsRequest;
	toJSON(message: QueryDelegatorValidatorsRequest): unknown;
	fromPartial<I extends {
		delegatorAddress?: string;
	} & {
		delegatorAddress?: string;
	} & Record<Exclude<keyof I, "delegatorAddress">, never>>(object: I): QueryDelegatorValidatorsRequest;
};
declare const QueryDelegatorValidatorsResponse: {
	encode(message: QueryDelegatorValidatorsResponse, writer?: _m0.Writer): _m0.Writer;
	decode(input: _m0.Reader | Uint8Array, length?: number): QueryDelegatorValidatorsResponse;
	fromJSON(object: any): QueryDelegatorValidatorsResponse;
	toJSON(message: QueryDelegatorValidatorsResponse): unknown;
	fromPartial<I extends {
		validators?: string[];
	} & {
		validators?: string[] & string[] & Record<Exclude<keyof I["validators"], keyof string[]>, never>;
	} & Record<Exclude<keyof I, "validators">, never>>(object: I): QueryDelegatorValidatorsResponse;
};
declare const QueryDelegatorWithdrawAddressRequest: {
	encode(message: QueryDelegatorWithdrawAddressRequest, writer?: _m0.Writer): _m0.Writer;
	decode(input: _m0.Reader | Uint8Array, length?: number): QueryDelegatorWithdrawAddressRequest;
	fromJSON(object: any): QueryDelegatorWithdrawAddressRequest;
	toJSON(message: QueryDelegatorWithdrawAddressRequest): unknown;
	fromPartial<I extends {
		delegatorAddress?: string;
	} & {
		delegatorAddress?: string;
	} & Record<Exclude<keyof I, "delegatorAddress">, never>>(object: I): QueryDelegatorWithdrawAddressRequest;
};
declare const QueryDelegatorWithdrawAddressResponse: {
	encode(message: QueryDelegatorWithdrawAddressResponse, writer?: _m0.Writer): _m0.Writer;
	decode(input: _m0.Reader | Uint8Array, length?: number): QueryDelegatorWithdrawAddressResponse;
	fromJSON(object: any): QueryDelegatorWithdrawAddressResponse;
	toJSON(message: QueryDelegatorWithdrawAddressResponse): unknown;
	fromPartial<I extends {
		withdrawAddress?: string;
	} & {
		withdrawAddress?: string;
	} & Record<Exclude<keyof I, "withdrawAddress">, never>>(object: I): QueryDelegatorWithdrawAddressResponse;
};
declare const QueryCommunityPoolRequest: {
	encode(_: QueryCommunityPoolRequest, writer?: _m0.Writer): _m0.Writer;
	decode(input: _m0.Reader | Uint8Array, length?: number): QueryCommunityPoolRequest;
	fromJSON(_: any): QueryCommunityPoolRequest;
	toJSON(_: QueryCommunityPoolRequest): unknown;
	fromPartial<I extends {} & {} & Record<Exclude<keyof I, never>, never>>(_: I): QueryCommunityPoolRequest;
};
declare const QueryCommunityPoolResponse: {
	encode(message: QueryCommunityPoolResponse, writer?: _m0.Writer): _m0.Writer;
	decode(input: _m0.Reader | Uint8Array, length?: number): QueryCommunityPoolResponse;
	fromJSON(object: any): QueryCommunityPoolResponse;
	toJSON(message: QueryCommunityPoolResponse): unknown;
	fromPartial<I extends {
		pool?: {
			denom?: string;
			amount?: string;
		}[];
	} & {
		pool?: {
			denom?: string;
			amount?: string;
		}[] & ({
			denom?: string;
			amount?: string;
		} & {
			denom?: string;
			amount?: string;
		} & Record<Exclude<keyof I["pool"][number], keyof DecCoin>, never>)[] & Record<Exclude<keyof I["pool"], keyof {
			denom?: string;
			amount?: string;
		}[]>, never>;
	} & Record<Exclude<keyof I, "pool">, never>>(object: I): QueryCommunityPoolResponse;
};
/** Query defines the gRPC querier service for distribution module. */
export interface Query {
	/** Params queries params of the distribution module. */
	Params(request: QueryParamsRequest): Promise<QueryParamsResponse>;
	/** ValidatorOutstandingRewards queries rewards of a validator address. */
	ValidatorOutstandingRewards(request: QueryValidatorOutstandingRewardsRequest): Promise<QueryValidatorOutstandingRewardsResponse>;
	/** ValidatorCommission queries accumulated commission for a validator. */
	ValidatorCommission(request: QueryValidatorCommissionRequest): Promise<QueryValidatorCommissionResponse>;
	/** ValidatorSlashes queries slash events of a validator. */
	ValidatorSlashes(request: QueryValidatorSlashesRequest): Promise<QueryValidatorSlashesResponse>;
	/** DelegationRewards queries the total rewards accrued by a delegation. */
	DelegationRewards(request: QueryDelegationRewardsRequest): Promise<QueryDelegationRewardsResponse>;
	/**
	 * DelegationTotalRewards queries the total rewards accrued by a each
	 * validator.
	 */
	DelegationTotalRewards(request: QueryDelegationTotalRewardsRequest): Promise<QueryDelegationTotalRewardsResponse>;
	/** DelegatorValidators queries the validators of a delegator. */
	DelegatorValidators(request: QueryDelegatorValidatorsRequest): Promise<QueryDelegatorValidatorsResponse>;
	/** DelegatorWithdrawAddress queries withdraw address of a delegator. */
	DelegatorWithdrawAddress(request: QueryDelegatorWithdrawAddressRequest): Promise<QueryDelegatorWithdrawAddressResponse>;
	/** CommunityPool queries the community pool coins. */
	CommunityPool(request: QueryCommunityPoolRequest): Promise<QueryCommunityPoolResponse>;
}
declare class QueryClientImpl implements Query {
	private readonly rpc;
	constructor(rpc: Rpc);
	Params(request: QueryParamsRequest): Promise<QueryParamsResponse>;
	ValidatorOutstandingRewards(request: QueryValidatorOutstandingRewardsRequest): Promise<QueryValidatorOutstandingRewardsResponse>;
	ValidatorCommission(request: QueryValidatorCommissionRequest): Promise<QueryValidatorCommissionResponse>;
	ValidatorSlashes(request: QueryValidatorSlashesRequest): Promise<QueryValidatorSlashesResponse>;
	DelegationRewards(request: QueryDelegationRewardsRequest): Promise<QueryDelegationRewardsResponse>;
	DelegationTotalRewards(request: QueryDelegationTotalRewardsRequest): Promise<QueryDelegationTotalRewardsResponse>;
	DelegatorValidators(request: QueryDelegatorValidatorsRequest): Promise<QueryDelegatorValidatorsResponse>;
	DelegatorWithdrawAddress(request: QueryDelegatorWithdrawAddressRequest): Promise<QueryDelegatorWithdrawAddressResponse>;
	CommunityPool(request: QueryCommunityPoolRequest): Promise<QueryCommunityPoolResponse>;
}
export interface Rpc {
	request(service: string, method: string, data: Uint8Array): Promise<Uint8Array>;
}
/**
 * Event allows application developers to attach additional information to
 * ResponseBeginBlock, ResponseEndBlock, ResponseCheckTx and ResponseDeliverTx.
 * Later, transactions may be queried using these events.
 */
export interface Event {
	type: string;
	attributes: EventAttribute[];
}
/** EventAttribute is a single key-value pair, associated with an event. */
export interface EventAttribute {
	key: Uint8Array;
	value: Uint8Array;
	/** nondeterministic */
	index: boolean;
}
declare const Event: {
	encode(message: Event, writer?: _m0.Writer): _m0.Writer;
	decode(input: _m0.Reader | Uint8Array, length?: number): Event;
	fromJSON(object: any): Event;
	toJSON(message: Event): unknown;
	fromPartial<I extends {
		type?: string;
		attributes?: {
			key?: Uint8Array;
			value?: Uint8Array;
			index?: boolean;
		}[];
	} & {
		type?: string;
		attributes?: {
			key?: Uint8Array;
			value?: Uint8Array;
			index?: boolean;
		}[] & ({
			key?: Uint8Array;
			value?: Uint8Array;
			index?: boolean;
		} & {
			key?: Uint8Array;
			value?: Uint8Array;
			index?: boolean;
		} & Record<Exclude<keyof I["attributes"][number], keyof EventAttribute>, never>)[] & Record<Exclude<keyof I["attributes"], keyof {
			key?: Uint8Array;
			value?: Uint8Array;
			index?: boolean;
		}[]>, never>;
	} & Record<Exclude<keyof I, keyof Event>, never>>(object: I): Event;
};
declare const EventAttribute: {
	encode(message: EventAttribute, writer?: _m0.Writer): _m0.Writer;
	decode(input: _m0.Reader | Uint8Array, length?: number): EventAttribute;
	fromJSON(object: any): EventAttribute;
	toJSON(message: EventAttribute): unknown;
	fromPartial<I extends {
		key?: Uint8Array;
		value?: Uint8Array;
		index?: boolean;
	} & {
		key?: Uint8Array;
		value?: Uint8Array;
		index?: boolean;
	} & Record<Exclude<keyof I, keyof EventAttribute>, never>>(object: I): EventAttribute;
};
/**
 * TxResponse defines a structure containing relevant tx data and metadata. The
 * tags are stringified and the log is JSON decoded.
 */
export interface TxResponse {
	/** The block height */
	height: Long;
	/** The transaction hash. */
	txhash: string;
	/** Namespace for the Code */
	codespace: string;
	/** Response code. */
	code: number;
	/** Result bytes, if any. */
	data: string;
	/**
	 * The output of the application's logger (raw string). May be
	 * non-deterministic.
	 */
	rawLog: string;
	/** The output of the application's logger (typed). May be non-deterministic. */
	logs: ABCIMessageLog[];
	/** Additional information. May be non-deterministic. */
	info: string;
	/** Amount of gas requested for transaction. */
	gasWanted: Long;
	/** Amount of gas consumed by transaction. */
	gasUsed: Long;
	/** The request transaction bytes. */
	tx?: Any;
	/**
	 * Time of the previous block. For heights > 1, it's the weighted median of
	 * the timestamps of the valid votes in the block.LastCommit. For height == 1,
	 * it's genesis time.
	 */
	timestamp: string;
}
/** ABCIMessageLog defines a structure containing an indexed tx ABCI message log. */
export interface ABCIMessageLog {
	msgIndex: number;
	log: string;
	/**
	 * Events contains a slice of Event objects that were emitted during some
	 * execution.
	 */
	events: StringEvent[];
}
/**
 * StringEvent defines en Event object wrapper where all the attributes
 * contain key/value pairs that are strings instead of raw bytes.
 */
export interface StringEvent {
	type: string;
	attributes: Attribute[];
}
/**
 * Attribute defines an attribute wrapper where the key and value are
 * strings instead of raw bytes.
 */
export interface Attribute {
	key: string;
	value: string;
}
/** GasInfo defines tx execution gas context. */
export interface GasInfo {
	/** GasWanted is the maximum units of work we allow this tx to perform. */
	gasWanted: Long;
	/** GasUsed is the amount of gas actually consumed. */
	gasUsed: Long;
}
/** Result is the union of ResponseFormat and ResponseCheckTx. */
export interface Result {
	/**
	 * Data is any data returned from message or handler execution. It MUST be
	 * length prefixed in order to separate data from multiple message executions.
	 */
	data: Uint8Array;
	/** Log contains the log information from message or handler execution. */
	log: string;
	/**
	 * Events contains a slice of Event objects that were emitted during message
	 * or handler execution.
	 */
	events: Event[];
}
declare const TxResponse: {
	encode(message: TxResponse, writer?: _m0.Writer): _m0.Writer;
	decode(input: _m0.Reader | Uint8Array, length?: number): TxResponse;
	fromJSON(object: any): TxResponse;
	toJSON(message: TxResponse): unknown;
	fromPartial<I extends {
		height?: string | number | Long.Long;
		txhash?: string;
		codespace?: string;
		code?: number;
		data?: string;
		rawLog?: string;
		logs?: {
			msgIndex?: number;
			log?: string;
			events?: {
				type?: string;
				attributes?: {
					key?: string;
					value?: string;
				}[];
			}[];
		}[];
		info?: string;
		gasWanted?: string | number | Long.Long;
		gasUsed?: string | number | Long.Long;
		tx?: {
			typeUrl?: string;
			value?: Uint8Array;
		};
		timestamp?: string;
	} & {
		height?: string | number | (Long.Long & {
			high: number;
			low: number;
			unsigned: boolean;
			add: (addend: string | number | Long.Long) => Long.Long;
			and: (other: string | number | Long.Long) => Long.Long;
			compare: (other: string | number | Long.Long) => number;
			comp: (other: string | number | Long.Long) => number;
			divide: (divisor: string | number | Long.Long) => Long.Long;
			div: (divisor: string | number | Long.Long) => Long.Long;
			equals: (other: string | number | Long.Long) => boolean;
			eq: (other: string | number | Long.Long) => boolean;
			getHighBits: () => number;
			getHighBitsUnsigned: () => number;
			getLowBits: () => number;
			getLowBitsUnsigned: () => number;
			getNumBitsAbs: () => number;
			greaterThan: (other: string | number | Long.Long) => boolean;
			gt: (other: string | number | Long.Long) => boolean;
			greaterThanOrEqual: (other: string | number | Long.Long) => boolean;
			gte: (other: string | number | Long.Long) => boolean;
			isEven: () => boolean;
			isNegative: () => boolean;
			isOdd: () => boolean;
			isPositive: () => boolean;
			isZero: () => boolean;
			lessThan: (other: string | number | Long.Long) => boolean;
			lt: (other: string | number | Long.Long) => boolean;
			lessThanOrEqual: (other: string | number | Long.Long) => boolean;
			lte: (other: string | number | Long.Long) => boolean;
			modulo: (other: string | number | Long.Long) => Long.Long;
			mod: (other: string | number | Long.Long) => Long.Long;
			multiply: (multiplier: string | number | Long.Long) => Long.Long;
			mul: (multiplier: string | number | Long.Long) => Long.Long;
			negate: () => Long.Long;
			neg: () => Long.Long;
			not: () => Long.Long;
			notEquals: (other: string | number | Long.Long) => boolean;
			neq: (other: string | number | Long.Long) => boolean;
			or: (other: string | number | Long.Long) => Long.Long;
			shiftLeft: (numBits: number | Long.Long) => Long.Long;
			shl: (numBits: number | Long.Long) => Long.Long;
			shiftRight: (numBits: number | Long.Long) => Long.Long;
			shr: (numBits: number | Long.Long) => Long.Long;
			shiftRightUnsigned: (numBits: number | Long.Long) => Long.Long;
			shru: (numBits: number | Long.Long) => Long.Long;
			subtract: (subtrahend: string | number | Long.Long) => Long.Long;
			sub: (subtrahend: string | number | Long.Long) => Long.Long;
			toInt: () => number;
			toNumber: () => number;
			toBytes: (le?: boolean) => number[];
			toBytesLE: () => number[];
			toBytesBE: () => number[];
			toSigned: () => Long.Long;
			toString: (radix?: number) => string;
			toUnsigned: () => Long.Long;
			xor: (other: string | number | Long.Long) => Long.Long;
		} & Record<Exclude<keyof I["height"], keyof Long.Long>, never>);
		txhash?: string;
		codespace?: string;
		code?: number;
		data?: string;
		rawLog?: string;
		logs?: {
			msgIndex?: number;
			log?: string;
			events?: {
				type?: string;
				attributes?: {
					key?: string;
					value?: string;
				}[];
			}[];
		}[] & ({
			msgIndex?: number;
			log?: string;
			events?: {
				type?: string;
				attributes?: {
					key?: string;
					value?: string;
				}[];
			}[];
		} & {
			msgIndex?: number;
			log?: string;
			events?: {
				type?: string;
				attributes?: {
					key?: string;
					value?: string;
				}[];
			}[] & ({
				type?: string;
				attributes?: {
					key?: string;
					value?: string;
				}[];
			} & {
				type?: string;
				attributes?: {
					key?: string;
					value?: string;
				}[] & ({
					key?: string;
					value?: string;
				} & {
					key?: string;
					value?: string;
				} & Record<Exclude<keyof I["logs"][number]["events"][number]["attributes"][number], keyof Attribute>, never>)[] & Record<Exclude<keyof I["logs"][number]["events"][number]["attributes"], keyof {
					key?: string;
					value?: string;
				}[]>, never>;
			} & Record<Exclude<keyof I["logs"][number]["events"][number], keyof StringEvent>, never>)[] & Record<Exclude<keyof I["logs"][number]["events"], keyof {
				type?: string;
				attributes?: {
					key?: string;
					value?: string;
				}[];
			}[]>, never>;
		} & Record<Exclude<keyof I["logs"][number], keyof ABCIMessageLog>, never>)[] & Record<Exclude<keyof I["logs"], keyof {
			msgIndex?: number;
			log?: string;
			events?: {
				type?: string;
				attributes?: {
					key?: string;
					value?: string;
				}[];
			}[];
		}[]>, never>;
		info?: string;
		gasWanted?: string | number | (Long.Long & {
			high: number;
			low: number;
			unsigned: boolean;
			add: (addend: string | number | Long.Long) => Long.Long;
			and: (other: string | number | Long.Long) => Long.Long;
			compare: (other: string | number | Long.Long) => number;
			comp: (other: string | number | Long.Long) => number;
			divide: (divisor: string | number | Long.Long) => Long.Long;
			div: (divisor: string | number | Long.Long) => Long.Long;
			equals: (other: string | number | Long.Long) => boolean;
			eq: (other: string | number | Long.Long) => boolean;
			getHighBits: () => number;
			getHighBitsUnsigned: () => number;
			getLowBits: () => number;
			getLowBitsUnsigned: () => number;
			getNumBitsAbs: () => number;
			greaterThan: (other: string | number | Long.Long) => boolean;
			gt: (other: string | number | Long.Long) => boolean;
			greaterThanOrEqual: (other: string | number | Long.Long) => boolean;
			gte: (other: string | number | Long.Long) => boolean;
			isEven: () => boolean;
			isNegative: () => boolean;
			isOdd: () => boolean;
			isPositive: () => boolean;
			isZero: () => boolean;
			lessThan: (other: string | number | Long.Long) => boolean;
			lt: (other: string | number | Long.Long) => boolean;
			lessThanOrEqual: (other: string | number | Long.Long) => boolean;
			lte: (other: string | number | Long.Long) => boolean;
			modulo: (other: string | number | Long.Long) => Long.Long;
			mod: (other: string | number | Long.Long) => Long.Long;
			multiply: (multiplier: string | number | Long.Long) => Long.Long;
			mul: (multiplier: string | number | Long.Long) => Long.Long;
			negate: () => Long.Long;
			neg: () => Long.Long;
			not: () => Long.Long;
			notEquals: (other: string | number | Long.Long) => boolean;
			neq: (other: string | number | Long.Long) => boolean;
			or: (other: string | number | Long.Long) => Long.Long;
			shiftLeft: (numBits: number | Long.Long) => Long.Long;
			shl: (numBits: number | Long.Long) => Long.Long;
			shiftRight: (numBits: number | Long.Long) => Long.Long;
			shr: (numBits: number | Long.Long) => Long.Long;
			shiftRightUnsigned: (numBits: number | Long.Long) => Long.Long;
			shru: (numBits: number | Long.Long) => Long.Long;
			subtract: (subtrahend: string | number | Long.Long) => Long.Long;
			sub: (subtrahend: string | number | Long.Long) => Long.Long;
			toInt: () => number;
			toNumber: () => number;
			toBytes: (le?: boolean) => number[];
			toBytesLE: () => number[];
			toBytesBE: () => number[];
			toSigned: () => Long.Long;
			toString: (radix?: number) => string;
			toUnsigned: () => Long.Long;
			xor: (other: string | number | Long.Long) => Long.Long;
		} & Record<Exclude<keyof I["gasWanted"], keyof Long.Long>, never>);
		gasUsed?: string | number | (Long.Long & {
			high: number;
			low: number;
			unsigned: boolean;
			add: (addend: string | number | Long.Long) => Long.Long;
			and: (other: string | number | Long.Long) => Long.Long;
			compare: (other: string | number | Long.Long) => number;
			comp: (other: string | number | Long.Long) => number;
			divide: (divisor: string | number | Long.Long) => Long.Long;
			div: (divisor: string | number | Long.Long) => Long.Long;
			equals: (other: string | number | Long.Long) => boolean;
			eq: (other: string | number | Long.Long) => boolean;
			getHighBits: () => number;
			getHighBitsUnsigned: () => number;
			getLowBits: () => number;
			getLowBitsUnsigned: () => number;
			getNumBitsAbs: () => number;
			greaterThan: (other: string | number | Long.Long) => boolean;
			gt: (other: string | number | Long.Long) => boolean;
			greaterThanOrEqual: (other: string | number | Long.Long) => boolean;
			gte: (other: string | number | Long.Long) => boolean;
			isEven: () => boolean;
			isNegative: () => boolean;
			isOdd: () => boolean;
			isPositive: () => boolean;
			isZero: () => boolean;
			lessThan: (other: string | number | Long.Long) => boolean;
			lt: (other: string | number | Long.Long) => boolean;
			lessThanOrEqual: (other: string | number | Long.Long) => boolean;
			lte: (other: string | number | Long.Long) => boolean;
			modulo: (other: string | number | Long.Long) => Long.Long;
			mod: (other: string | number | Long.Long) => Long.Long;
			multiply: (multiplier: string | number | Long.Long) => Long.Long;
			mul: (multiplier: string | number | Long.Long) => Long.Long;
			negate: () => Long.Long;
			neg: () => Long.Long;
			not: () => Long.Long;
			notEquals: (other: string | number | Long.Long) => boolean;
			neq: (other: string | number | Long.Long) => boolean;
			or: (other: string | number | Long.Long) => Long.Long;
			shiftLeft: (numBits: number | Long.Long) => Long.Long;
			shl: (numBits: number | Long.Long) => Long.Long;
			shiftRight: (numBits: number | Long.Long) => Long.Long;
			shr: (numBits: number | Long.Long) => Long.Long;
			shiftRightUnsigned: (numBits: number | Long.Long) => Long.Long;
			shru: (numBits: number | Long.Long) => Long.Long;
			subtract: (subtrahend: string | number | Long.Long) => Long.Long;
			sub: (subtrahend: string | number | Long.Long) => Long.Long;
			toInt: () => number;
			toNumber: () => number;
			toBytes: (le?: boolean) => number[];
			toBytesLE: () => number[];
			toBytesBE: () => number[];
			toSigned: () => Long.Long;
			toString: (radix?: number) => string;
			toUnsigned: () => Long.Long;
			xor: (other: string | number | Long.Long) => Long.Long;
		} & Record<Exclude<keyof I["gasUsed"], keyof Long.Long>, never>);
		tx?: {
			typeUrl?: string;
			value?: Uint8Array;
		} & {
			typeUrl?: string;
			value?: Uint8Array;
		} & Record<Exclude<keyof I["tx"], keyof Any>, never>;
		timestamp?: string;
	} & Record<Exclude<keyof I, keyof TxResponse>, never>>(object: I): TxResponse;
};
declare const ABCIMessageLog: {
	encode(message: ABCIMessageLog, writer?: _m0.Writer): _m0.Writer;
	decode(input: _m0.Reader | Uint8Array, length?: number): ABCIMessageLog;
	fromJSON(object: any): ABCIMessageLog;
	toJSON(message: ABCIMessageLog): unknown;
	fromPartial<I extends {
		msgIndex?: number;
		log?: string;
		events?: {
			type?: string;
			attributes?: {
				key?: string;
				value?: string;
			}[];
		}[];
	} & {
		msgIndex?: number;
		log?: string;
		events?: {
			type?: string;
			attributes?: {
				key?: string;
				value?: string;
			}[];
		}[] & ({
			type?: string;
			attributes?: {
				key?: string;
				value?: string;
			}[];
		} & {
			type?: string;
			attributes?: {
				key?: string;
				value?: string;
			}[] & ({
				key?: string;
				value?: string;
			} & {
				key?: string;
				value?: string;
			} & Record<Exclude<keyof I["events"][number]["attributes"][number], keyof Attribute>, never>)[] & Record<Exclude<keyof I["events"][number]["attributes"], keyof {
				key?: string;
				value?: string;
			}[]>, never>;
		} & Record<Exclude<keyof I["events"][number], keyof StringEvent>, never>)[] & Record<Exclude<keyof I["events"], keyof {
			type?: string;
			attributes?: {
				key?: string;
				value?: string;
			}[];
		}[]>, never>;
	} & Record<Exclude<keyof I, keyof ABCIMessageLog>, never>>(object: I): ABCIMessageLog;
};
declare const StringEvent: {
	encode(message: StringEvent, writer?: _m0.Writer): _m0.Writer;
	decode(input: _m0.Reader | Uint8Array, length?: number): StringEvent;
	fromJSON(object: any): StringEvent;
	toJSON(message: StringEvent): unknown;
	fromPartial<I extends {
		type?: string;
		attributes?: {
			key?: string;
			value?: string;
		}[];
	} & {
		type?: string;
		attributes?: {
			key?: string;
			value?: string;
		}[] & ({
			key?: string;
			value?: string;
		} & {
			key?: string;
			value?: string;
		} & Record<Exclude<keyof I["attributes"][number], keyof Attribute>, never>)[] & Record<Exclude<keyof I["attributes"], keyof {
			key?: string;
			value?: string;
		}[]>, never>;
	} & Record<Exclude<keyof I, keyof StringEvent>, never>>(object: I): StringEvent;
};
declare const Attribute: {
	encode(message: Attribute, writer?: _m0.Writer): _m0.Writer;
	decode(input: _m0.Reader | Uint8Array, length?: number): Attribute;
	fromJSON(object: any): Attribute;
	toJSON(message: Attribute): unknown;
	fromPartial<I extends {
		key?: string;
		value?: string;
	} & {
		key?: string;
		value?: string;
	} & Record<Exclude<keyof I, keyof Attribute>, never>>(object: I): Attribute;
};
declare const GasInfo: {
	encode(message: GasInfo, writer?: _m0.Writer): _m0.Writer;
	decode(input: _m0.Reader | Uint8Array, length?: number): GasInfo;
	fromJSON(object: any): GasInfo;
	toJSON(message: GasInfo): unknown;
	fromPartial<I extends {
		gasWanted?: string | number | Long.Long;
		gasUsed?: string | number | Long.Long;
	} & {
		gasWanted?: string | number | (Long.Long & {
			high: number;
			low: number;
			unsigned: boolean;
			add: (addend: string | number | Long.Long) => Long.Long;
			and: (other: string | number | Long.Long) => Long.Long;
			compare: (other: string | number | Long.Long) => number;
			comp: (other: string | number | Long.Long) => number;
			divide: (divisor: string | number | Long.Long) => Long.Long;
			div: (divisor: string | number | Long.Long) => Long.Long;
			equals: (other: string | number | Long.Long) => boolean;
			eq: (other: string | number | Long.Long) => boolean;
			getHighBits: () => number;
			getHighBitsUnsigned: () => number;
			getLowBits: () => number;
			getLowBitsUnsigned: () => number;
			getNumBitsAbs: () => number;
			greaterThan: (other: string | number | Long.Long) => boolean;
			gt: (other: string | number | Long.Long) => boolean;
			greaterThanOrEqual: (other: string | number | Long.Long) => boolean;
			gte: (other: string | number | Long.Long) => boolean;
			isEven: () => boolean;
			isNegative: () => boolean;
			isOdd: () => boolean;
			isPositive: () => boolean;
			isZero: () => boolean;
			lessThan: (other: string | number | Long.Long) => boolean;
			lt: (other: string | number | Long.Long) => boolean;
			lessThanOrEqual: (other: string | number | Long.Long) => boolean;
			lte: (other: string | number | Long.Long) => boolean;
			modulo: (other: string | number | Long.Long) => Long.Long;
			mod: (other: string | number | Long.Long) => Long.Long;
			multiply: (multiplier: string | number | Long.Long) => Long.Long;
			mul: (multiplier: string | number | Long.Long) => Long.Long;
			negate: () => Long.Long;
			neg: () => Long.Long;
			not: () => Long.Long;
			notEquals: (other: string | number | Long.Long) => boolean;
			neq: (other: string | number | Long.Long) => boolean;
			or: (other: string | number | Long.Long) => Long.Long;
			shiftLeft: (numBits: number | Long.Long) => Long.Long;
			shl: (numBits: number | Long.Long) => Long.Long;
			shiftRight: (numBits: number | Long.Long) => Long.Long;
			shr: (numBits: number | Long.Long) => Long.Long;
			shiftRightUnsigned: (numBits: number | Long.Long) => Long.Long;
			shru: (numBits: number | Long.Long) => Long.Long;
			subtract: (subtrahend: string | number | Long.Long) => Long.Long;
			sub: (subtrahend: string | number | Long.Long) => Long.Long;
			toInt: () => number;
			toNumber: () => number;
			toBytes: (le?: boolean) => number[];
			toBytesLE: () => number[];
			toBytesBE: () => number[];
			toSigned: () => Long.Long;
			toString: (radix?: number) => string;
			toUnsigned: () => Long.Long;
			xor: (other: string | number | Long.Long) => Long.Long;
		} & Record<Exclude<keyof I["gasWanted"], keyof Long.Long>, never>);
		gasUsed?: string | number | (Long.Long & {
			high: number;
			low: number;
			unsigned: boolean;
			add: (addend: string | number | Long.Long) => Long.Long;
			and: (other: string | number | Long.Long) => Long.Long;
			compare: (other: string | number | Long.Long) => number;
			comp: (other: string | number | Long.Long) => number;
			divide: (divisor: string | number | Long.Long) => Long.Long;
			div: (divisor: string | number | Long.Long) => Long.Long;
			equals: (other: string | number | Long.Long) => boolean;
			eq: (other: string | number | Long.Long) => boolean;
			getHighBits: () => number;
			getHighBitsUnsigned: () => number;
			getLowBits: () => number;
			getLowBitsUnsigned: () => number;
			getNumBitsAbs: () => number;
			greaterThan: (other: string | number | Long.Long) => boolean;
			gt: (other: string | number | Long.Long) => boolean;
			greaterThanOrEqual: (other: string | number | Long.Long) => boolean;
			gte: (other: string | number | Long.Long) => boolean;
			isEven: () => boolean;
			isNegative: () => boolean;
			isOdd: () => boolean;
			isPositive: () => boolean;
			isZero: () => boolean;
			lessThan: (other: string | number | Long.Long) => boolean;
			lt: (other: string | number | Long.Long) => boolean;
			lessThanOrEqual: (other: string | number | Long.Long) => boolean;
			lte: (other: string | number | Long.Long) => boolean;
			modulo: (other: string | number | Long.Long) => Long.Long;
			mod: (other: string | number | Long.Long) => Long.Long;
			multiply: (multiplier: string | number | Long.Long) => Long.Long;
			mul: (multiplier: string | number | Long.Long) => Long.Long;
			negate: () => Long.Long;
			neg: () => Long.Long;
			not: () => Long.Long;
			notEquals: (other: string | number | Long.Long) => boolean;
			neq: (other: string | number | Long.Long) => boolean;
			or: (other: string | number | Long.Long) => Long.Long;
			shiftLeft: (numBits: number | Long.Long) => Long.Long;
			shl: (numBits: number | Long.Long) => Long.Long;
			shiftRight: (numBits: number | Long.Long) => Long.Long;
			shr: (numBits: number | Long.Long) => Long.Long;
			shiftRightUnsigned: (numBits: number | Long.Long) => Long.Long;
			shru: (numBits: number | Long.Long) => Long.Long;
			subtract: (subtrahend: string | number | Long.Long) => Long.Long;
			sub: (subtrahend: string | number | Long.Long) => Long.Long;
			toInt: () => number;
			toNumber: () => number;
			toBytes: (le?: boolean) => number[];
			toBytesLE: () => number[];
			toBytesBE: () => number[];
			toSigned: () => Long.Long;
			toString: (radix?: number) => string;
			toUnsigned: () => Long.Long;
			xor: (other: string | number | Long.Long) => Long.Long;
		} & Record<Exclude<keyof I["gasUsed"], keyof Long.Long>, never>);
	} & Record<Exclude<keyof I, keyof GasInfo>, never>>(object: I): GasInfo;
};
declare const Result: {
	encode(message: Result, writer?: _m0.Writer): _m0.Writer;
	decode(input: _m0.Reader | Uint8Array, length?: number): Result;
	fromJSON(object: any): Result;
	toJSON(message: Result): unknown;
	fromPartial<I extends {
		data?: Uint8Array;
		log?: string;
		events?: {
			type?: string;
			attributes?: {
				key?: Uint8Array;
				value?: Uint8Array;
				index?: boolean;
			}[];
		}[];
	} & {
		data?: Uint8Array;
		log?: string;
		events?: {
			type?: string;
			attributes?: {
				key?: Uint8Array;
				value?: Uint8Array;
				index?: boolean;
			}[];
		}[] & ({
			type?: string;
			attributes?: {
				key?: Uint8Array;
				value?: Uint8Array;
				index?: boolean;
			}[];
		} & {
			type?: string;
			attributes?: {
				key?: Uint8Array;
				value?: Uint8Array;
				index?: boolean;
			}[] & ({
				key?: Uint8Array;
				value?: Uint8Array;
				index?: boolean;
			} & {
				key?: Uint8Array;
				value?: Uint8Array;
				index?: boolean;
			} & Record<Exclude<keyof I["events"][number]["attributes"][number], keyof EventAttribute>, never>)[] & Record<Exclude<keyof I["events"][number]["attributes"], keyof {
				key?: Uint8Array;
				value?: Uint8Array;
				index?: boolean;
			}[]>, never>;
		} & Record<Exclude<keyof I["events"][number], keyof Event>, never>)[] & Record<Exclude<keyof I["events"], keyof {
			type?: string;
			attributes?: {
				key?: Uint8Array;
				value?: Uint8Array;
				index?: boolean;
			}[];
		}[]>, never>;
	} & Record<Exclude<keyof I, keyof Result>, never>>(object: I): Result;
};
/**
 * CompactBitArray is an implementation of a space efficient bit array.
 * This is used to ensure that the encoded data takes up a minimal amount of
 * space after proto encoding.
 * This is not thread safe, and is not intended for concurrent usage.
 */
export interface CompactBitArray {
	extraBitsStored: number;
	elems: Uint8Array;
}
declare const CompactBitArray: {
	encode(message: CompactBitArray, writer?: _m0.Writer): _m0.Writer;
	decode(input: _m0.Reader | Uint8Array, length?: number): CompactBitArray;
	fromJSON(object: any): CompactBitArray;
	toJSON(message: CompactBitArray): unknown;
	fromPartial<I extends {
		extraBitsStored?: number;
		elems?: Uint8Array;
	} & {
		extraBitsStored?: number;
		elems?: Uint8Array;
	} & Record<Exclude<keyof I, keyof CompactBitArray>, never>>(object: I): CompactBitArray;
};
declare enum SignMode {
	/**
	 * SIGN_MODE_UNSPECIFIED - SIGN_MODE_UNSPECIFIED specifies an unknown signing mode and will be
	 * rejected
	 */
	SIGN_MODE_UNSPECIFIED = 0,
	/**
	 * SIGN_MODE_DIRECT - SIGN_MODE_DIRECT specifies a signing mode which uses SignDoc and is
	 * verified with raw bytes from Tx
	 */
	SIGN_MODE_DIRECT = 1,
	/**
	 * SIGN_MODE_TEXTUAL - SIGN_MODE_TEXTUAL is a future signing mode that will verify some
	 * human-readable textual representation on top of the binary representation
	 * from SIGN_MODE_DIRECT
	 */
	SIGN_MODE_TEXTUAL = 2,
	/**
	 * SIGN_MODE_LEGACY_AMINO_JSON - SIGN_MODE_LEGACY_AMINO_JSON is a backwards compatibility mode which uses
	 * Amino JSON and will be removed in the future
	 */
	SIGN_MODE_LEGACY_AMINO_JSON = 127,
	UNRECOGNIZED = -1
}
/** Tx is the standard type used for broadcasting transactions. */
export interface Tx {
	/** body is the processable content of the transaction */
	body?: TxBody;
	/**
	 * auth_info is the authorization related content of the transaction,
	 * specifically signers, signer modes and fee
	 */
	authInfo?: AuthInfo;
	/**
	 * signatures is a list of signatures that matches the length and order of
	 * AuthInfo's signer_infos to allow connecting signature meta information like
	 * public key and signing mode by position.
	 */
	signatures: Uint8Array[];
}
/** TxBody is the body of a transaction that all signers sign over. */
export interface TxBody {
	/**
	 * messages is a list of messages to be executed. The required signers of
	 * those messages define the number and order of elements in AuthInfo's
	 * signer_infos and Tx's signatures. Each required signer address is added to
	 * the list only the first time it occurs.
	 * By convention, the first required signer (usually from the first message)
	 * is referred to as the primary signer and pays the fee for the whole
	 * transaction.
	 */
	messages: Any[];
	/**
	 * memo is any arbitrary note/comment to be added to the transaction.
	 * WARNING: in clients, any publicly exposed text should not be called memo,
	 * but should be called `note` instead (see https://github.com/cosmos/cosmos-sdk/issues/9122).
	 */
	memo: string;
	/**
	 * timeout is the block height after which this transaction will not
	 * be processed by the chain
	 */
	timeoutHeight: Long;
	/**
	 * extension_options are arbitrary options that can be added by chains
	 * when the default options are not sufficient. If any of these are present
	 * and can't be handled, the transaction will be rejected
	 */
	extensionOptions: Any[];
	/**
	 * extension_options are arbitrary options that can be added by chains
	 * when the default options are not sufficient. If any of these are present
	 * and can't be handled, they will be ignored
	 */
	nonCriticalExtensionOptions: Any[];
}
/**
 * AuthInfo describes the fee and signer modes that are used to sign a
 * transaction.
 */
export interface AuthInfo {
	/**
	 * signer_infos defines the signing modes for the required signers. The number
	 * and order of elements must match the required signers from TxBody's
	 * messages. The first element is the primary signer and the one which pays
	 * the fee.
	 */
	signerInfos: SignerInfo[];
	/**
	 * Fee is the fee and gas limit for the transaction. The first signer is the
	 * primary signer and the one which pays the fee. The fee can be calculated
	 * based on the cost of evaluating the body and doing signature verification
	 * of the signers. This can be estimated via simulation.
	 */
	fee?: Fee;
}
/**
 * SignerInfo describes the public key and signing mode of a single top-level
 * signer.
 */
export interface SignerInfo {
	/**
	 * public_key is the public key of the signer. It is optional for accounts
	 * that already exist in state. If unset, the verifier can use the required \
	 * signer address for this position and lookup the public key.
	 */
	publicKey?: Any;
	/**
	 * mode_info describes the signing mode of the signer and is a nested
	 * structure to support nested multisig pubkey's
	 */
	modeInfo?: ModeInfo;
	/**
	 * sequence is the sequence of the account, which describes the
	 * number of committed transactions signed by a given address. It is used to
	 * prevent replay attacks.
	 */
	sequence: Long;
}
/** ModeInfo describes the signing mode of a single or nested multisig signer. */
export interface ModeInfo {
	/** single represents a single signer */
	single?: ModeInfo_Single | undefined;
	/** multi represents a nested multisig signer */
	multi?: ModeInfo_Multi | undefined;
}
/**
 * Single is the mode info for a single signer. It is structured as a message
 * to allow for additional fields such as locale for SIGN_MODE_TEXTUAL in the
 * future
 */
export interface ModeInfo_Single {
	/** mode is the signing mode of the single signer */
	mode: SignMode;
}
/** Multi is the mode info for a multisig public key */
export interface ModeInfo_Multi {
	/** bitarray specifies which keys within the multisig are signing */
	bitarray?: CompactBitArray;
	/**
	 * mode_infos is the corresponding modes of the signers of the multisig
	 * which could include nested multisig public keys
	 */
	modeInfos: ModeInfo[];
}
/**
 * Fee includes the amount of coins paid in fees and the maximum
 * gas to be used by the transaction. The ratio yields an effective "gasprice",
 * which must be above some miminum to be accepted into the mempool.
 */
export interface Fee {
	/** amount is the amount of coins to be paid as a fee */
	amount: Coin[];
	/**
	 * gas_limit is the maximum gas that can be used in transaction processing
	 * before an out of gas error occurs
	 */
	gasLimit: Long;
	/**
	 * if unset, the first signer is responsible for paying the fees. If set, the specified account must pay the fees.
	 * the payer must be a tx signer (and thus have signed this field in AuthInfo).
	 * setting this field does *not* change the ordering of required signers for the transaction.
	 */
	payer: string;
	/**
	 * if set, the fee payer (either the first signer or the value of the payer field) requests that a fee grant be used
	 * to pay fees instead of the fee payer's own balance. If an appropriate fee grant does not exist or the chain does
	 * not support fee grants, this will fail
	 */
	granter: string;
}
declare const Tx: {
	encode(message: Tx, writer?: _m0.Writer): _m0.Writer;
	decode(input: _m0.Reader | Uint8Array, length?: number): Tx;
	fromJSON(object: any): Tx;
	toJSON(message: Tx): unknown;
	fromPartial<I extends {
		body?: {
			messages?: {
				typeUrl?: string;
				value?: Uint8Array;
			}[];
			memo?: string;
			timeoutHeight?: string | number | Long.Long;
			extensionOptions?: {
				typeUrl?: string;
				value?: Uint8Array;
			}[];
			nonCriticalExtensionOptions?: {
				typeUrl?: string;
				value?: Uint8Array;
			}[];
		};
		authInfo?: {
			signerInfos?: {
				publicKey?: {
					typeUrl?: string;
					value?: Uint8Array;
				};
				modeInfo?: {
					single?: {
						mode?: SignMode;
					};
					multi?: {
						bitarray?: {
							extraBitsStored?: number;
							elems?: Uint8Array;
						};
						modeInfos?: any[];
					};
				};
				sequence?: string | number | Long.Long;
			}[];
			fee?: {
				amount?: {
					denom?: string;
					amount?: string;
				}[];
				gasLimit?: string | number | Long.Long;
				payer?: string;
				granter?: string;
			};
		};
		signatures?: Uint8Array[];
	} & {
		body?: {
			messages?: {
				typeUrl?: string;
				value?: Uint8Array;
			}[];
			memo?: string;
			timeoutHeight?: string | number | Long.Long;
			extensionOptions?: {
				typeUrl?: string;
				value?: Uint8Array;
			}[];
			nonCriticalExtensionOptions?: {
				typeUrl?: string;
				value?: Uint8Array;
			}[];
		} & {
			messages?: {
				typeUrl?: string;
				value?: Uint8Array;
			}[] & ({
				typeUrl?: string;
				value?: Uint8Array;
			} & {
				typeUrl?: string;
				value?: Uint8Array;
			} & Record<Exclude<keyof I["body"]["messages"][number], keyof Any>, never>)[] & Record<Exclude<keyof I["body"]["messages"], keyof {
				typeUrl?: string;
				value?: Uint8Array;
			}[]>, never>;
			memo?: string;
			timeoutHeight?: string | number | (Long.Long & {
				high: number;
				low: number;
				unsigned: boolean;
				add: (addend: string | number | Long.Long) => Long.Long;
				and: (other: string | number | Long.Long) => Long.Long;
				compare: (other: string | number | Long.Long) => number;
				comp: (other: string | number | Long.Long) => number;
				divide: (divisor: string | number | Long.Long) => Long.Long;
				div: (divisor: string | number | Long.Long) => Long.Long;
				equals: (other: string | number | Long.Long) => boolean;
				eq: (other: string | number | Long.Long) => boolean;
				getHighBits: () => number;
				getHighBitsUnsigned: () => number;
				getLowBits: () => number;
				getLowBitsUnsigned: () => number;
				getNumBitsAbs: () => number;
				greaterThan: (other: string | number | Long.Long) => boolean;
				gt: (other: string | number | Long.Long) => boolean;
				greaterThanOrEqual: (other: string | number | Long.Long) => boolean;
				gte: (other: string | number | Long.Long) => boolean;
				isEven: () => boolean;
				isNegative: () => boolean;
				isOdd: () => boolean;
				isPositive: () => boolean;
				isZero: () => boolean;
				lessThan: (other: string | number | Long.Long) => boolean;
				lt: (other: string | number | Long.Long) => boolean;
				lessThanOrEqual: (other: string | number | Long.Long) => boolean;
				lte: (other: string | number | Long.Long) => boolean;
				modulo: (other: string | number | Long.Long) => Long.Long;
				mod: (other: string | number | Long.Long) => Long.Long;
				multiply: (multiplier: string | number | Long.Long) => Long.Long;
				mul: (multiplier: string | number | Long.Long) => Long.Long;
				negate: () => Long.Long;
				neg: () => Long.Long;
				not: () => Long.Long;
				notEquals: (other: string | number | Long.Long) => boolean;
				neq: (other: string | number | Long.Long) => boolean;
				or: (other: string | number | Long.Long) => Long.Long;
				shiftLeft: (numBits: number | Long.Long) => Long.Long;
				shl: (numBits: number | Long.Long) => Long.Long;
				shiftRight: (numBits: number | Long.Long) => Long.Long;
				shr: (numBits: number | Long.Long) => Long.Long;
				shiftRightUnsigned: (numBits: number | Long.Long) => Long.Long;
				shru: (numBits: number | Long.Long) => Long.Long;
				subtract: (subtrahend: string | number | Long.Long) => Long.Long;
				sub: (subtrahend: string | number | Long.Long) => Long.Long;
				toInt: () => number;
				toNumber: () => number;
				toBytes: (le?: boolean) => number[];
				toBytesLE: () => number[];
				toBytesBE: () => number[];
				toSigned: () => Long.Long;
				toString: (radix?: number) => string;
				toUnsigned: () => Long.Long;
				xor: (other: string | number | Long.Long) => Long.Long;
			} & Record<Exclude<keyof I["body"]["timeoutHeight"], keyof Long.Long>, never>);
			extensionOptions?: {
				typeUrl?: string;
				value?: Uint8Array;
			}[] & ({
				typeUrl?: string;
				value?: Uint8Array;
			} & {
				typeUrl?: string;
				value?: Uint8Array;
			} & Record<Exclude<keyof I["body"]["extensionOptions"][number], keyof Any>, never>)[] & Record<Exclude<keyof I["body"]["extensionOptions"], keyof {
				typeUrl?: string;
				value?: Uint8Array;
			}[]>, never>;
			nonCriticalExtensionOptions?: {
				typeUrl?: string;
				value?: Uint8Array;
			}[] & ({
				typeUrl?: string;
				value?: Uint8Array;
			} & {
				typeUrl?: string;
				value?: Uint8Array;
			} & Record<Exclude<keyof I["body"]["nonCriticalExtensionOptions"][number], keyof Any>, never>)[] & Record<Exclude<keyof I["body"]["nonCriticalExtensionOptions"], keyof {
				typeUrl?: string;
				value?: Uint8Array;
			}[]>, never>;
		} & Record<Exclude<keyof I["body"], keyof TxBody>, never>;
		authInfo?: {
			signerInfos?: {
				publicKey?: {
					typeUrl?: string;
					value?: Uint8Array;
				};
				modeInfo?: {
					single?: {
						mode?: SignMode;
					};
					multi?: {
						bitarray?: {
							extraBitsStored?: number;
							elems?: Uint8Array;
						};
						modeInfos?: any[];
					};
				};
				sequence?: string | number | Long.Long;
			}[];
			fee?: {
				amount?: {
					denom?: string;
					amount?: string;
				}[];
				gasLimit?: string | number | Long.Long;
				payer?: string;
				granter?: string;
			};
		} & {
			signerInfos?: {
				publicKey?: {
					typeUrl?: string;
					value?: Uint8Array;
				};
				modeInfo?: {
					single?: {
						mode?: SignMode;
					};
					multi?: {
						bitarray?: {
							extraBitsStored?: number;
							elems?: Uint8Array;
						};
						modeInfos?: any[];
					};
				};
				sequence?: string | number | Long.Long;
			}[] & ({
				publicKey?: {
					typeUrl?: string;
					value?: Uint8Array;
				};
				modeInfo?: {
					single?: {
						mode?: SignMode;
					};
					multi?: {
						bitarray?: {
							extraBitsStored?: number;
							elems?: Uint8Array;
						};
						modeInfos?: any[];
					};
				};
				sequence?: string | number | Long.Long;
			} & {
				publicKey?: {
					typeUrl?: string;
					value?: Uint8Array;
				} & {
					typeUrl?: string;
					value?: Uint8Array;
				} & Record<Exclude<keyof I["authInfo"]["signerInfos"][number]["publicKey"], keyof Any>, never>;
				modeInfo?: {
					single?: {
						mode?: SignMode;
					};
					multi?: {
						bitarray?: {
							extraBitsStored?: number;
							elems?: Uint8Array;
						};
						modeInfos?: any[];
					};
				} & {
					single?: {
						mode?: SignMode;
					} & {
						mode?: SignMode;
					} & Record<Exclude<keyof I["authInfo"]["signerInfos"][number]["modeInfo"]["single"], "mode">, never>;
					multi?: {
						bitarray?: {
							extraBitsStored?: number;
							elems?: Uint8Array;
						};
						modeInfos?: any[];
					} & {
						bitarray?: {
							extraBitsStored?: number;
							elems?: Uint8Array;
						} & {
							extraBitsStored?: number;
							elems?: Uint8Array;
						} & Record<Exclude<keyof I["authInfo"]["signerInfos"][number]["modeInfo"]["multi"]["bitarray"], keyof CompactBitArray>, never>;
						modeInfos?: any[] & ({
							single?: {
								mode?: SignMode;
							};
							multi?: {
								bitarray?: {
									extraBitsStored?: number;
									elems?: Uint8Array;
								};
								modeInfos?: any[];
							};
						} & {
							single?: {
								mode?: SignMode;
							} & {
								mode?: SignMode;
							} & Record<Exclude<keyof I["authInfo"]["signerInfos"][number]["modeInfo"]["multi"]["modeInfos"][number]["single"], "mode">, never>;
							multi?: {
								bitarray?: {
									extraBitsStored?: number;
									elems?: Uint8Array;
								};
								modeInfos?: any[];
							} & {
								bitarray?: {
									extraBitsStored?: number;
									elems?: Uint8Array;
								} & {
									extraBitsStored?: number;
									elems?: Uint8Array;
								} & Record<Exclude<keyof I["authInfo"]["signerInfos"][number]["modeInfo"]["multi"]["modeInfos"][number]["multi"]["bitarray"], keyof CompactBitArray>, never>;
								modeInfos?: any[] & ({
									single?: {
										mode?: SignMode;
									};
									multi?: {
										bitarray?: {
											extraBitsStored?: number;
											elems?: Uint8Array;
										};
										modeInfos?: any[];
									};
								} & {
									single?: {
										mode?: SignMode;
									} & {
										mode?: SignMode;
									} & Record<Exclude<keyof I["authInfo"]["signerInfos"][number]["modeInfo"]["multi"]["modeInfos"][number]["multi"]["modeInfos"][number]["single"], "mode">, never>;
									multi?: {
										bitarray?: {
											extraBitsStored?: number;
											elems?: Uint8Array;
										};
										modeInfos?: any[];
									} & {
										bitarray?: {
											extraBitsStored?: number;
											elems?: Uint8Array;
										} & {
											extraBitsStored?: number;
											elems?: Uint8Array;
										} & Record<Exclude<keyof I["authInfo"]["signerInfos"][number]["modeInfo"]["multi"]["modeInfos"][number]["multi"]["modeInfos"][number]["multi"]["bitarray"], keyof CompactBitArray>, never>;
										modeInfos?: any[] & ({
											single?: {
												mode?: SignMode;
											};
											multi?: {
												bitarray?: {
													extraBitsStored?: number;
													elems?: Uint8Array;
												};
												modeInfos?: any[];
											};
										} & {
											single?: {
												mode?: SignMode;
											} & {
												mode?: SignMode;
											} & Record<Exclude<keyof I["authInfo"]["signerInfos"][number]["modeInfo"]["multi"]["modeInfos"][number]["multi"]["modeInfos"][number]["multi"]["modeInfos"][number]["single"], "mode">, never>;
											multi?: {
												bitarray?: {
													extraBitsStored?: number;
													elems?: Uint8Array;
												};
												modeInfos?: any[];
											} & {
												bitarray?: {
													extraBitsStored?: number;
													elems?: Uint8Array;
												} & any & Record<Exclude<keyof I["authInfo"]["signerInfos"][number]["modeInfo"]["multi"]["modeInfos"][number]["multi"]["modeInfos"][number]["multi"]["modeInfos"][number]["multi"]["bitarray"], keyof CompactBitArray>, never>;
												modeInfos?: any[] & ({
													single?: {
														mode?: SignMode;
													};
													multi?: {
														bitarray?: {
															extraBitsStored?: number;
															elems?: Uint8Array;
														};
														modeInfos?: any[];
													};
												} & any & Record<Exclude<keyof I["authInfo"]["signerInfos"][number]["modeInfo"]["multi"]["modeInfos"][number]["multi"]["modeInfos"][number]["multi"]["modeInfos"][number]["multi"]["modeInfos"][number], keyof ModeInfo>, never>)[] & Record<Exclude<keyof I["authInfo"]["signerInfos"][number]["modeInfo"]["multi"]["modeInfos"][number]["multi"]["modeInfos"][number]["multi"]["modeInfos"][number]["multi"]["modeInfos"], keyof any[]>, never>;
											} & Record<Exclude<keyof I["authInfo"]["signerInfos"][number]["modeInfo"]["multi"]["modeInfos"][number]["multi"]["modeInfos"][number]["multi"]["modeInfos"][number]["multi"], keyof ModeInfo_Multi>, never>;
										} & Record<Exclude<keyof I["authInfo"]["signerInfos"][number]["modeInfo"]["multi"]["modeInfos"][number]["multi"]["modeInfos"][number]["multi"]["modeInfos"][number], keyof ModeInfo>, never>)[] & Record<Exclude<keyof I["authInfo"]["signerInfos"][number]["modeInfo"]["multi"]["modeInfos"][number]["multi"]["modeInfos"][number]["multi"]["modeInfos"], keyof any[]>, never>;
									} & Record<Exclude<keyof I["authInfo"]["signerInfos"][number]["modeInfo"]["multi"]["modeInfos"][number]["multi"]["modeInfos"][number]["multi"], keyof ModeInfo_Multi>, never>;
								} & Record<Exclude<keyof I["authInfo"]["signerInfos"][number]["modeInfo"]["multi"]["modeInfos"][number]["multi"]["modeInfos"][number], keyof ModeInfo>, never>)[] & Record<Exclude<keyof I["authInfo"]["signerInfos"][number]["modeInfo"]["multi"]["modeInfos"][number]["multi"]["modeInfos"], keyof any[]>, never>;
							} & Record<Exclude<keyof I["authInfo"]["signerInfos"][number]["modeInfo"]["multi"]["modeInfos"][number]["multi"], keyof ModeInfo_Multi>, never>;
						} & Record<Exclude<keyof I["authInfo"]["signerInfos"][number]["modeInfo"]["multi"]["modeInfos"][number], keyof ModeInfo>, never>)[] & Record<Exclude<keyof I["authInfo"]["signerInfos"][number]["modeInfo"]["multi"]["modeInfos"], keyof any[]>, never>;
					} & Record<Exclude<keyof I["authInfo"]["signerInfos"][number]["modeInfo"]["multi"], keyof ModeInfo_Multi>, never>;
				} & Record<Exclude<keyof I["authInfo"]["signerInfos"][number]["modeInfo"], keyof ModeInfo>, never>;
				sequence?: string | number | (Long.Long & {
					high: number;
					low: number;
					unsigned: boolean;
					add: (addend: string | number | Long.Long) => Long.Long;
					and: (other: string | number | Long.Long) => Long.Long;
					compare: (other: string | number | Long.Long) => number;
					comp: (other: string | number | Long.Long) => number;
					divide: (divisor: string | number | Long.Long) => Long.Long;
					div: (divisor: string | number | Long.Long) => Long.Long;
					equals: (other: string | number | Long.Long) => boolean;
					eq: (other: string | number | Long.Long) => boolean;
					getHighBits: () => number;
					getHighBitsUnsigned: () => number;
					getLowBits: () => number;
					getLowBitsUnsigned: () => number;
					getNumBitsAbs: () => number;
					greaterThan: (other: string | number | Long.Long) => boolean;
					gt: (other: string | number | Long.Long) => boolean;
					greaterThanOrEqual: (other: string | number | Long.Long) => boolean;
					gte: (other: string | number | Long.Long) => boolean;
					isEven: () => boolean;
					isNegative: () => boolean;
					isOdd: () => boolean;
					isPositive: () => boolean;
					isZero: () => boolean;
					lessThan: (other: string | number | Long.Long) => boolean;
					lt: (other: string | number | Long.Long) => boolean;
					lessThanOrEqual: (other: string | number | Long.Long) => boolean;
					lte: (other: string | number | Long.Long) => boolean;
					modulo: (other: string | number | Long.Long) => Long.Long;
					mod: (other: string | number | Long.Long) => Long.Long;
					multiply: (multiplier: string | number | Long.Long) => Long.Long;
					mul: (multiplier: string | number | Long.Long) => Long.Long;
					negate: () => Long.Long;
					neg: () => Long.Long;
					not: () => Long.Long;
					notEquals: (other: string | number | Long.Long) => boolean;
					neq: (other: string | number | Long.Long) => boolean;
					or: (other: string | number | Long.Long) => Long.Long;
					shiftLeft: (numBits: number | Long.Long) => Long.Long;
					shl: (numBits: number | Long.Long) => Long.Long;
					shiftRight: (numBits: number | Long.Long) => Long.Long;
					shr: (numBits: number | Long.Long) => Long.Long;
					shiftRightUnsigned: (numBits: number | Long.Long) => Long.Long;
					shru: (numBits: number | Long.Long) => Long.Long;
					subtract: (subtrahend: string | number | Long.Long) => Long.Long;
					sub: (subtrahend: string | number | Long.Long) => Long.Long;
					toInt: () => number;
					toNumber: () => number;
					toBytes: (le?: boolean) => number[];
					toBytesLE: () => number[];
					toBytesBE: () => number[];
					toSigned: () => Long.Long;
					toString: (radix?: number) => string;
					toUnsigned: () => Long.Long;
					xor: (other: string | number | Long.Long) => Long.Long;
				} & Record<Exclude<keyof I["authInfo"]["signerInfos"][number]["sequence"], keyof Long.Long>, never>);
			} & Record<Exclude<keyof I["authInfo"]["signerInfos"][number], keyof SignerInfo>, never>)[] & Record<Exclude<keyof I["authInfo"]["signerInfos"], keyof {
				publicKey?: {
					typeUrl?: string;
					value?: Uint8Array;
				};
				modeInfo?: {
					single?: {
						mode?: SignMode;
					};
					multi?: {
						bitarray?: {
							extraBitsStored?: number;
							elems?: Uint8Array;
						};
						modeInfos?: any[];
					};
				};
				sequence?: string | number | Long.Long;
			}[]>, never>;
			fee?: {
				amount?: {
					denom?: string;
					amount?: string;
				}[];
				gasLimit?: string | number | Long.Long;
				payer?: string;
				granter?: string;
			} & {
				amount?: {
					denom?: string;
					amount?: string;
				}[] & ({
					denom?: string;
					amount?: string;
				} & {
					denom?: string;
					amount?: string;
				} & Record<Exclude<keyof I["authInfo"]["fee"]["amount"][number], keyof Coin>, never>)[] & Record<Exclude<keyof I["authInfo"]["fee"]["amount"], keyof {
					denom?: string;
					amount?: string;
				}[]>, never>;
				gasLimit?: string | number | (Long.Long & {
					high: number;
					low: number;
					unsigned: boolean;
					add: (addend: string | number | Long.Long) => Long.Long;
					and: (other: string | number | Long.Long) => Long.Long;
					compare: (other: string | number | Long.Long) => number;
					comp: (other: string | number | Long.Long) => number;
					divide: (divisor: string | number | Long.Long) => Long.Long;
					div: (divisor: string | number | Long.Long) => Long.Long;
					equals: (other: string | number | Long.Long) => boolean;
					eq: (other: string | number | Long.Long) => boolean;
					getHighBits: () => number;
					getHighBitsUnsigned: () => number;
					getLowBits: () => number;
					getLowBitsUnsigned: () => number;
					getNumBitsAbs: () => number;
					greaterThan: (other: string | number | Long.Long) => boolean;
					gt: (other: string | number | Long.Long) => boolean;
					greaterThanOrEqual: (other: string | number | Long.Long) => boolean;
					gte: (other: string | number | Long.Long) => boolean;
					isEven: () => boolean;
					isNegative: () => boolean;
					isOdd: () => boolean;
					isPositive: () => boolean;
					isZero: () => boolean;
					lessThan: (other: string | number | Long.Long) => boolean;
					lt: (other: string | number | Long.Long) => boolean;
					lessThanOrEqual: (other: string | number | Long.Long) => boolean;
					lte: (other: string | number | Long.Long) => boolean;
					modulo: (other: string | number | Long.Long) => Long.Long;
					mod: (other: string | number | Long.Long) => Long.Long;
					multiply: (multiplier: string | number | Long.Long) => Long.Long;
					mul: (multiplier: string | number | Long.Long) => Long.Long;
					negate: () => Long.Long;
					neg: () => Long.Long;
					not: () => Long.Long;
					notEquals: (other: string | number | Long.Long) => boolean;
					neq: (other: string | number | Long.Long) => boolean;
					or: (other: string | number | Long.Long) => Long.Long;
					shiftLeft: (numBits: number | Long.Long) => Long.Long;
					shl: (numBits: number | Long.Long) => Long.Long;
					shiftRight: (numBits: number | Long.Long) => Long.Long;
					shr: (numBits: number | Long.Long) => Long.Long;
					shiftRightUnsigned: (numBits: number | Long.Long) => Long.Long;
					shru: (numBits: number | Long.Long) => Long.Long;
					subtract: (subtrahend: string | number | Long.Long) => Long.Long;
					sub: (subtrahend: string | number | Long.Long) => Long.Long;
					toInt: () => number;
					toNumber: () => number;
					toBytes: (le?: boolean) => number[];
					toBytesLE: () => number[];
					toBytesBE: () => number[];
					toSigned: () => Long.Long;
					toString: (radix?: number) => string;
					toUnsigned: () => Long.Long;
					xor: (other: string | number | Long.Long) => Long.Long;
				} & Record<Exclude<keyof I["authInfo"]["fee"]["gasLimit"], keyof Long.Long>, never>);
				payer?: string;
				granter?: string;
			} & Record<Exclude<keyof I["authInfo"]["fee"], keyof Fee>, never>;
		} & Record<Exclude<keyof I["authInfo"], keyof AuthInfo>, never>;
		signatures?: Uint8Array[] & Uint8Array[] & Record<Exclude<keyof I["signatures"], keyof Uint8Array[]>, never>;
	} & Record<Exclude<keyof I, keyof Tx>, never>>(object: I): Tx;
};
declare const TxBody: {
	encode(message: TxBody, writer?: _m0.Writer): _m0.Writer;
	decode(input: _m0.Reader | Uint8Array, length?: number): TxBody;
	fromJSON(object: any): TxBody;
	toJSON(message: TxBody): unknown;
	fromPartial<I extends {
		messages?: {
			typeUrl?: string;
			value?: Uint8Array;
		}[];
		memo?: string;
		timeoutHeight?: string | number | Long.Long;
		extensionOptions?: {
			typeUrl?: string;
			value?: Uint8Array;
		}[];
		nonCriticalExtensionOptions?: {
			typeUrl?: string;
			value?: Uint8Array;
		}[];
	} & {
		messages?: {
			typeUrl?: string;
			value?: Uint8Array;
		}[] & ({
			typeUrl?: string;
			value?: Uint8Array;
		} & {
			typeUrl?: string;
			value?: Uint8Array;
		} & Record<Exclude<keyof I["messages"][number], keyof Any>, never>)[] & Record<Exclude<keyof I["messages"], keyof {
			typeUrl?: string;
			value?: Uint8Array;
		}[]>, never>;
		memo?: string;
		timeoutHeight?: string | number | (Long.Long & {
			high: number;
			low: number;
			unsigned: boolean;
			add: (addend: string | number | Long.Long) => Long.Long;
			and: (other: string | number | Long.Long) => Long.Long;
			compare: (other: string | number | Long.Long) => number;
			comp: (other: string | number | Long.Long) => number;
			divide: (divisor: string | number | Long.Long) => Long.Long;
			div: (divisor: string | number | Long.Long) => Long.Long;
			equals: (other: string | number | Long.Long) => boolean;
			eq: (other: string | number | Long.Long) => boolean;
			getHighBits: () => number;
			getHighBitsUnsigned: () => number;
			getLowBits: () => number;
			getLowBitsUnsigned: () => number;
			getNumBitsAbs: () => number;
			greaterThan: (other: string | number | Long.Long) => boolean;
			gt: (other: string | number | Long.Long) => boolean;
			greaterThanOrEqual: (other: string | number | Long.Long) => boolean;
			gte: (other: string | number | Long.Long) => boolean;
			isEven: () => boolean;
			isNegative: () => boolean;
			isOdd: () => boolean;
			isPositive: () => boolean;
			isZero: () => boolean;
			lessThan: (other: string | number | Long.Long) => boolean;
			lt: (other: string | number | Long.Long) => boolean;
			lessThanOrEqual: (other: string | number | Long.Long) => boolean;
			lte: (other: string | number | Long.Long) => boolean;
			modulo: (other: string | number | Long.Long) => Long.Long;
			mod: (other: string | number | Long.Long) => Long.Long;
			multiply: (multiplier: string | number | Long.Long) => Long.Long;
			mul: (multiplier: string | number | Long.Long) => Long.Long;
			negate: () => Long.Long;
			neg: () => Long.Long;
			not: () => Long.Long;
			notEquals: (other: string | number | Long.Long) => boolean;
			neq: (other: string | number | Long.Long) => boolean;
			or: (other: string | number | Long.Long) => Long.Long;
			shiftLeft: (numBits: number | Long.Long) => Long.Long;
			shl: (numBits: number | Long.Long) => Long.Long;
			shiftRight: (numBits: number | Long.Long) => Long.Long;
			shr: (numBits: number | Long.Long) => Long.Long;
			shiftRightUnsigned: (numBits: number | Long.Long) => Long.Long;
			shru: (numBits: number | Long.Long) => Long.Long;
			subtract: (subtrahend: string | number | Long.Long) => Long.Long;
			sub: (subtrahend: string | number | Long.Long) => Long.Long;
			toInt: () => number;
			toNumber: () => number;
			toBytes: (le?: boolean) => number[];
			toBytesLE: () => number[];
			toBytesBE: () => number[];
			toSigned: () => Long.Long;
			toString: (radix?: number) => string;
			toUnsigned: () => Long.Long;
			xor: (other: string | number | Long.Long) => Long.Long;
		} & Record<Exclude<keyof I["timeoutHeight"], keyof Long.Long>, never>);
		extensionOptions?: {
			typeUrl?: string;
			value?: Uint8Array;
		}[] & ({
			typeUrl?: string;
			value?: Uint8Array;
		} & {
			typeUrl?: string;
			value?: Uint8Array;
		} & Record<Exclude<keyof I["extensionOptions"][number], keyof Any>, never>)[] & Record<Exclude<keyof I["extensionOptions"], keyof {
			typeUrl?: string;
			value?: Uint8Array;
		}[]>, never>;
		nonCriticalExtensionOptions?: {
			typeUrl?: string;
			value?: Uint8Array;
		}[] & ({
			typeUrl?: string;
			value?: Uint8Array;
		} & {
			typeUrl?: string;
			value?: Uint8Array;
		} & Record<Exclude<keyof I["nonCriticalExtensionOptions"][number], keyof Any>, never>)[] & Record<Exclude<keyof I["nonCriticalExtensionOptions"], keyof {
			typeUrl?: string;
			value?: Uint8Array;
		}[]>, never>;
	} & Record<Exclude<keyof I, keyof TxBody>, never>>(object: I): TxBody;
};
declare const AuthInfo: {
	encode(message: AuthInfo, writer?: _m0.Writer): _m0.Writer;
	decode(input: _m0.Reader | Uint8Array, length?: number): AuthInfo;
	fromJSON(object: any): AuthInfo;
	toJSON(message: AuthInfo): unknown;
	fromPartial<I extends {
		signerInfos?: {
			publicKey?: {
				typeUrl?: string;
				value?: Uint8Array;
			};
			modeInfo?: {
				single?: {
					mode?: SignMode;
				};
				multi?: {
					bitarray?: {
						extraBitsStored?: number;
						elems?: Uint8Array;
					};
					modeInfos?: any[];
				};
			};
			sequence?: string | number | Long.Long;
		}[];
		fee?: {
			amount?: {
				denom?: string;
				amount?: string;
			}[];
			gasLimit?: string | number | Long.Long;
			payer?: string;
			granter?: string;
		};
	} & {
		signerInfos?: {
			publicKey?: {
				typeUrl?: string;
				value?: Uint8Array;
			};
			modeInfo?: {
				single?: {
					mode?: SignMode;
				};
				multi?: {
					bitarray?: {
						extraBitsStored?: number;
						elems?: Uint8Array;
					};
					modeInfos?: any[];
				};
			};
			sequence?: string | number | Long.Long;
		}[] & ({
			publicKey?: {
				typeUrl?: string;
				value?: Uint8Array;
			};
			modeInfo?: {
				single?: {
					mode?: SignMode;
				};
				multi?: {
					bitarray?: {
						extraBitsStored?: number;
						elems?: Uint8Array;
					};
					modeInfos?: any[];
				};
			};
			sequence?: string | number | Long.Long;
		} & {
			publicKey?: {
				typeUrl?: string;
				value?: Uint8Array;
			} & {
				typeUrl?: string;
				value?: Uint8Array;
			} & Record<Exclude<keyof I["signerInfos"][number]["publicKey"], keyof Any>, never>;
			modeInfo?: {
				single?: {
					mode?: SignMode;
				};
				multi?: {
					bitarray?: {
						extraBitsStored?: number;
						elems?: Uint8Array;
					};
					modeInfos?: any[];
				};
			} & {
				single?: {
					mode?: SignMode;
				} & {
					mode?: SignMode;
				} & Record<Exclude<keyof I["signerInfos"][number]["modeInfo"]["single"], "mode">, never>;
				multi?: {
					bitarray?: {
						extraBitsStored?: number;
						elems?: Uint8Array;
					};
					modeInfos?: any[];
				} & {
					bitarray?: {
						extraBitsStored?: number;
						elems?: Uint8Array;
					} & {
						extraBitsStored?: number;
						elems?: Uint8Array;
					} & Record<Exclude<keyof I["signerInfos"][number]["modeInfo"]["multi"]["bitarray"], keyof CompactBitArray>, never>;
					modeInfos?: any[] & ({
						single?: {
							mode?: SignMode;
						};
						multi?: {
							bitarray?: {
								extraBitsStored?: number;
								elems?: Uint8Array;
							};
							modeInfos?: any[];
						};
					} & {
						single?: {
							mode?: SignMode;
						} & {
							mode?: SignMode;
						} & Record<Exclude<keyof I["signerInfos"][number]["modeInfo"]["multi"]["modeInfos"][number]["single"], "mode">, never>;
						multi?: {
							bitarray?: {
								extraBitsStored?: number;
								elems?: Uint8Array;
							};
							modeInfos?: any[];
						} & {
							bitarray?: {
								extraBitsStored?: number;
								elems?: Uint8Array;
							} & {
								extraBitsStored?: number;
								elems?: Uint8Array;
							} & Record<Exclude<keyof I["signerInfos"][number]["modeInfo"]["multi"]["modeInfos"][number]["multi"]["bitarray"], keyof CompactBitArray>, never>;
							modeInfos?: any[] & ({
								single?: {
									mode?: SignMode;
								};
								multi?: {
									bitarray?: {
										extraBitsStored?: number;
										elems?: Uint8Array;
									};
									modeInfos?: any[];
								};
							} & {
								single?: {
									mode?: SignMode;
								} & {
									mode?: SignMode;
								} & Record<Exclude<keyof I["signerInfos"][number]["modeInfo"]["multi"]["modeInfos"][number]["multi"]["modeInfos"][number]["single"], "mode">, never>;
								multi?: {
									bitarray?: {
										extraBitsStored?: number;
										elems?: Uint8Array;
									};
									modeInfos?: any[];
								} & {
									bitarray?: {
										extraBitsStored?: number;
										elems?: Uint8Array;
									} & {
										extraBitsStored?: number;
										elems?: Uint8Array;
									} & Record<Exclude<keyof I["signerInfos"][number]["modeInfo"]["multi"]["modeInfos"][number]["multi"]["modeInfos"][number]["multi"]["bitarray"], keyof CompactBitArray>, never>;
									modeInfos?: any[] & ({
										single?: {
											mode?: SignMode;
										};
										multi?: {
											bitarray?: {
												extraBitsStored?: number;
												elems?: Uint8Array;
											};
											modeInfos?: any[];
										};
									} & {
										single?: {
											mode?: SignMode;
										} & {
											mode?: SignMode;
										} & Record<Exclude<keyof I["signerInfos"][number]["modeInfo"]["multi"]["modeInfos"][number]["multi"]["modeInfos"][number]["multi"]["modeInfos"][number]["single"], "mode">, never>;
										multi?: {
											bitarray?: {
												extraBitsStored?: number;
												elems?: Uint8Array;
											};
											modeInfos?: any[];
										} & {
											bitarray?: {
												extraBitsStored?: number;
												elems?: Uint8Array;
											} & {
												extraBitsStored?: number;
												elems?: Uint8Array;
											} & Record<Exclude<keyof I["signerInfos"][number]["modeInfo"]["multi"]["modeInfos"][number]["multi"]["modeInfos"][number]["multi"]["modeInfos"][number]["multi"]["bitarray"], keyof CompactBitArray>, never>;
											modeInfos?: any[] & ({
												single?: {
													mode?: SignMode;
												};
												multi?: {
													bitarray?: {
														extraBitsStored?: number;
														elems?: Uint8Array;
													};
													modeInfos?: any[];
												};
											} & {
												single?: {
													mode?: SignMode;
												} & any & Record<Exclude<keyof I["signerInfos"][number]["modeInfo"]["multi"]["modeInfos"][number]["multi"]["modeInfos"][number]["multi"]["modeInfos"][number]["multi"]["modeInfos"][number]["single"], "mode">, never>;
												multi?: {
													bitarray?: {
														extraBitsStored?: number;
														elems?: Uint8Array;
													};
													modeInfos?: any[];
												} & any & Record<Exclude<keyof I["signerInfos"][number]["modeInfo"]["multi"]["modeInfos"][number]["multi"]["modeInfos"][number]["multi"]["modeInfos"][number]["multi"]["modeInfos"][number]["multi"], keyof ModeInfo_Multi>, never>;
											} & Record<Exclude<keyof I["signerInfos"][number]["modeInfo"]["multi"]["modeInfos"][number]["multi"]["modeInfos"][number]["multi"]["modeInfos"][number]["multi"]["modeInfos"][number], keyof ModeInfo>, never>)[] & Record<Exclude<keyof I["signerInfos"][number]["modeInfo"]["multi"]["modeInfos"][number]["multi"]["modeInfos"][number]["multi"]["modeInfos"][number]["multi"]["modeInfos"], keyof any[]>, never>;
										} & Record<Exclude<keyof I["signerInfos"][number]["modeInfo"]["multi"]["modeInfos"][number]["multi"]["modeInfos"][number]["multi"]["modeInfos"][number]["multi"], keyof ModeInfo_Multi>, never>;
									} & Record<Exclude<keyof I["signerInfos"][number]["modeInfo"]["multi"]["modeInfos"][number]["multi"]["modeInfos"][number]["multi"]["modeInfos"][number], keyof ModeInfo>, never>)[] & Record<Exclude<keyof I["signerInfos"][number]["modeInfo"]["multi"]["modeInfos"][number]["multi"]["modeInfos"][number]["multi"]["modeInfos"], keyof any[]>, never>;
								} & Record<Exclude<keyof I["signerInfos"][number]["modeInfo"]["multi"]["modeInfos"][number]["multi"]["modeInfos"][number]["multi"], keyof ModeInfo_Multi>, never>;
							} & Record<Exclude<keyof I["signerInfos"][number]["modeInfo"]["multi"]["modeInfos"][number]["multi"]["modeInfos"][number], keyof ModeInfo>, never>)[] & Record<Exclude<keyof I["signerInfos"][number]["modeInfo"]["multi"]["modeInfos"][number]["multi"]["modeInfos"], keyof any[]>, never>;
						} & Record<Exclude<keyof I["signerInfos"][number]["modeInfo"]["multi"]["modeInfos"][number]["multi"], keyof ModeInfo_Multi>, never>;
					} & Record<Exclude<keyof I["signerInfos"][number]["modeInfo"]["multi"]["modeInfos"][number], keyof ModeInfo>, never>)[] & Record<Exclude<keyof I["signerInfos"][number]["modeInfo"]["multi"]["modeInfos"], keyof any[]>, never>;
				} & Record<Exclude<keyof I["signerInfos"][number]["modeInfo"]["multi"], keyof ModeInfo_Multi>, never>;
			} & Record<Exclude<keyof I["signerInfos"][number]["modeInfo"], keyof ModeInfo>, never>;
			sequence?: string | number | (Long.Long & {
				high: number;
				low: number;
				unsigned: boolean;
				add: (addend: string | number | Long.Long) => Long.Long;
				and: (other: string | number | Long.Long) => Long.Long;
				compare: (other: string | number | Long.Long) => number;
				comp: (other: string | number | Long.Long) => number;
				divide: (divisor: string | number | Long.Long) => Long.Long;
				div: (divisor: string | number | Long.Long) => Long.Long;
				equals: (other: string | number | Long.Long) => boolean;
				eq: (other: string | number | Long.Long) => boolean;
				getHighBits: () => number;
				getHighBitsUnsigned: () => number;
				getLowBits: () => number;
				getLowBitsUnsigned: () => number;
				getNumBitsAbs: () => number;
				greaterThan: (other: string | number | Long.Long) => boolean;
				gt: (other: string | number | Long.Long) => boolean;
				greaterThanOrEqual: (other: string | number | Long.Long) => boolean;
				gte: (other: string | number | Long.Long) => boolean;
				isEven: () => boolean;
				isNegative: () => boolean;
				isOdd: () => boolean;
				isPositive: () => boolean;
				isZero: () => boolean;
				lessThan: (other: string | number | Long.Long) => boolean;
				lt: (other: string | number | Long.Long) => boolean;
				lessThanOrEqual: (other: string | number | Long.Long) => boolean;
				lte: (other: string | number | Long.Long) => boolean;
				modulo: (other: string | number | Long.Long) => Long.Long;
				mod: (other: string | number | Long.Long) => Long.Long;
				multiply: (multiplier: string | number | Long.Long) => Long.Long;
				mul: (multiplier: string | number | Long.Long) => Long.Long;
				negate: () => Long.Long;
				neg: () => Long.Long;
				not: () => Long.Long;
				notEquals: (other: string | number | Long.Long) => boolean;
				neq: (other: string | number | Long.Long) => boolean;
				or: (other: string | number | Long.Long) => Long.Long;
				shiftLeft: (numBits: number | Long.Long) => Long.Long;
				shl: (numBits: number | Long.Long) => Long.Long;
				shiftRight: (numBits: number | Long.Long) => Long.Long;
				shr: (numBits: number | Long.Long) => Long.Long;
				shiftRightUnsigned: (numBits: number | Long.Long) => Long.Long;
				shru: (numBits: number | Long.Long) => Long.Long;
				subtract: (subtrahend: string | number | Long.Long) => Long.Long;
				sub: (subtrahend: string | number | Long.Long) => Long.Long;
				toInt: () => number;
				toNumber: () => number;
				toBytes: (le?: boolean) => number[];
				toBytesLE: () => number[];
				toBytesBE: () => number[];
				toSigned: () => Long.Long;
				toString: (radix?: number) => string;
				toUnsigned: () => Long.Long;
				xor: (other: string | number | Long.Long) => Long.Long;
			} & Record<Exclude<keyof I["signerInfos"][number]["sequence"], keyof Long.Long>, never>);
		} & Record<Exclude<keyof I["signerInfos"][number], keyof SignerInfo>, never>)[] & Record<Exclude<keyof I["signerInfos"], keyof {
			publicKey?: {
				typeUrl?: string;
				value?: Uint8Array;
			};
			modeInfo?: {
				single?: {
					mode?: SignMode;
				};
				multi?: {
					bitarray?: {
						extraBitsStored?: number;
						elems?: Uint8Array;
					};
					modeInfos?: any[];
				};
			};
			sequence?: string | number | Long.Long;
		}[]>, never>;
		fee?: {
			amount?: {
				denom?: string;
				amount?: string;
			}[];
			gasLimit?: string | number | Long.Long;
			payer?: string;
			granter?: string;
		} & {
			amount?: {
				denom?: string;
				amount?: string;
			}[] & ({
				denom?: string;
				amount?: string;
			} & {
				denom?: string;
				amount?: string;
			} & Record<Exclude<keyof I["fee"]["amount"][number], keyof Coin>, never>)[] & Record<Exclude<keyof I["fee"]["amount"], keyof {
				denom?: string;
				amount?: string;
			}[]>, never>;
			gasLimit?: string | number | (Long.Long & {
				high: number;
				low: number;
				unsigned: boolean;
				add: (addend: string | number | Long.Long) => Long.Long;
				and: (other: string | number | Long.Long) => Long.Long;
				compare: (other: string | number | Long.Long) => number;
				comp: (other: string | number | Long.Long) => number;
				divide: (divisor: string | number | Long.Long) => Long.Long;
				div: (divisor: string | number | Long.Long) => Long.Long;
				equals: (other: string | number | Long.Long) => boolean;
				eq: (other: string | number | Long.Long) => boolean;
				getHighBits: () => number;
				getHighBitsUnsigned: () => number;
				getLowBits: () => number;
				getLowBitsUnsigned: () => number;
				getNumBitsAbs: () => number;
				greaterThan: (other: string | number | Long.Long) => boolean;
				gt: (other: string | number | Long.Long) => boolean;
				greaterThanOrEqual: (other: string | number | Long.Long) => boolean;
				gte: (other: string | number | Long.Long) => boolean;
				isEven: () => boolean;
				isNegative: () => boolean;
				isOdd: () => boolean;
				isPositive: () => boolean;
				isZero: () => boolean;
				lessThan: (other: string | number | Long.Long) => boolean;
				lt: (other: string | number | Long.Long) => boolean;
				lessThanOrEqual: (other: string | number | Long.Long) => boolean;
				lte: (other: string | number | Long.Long) => boolean;
				modulo: (other: string | number | Long.Long) => Long.Long;
				mod: (other: string | number | Long.Long) => Long.Long;
				multiply: (multiplier: string | number | Long.Long) => Long.Long;
				mul: (multiplier: string | number | Long.Long) => Long.Long;
				negate: () => Long.Long;
				neg: () => Long.Long;
				not: () => Long.Long;
				notEquals: (other: string | number | Long.Long) => boolean;
				neq: (other: string | number | Long.Long) => boolean;
				or: (other: string | number | Long.Long) => Long.Long;
				shiftLeft: (numBits: number | Long.Long) => Long.Long;
				shl: (numBits: number | Long.Long) => Long.Long;
				shiftRight: (numBits: number | Long.Long) => Long.Long;
				shr: (numBits: number | Long.Long) => Long.Long;
				shiftRightUnsigned: (numBits: number | Long.Long) => Long.Long;
				shru: (numBits: number | Long.Long) => Long.Long;
				subtract: (subtrahend: string | number | Long.Long) => Long.Long;
				sub: (subtrahend: string | number | Long.Long) => Long.Long;
				toInt: () => number;
				toNumber: () => number;
				toBytes: (le?: boolean) => number[];
				toBytesLE: () => number[];
				toBytesBE: () => number[];
				toSigned: () => Long.Long;
				toString: (radix?: number) => string;
				toUnsigned: () => Long.Long;
				xor: (other: string | number | Long.Long) => Long.Long;
			} & Record<Exclude<keyof I["fee"]["gasLimit"], keyof Long.Long>, never>);
			payer?: string;
			granter?: string;
		} & Record<Exclude<keyof I["fee"], keyof Fee>, never>;
	} & Record<Exclude<keyof I, keyof AuthInfo>, never>>(object: I): AuthInfo;
};
declare const SignerInfo: {
	encode(message: SignerInfo, writer?: _m0.Writer): _m0.Writer;
	decode(input: _m0.Reader | Uint8Array, length?: number): SignerInfo;
	fromJSON(object: any): SignerInfo;
	toJSON(message: SignerInfo): unknown;
	fromPartial<I extends {
		publicKey?: {
			typeUrl?: string;
			value?: Uint8Array;
		};
		modeInfo?: {
			single?: {
				mode?: SignMode;
			};
			multi?: {
				bitarray?: {
					extraBitsStored?: number;
					elems?: Uint8Array;
				};
				modeInfos?: any[];
			};
		};
		sequence?: string | number | Long.Long;
	} & {
		publicKey?: {
			typeUrl?: string;
			value?: Uint8Array;
		} & {
			typeUrl?: string;
			value?: Uint8Array;
		} & Record<Exclude<keyof I["publicKey"], keyof Any>, never>;
		modeInfo?: {
			single?: {
				mode?: SignMode;
			};
			multi?: {
				bitarray?: {
					extraBitsStored?: number;
					elems?: Uint8Array;
				};
				modeInfos?: any[];
			};
		} & {
			single?: {
				mode?: SignMode;
			} & {
				mode?: SignMode;
			} & Record<Exclude<keyof I["modeInfo"]["single"], "mode">, never>;
			multi?: {
				bitarray?: {
					extraBitsStored?: number;
					elems?: Uint8Array;
				};
				modeInfos?: any[];
			} & {
				bitarray?: {
					extraBitsStored?: number;
					elems?: Uint8Array;
				} & {
					extraBitsStored?: number;
					elems?: Uint8Array;
				} & Record<Exclude<keyof I["modeInfo"]["multi"]["bitarray"], keyof CompactBitArray>, never>;
				modeInfos?: any[] & ({
					single?: {
						mode?: SignMode;
					};
					multi?: {
						bitarray?: {
							extraBitsStored?: number;
							elems?: Uint8Array;
						};
						modeInfos?: any[];
					};
				} & {
					single?: {
						mode?: SignMode;
					} & {
						mode?: SignMode;
					} & Record<Exclude<keyof I["modeInfo"]["multi"]["modeInfos"][number]["single"], "mode">, never>;
					multi?: {
						bitarray?: {
							extraBitsStored?: number;
							elems?: Uint8Array;
						};
						modeInfos?: any[];
					} & {
						bitarray?: {
							extraBitsStored?: number;
							elems?: Uint8Array;
						} & {
							extraBitsStored?: number;
							elems?: Uint8Array;
						} & Record<Exclude<keyof I["modeInfo"]["multi"]["modeInfos"][number]["multi"]["bitarray"], keyof CompactBitArray>, never>;
						modeInfos?: any[] & ({
							single?: {
								mode?: SignMode;
							};
							multi?: {
								bitarray?: {
									extraBitsStored?: number;
									elems?: Uint8Array;
								};
								modeInfos?: any[];
							};
						} & {
							single?: {
								mode?: SignMode;
							} & {
								mode?: SignMode;
							} & Record<Exclude<keyof I["modeInfo"]["multi"]["modeInfos"][number]["multi"]["modeInfos"][number]["single"], "mode">, never>;
							multi?: {
								bitarray?: {
									extraBitsStored?: number;
									elems?: Uint8Array;
								};
								modeInfos?: any[];
							} & {
								bitarray?: {
									extraBitsStored?: number;
									elems?: Uint8Array;
								} & {
									extraBitsStored?: number;
									elems?: Uint8Array;
								} & Record<Exclude<keyof I["modeInfo"]["multi"]["modeInfos"][number]["multi"]["modeInfos"][number]["multi"]["bitarray"], keyof CompactBitArray>, never>;
								modeInfos?: any[] & ({
									single?: {
										mode?: SignMode;
									};
									multi?: {
										bitarray?: {
											extraBitsStored?: number;
											elems?: Uint8Array;
										};
										modeInfos?: any[];
									};
								} & {
									single?: {
										mode?: SignMode;
									} & {
										mode?: SignMode;
									} & Record<Exclude<keyof I["modeInfo"]["multi"]["modeInfos"][number]["multi"]["modeInfos"][number]["multi"]["modeInfos"][number]["single"], "mode">, never>;
									multi?: {
										bitarray?: {
											extraBitsStored?: number;
											elems?: Uint8Array;
										};
										modeInfos?: any[];
									} & {
										bitarray?: {
											extraBitsStored?: number;
											elems?: Uint8Array;
										} & {
											extraBitsStored?: number;
											elems?: Uint8Array;
										} & Record<Exclude<keyof I["modeInfo"]["multi"]["modeInfos"][number]["multi"]["modeInfos"][number]["multi"]["modeInfos"][number]["multi"]["bitarray"], keyof CompactBitArray>, never>;
										modeInfos?: any[] & ({
											single?: {
												mode?: SignMode;
											};
											multi?: {
												bitarray?: {
													extraBitsStored?: number;
													elems?: Uint8Array;
												};
												modeInfos?: any[];
											};
										} & {
											single?: {
												mode?: SignMode;
											} & {
												mode?: SignMode;
											} & Record<Exclude<keyof I["modeInfo"]["multi"]["modeInfos"][number]["multi"]["modeInfos"][number]["multi"]["modeInfos"][number]["multi"]["modeInfos"][number]["single"], "mode">, never>;
											multi?: {
												bitarray?: {
													extraBitsStored?: number;
													elems?: Uint8Array;
												};
												modeInfos?: any[];
											} & {
												bitarray?: {
													extraBitsStored?: number;
													elems?: Uint8Array;
												} & any & Record<Exclude<keyof I["modeInfo"]["multi"]["modeInfos"][number]["multi"]["modeInfos"][number]["multi"]["modeInfos"][number]["multi"]["modeInfos"][number]["multi"]["bitarray"], keyof CompactBitArray>, never>;
												modeInfos?: any[] & ({
													single?: {
														mode?: SignMode;
													};
													multi?: {
														bitarray?: {
															extraBitsStored?: number;
															elems?: Uint8Array;
														};
														modeInfos?: any[];
													};
												} & any & Record<Exclude<keyof I["modeInfo"]["multi"]["modeInfos"][number]["multi"]["modeInfos"][number]["multi"]["modeInfos"][number]["multi"]["modeInfos"][number]["multi"]["modeInfos"][number], keyof ModeInfo>, never>)[] & Record<Exclude<keyof I["modeInfo"]["multi"]["modeInfos"][number]["multi"]["modeInfos"][number]["multi"]["modeInfos"][number]["multi"]["modeInfos"][number]["multi"]["modeInfos"], keyof any[]>, never>;
											} & Record<Exclude<keyof I["modeInfo"]["multi"]["modeInfos"][number]["multi"]["modeInfos"][number]["multi"]["modeInfos"][number]["multi"]["modeInfos"][number]["multi"], keyof ModeInfo_Multi>, never>;
										} & Record<Exclude<keyof I["modeInfo"]["multi"]["modeInfos"][number]["multi"]["modeInfos"][number]["multi"]["modeInfos"][number]["multi"]["modeInfos"][number], keyof ModeInfo>, never>)[] & Record<Exclude<keyof I["modeInfo"]["multi"]["modeInfos"][number]["multi"]["modeInfos"][number]["multi"]["modeInfos"][number]["multi"]["modeInfos"], keyof any[]>, never>;
									} & Record<Exclude<keyof I["modeInfo"]["multi"]["modeInfos"][number]["multi"]["modeInfos"][number]["multi"]["modeInfos"][number]["multi"], keyof ModeInfo_Multi>, never>;
								} & Record<Exclude<keyof I["modeInfo"]["multi"]["modeInfos"][number]["multi"]["modeInfos"][number]["multi"]["modeInfos"][number], keyof ModeInfo>, never>)[] & Record<Exclude<keyof I["modeInfo"]["multi"]["modeInfos"][number]["multi"]["modeInfos"][number]["multi"]["modeInfos"], keyof any[]>, never>;
							} & Record<Exclude<keyof I["modeInfo"]["multi"]["modeInfos"][number]["multi"]["modeInfos"][number]["multi"], keyof ModeInfo_Multi>, never>;
						} & Record<Exclude<keyof I["modeInfo"]["multi"]["modeInfos"][number]["multi"]["modeInfos"][number], keyof ModeInfo>, never>)[] & Record<Exclude<keyof I["modeInfo"]["multi"]["modeInfos"][number]["multi"]["modeInfos"], keyof any[]>, never>;
					} & Record<Exclude<keyof I["modeInfo"]["multi"]["modeInfos"][number]["multi"], keyof ModeInfo_Multi>, never>;
				} & Record<Exclude<keyof I["modeInfo"]["multi"]["modeInfos"][number], keyof ModeInfo>, never>)[] & Record<Exclude<keyof I["modeInfo"]["multi"]["modeInfos"], keyof any[]>, never>;
			} & Record<Exclude<keyof I["modeInfo"]["multi"], keyof ModeInfo_Multi>, never>;
		} & Record<Exclude<keyof I["modeInfo"], keyof ModeInfo>, never>;
		sequence?: string | number | (Long.Long & {
			high: number;
			low: number;
			unsigned: boolean;
			add: (addend: string | number | Long.Long) => Long.Long;
			and: (other: string | number | Long.Long) => Long.Long;
			compare: (other: string | number | Long.Long) => number;
			comp: (other: string | number | Long.Long) => number;
			divide: (divisor: string | number | Long.Long) => Long.Long;
			div: (divisor: string | number | Long.Long) => Long.Long;
			equals: (other: string | number | Long.Long) => boolean;
			eq: (other: string | number | Long.Long) => boolean;
			getHighBits: () => number;
			getHighBitsUnsigned: () => number;
			getLowBits: () => number;
			getLowBitsUnsigned: () => number;
			getNumBitsAbs: () => number;
			greaterThan: (other: string | number | Long.Long) => boolean;
			gt: (other: string | number | Long.Long) => boolean;
			greaterThanOrEqual: (other: string | number | Long.Long) => boolean;
			gte: (other: string | number | Long.Long) => boolean;
			isEven: () => boolean;
			isNegative: () => boolean;
			isOdd: () => boolean;
			isPositive: () => boolean;
			isZero: () => boolean;
			lessThan: (other: string | number | Long.Long) => boolean;
			lt: (other: string | number | Long.Long) => boolean;
			lessThanOrEqual: (other: string | number | Long.Long) => boolean;
			lte: (other: string | number | Long.Long) => boolean;
			modulo: (other: string | number | Long.Long) => Long.Long;
			mod: (other: string | number | Long.Long) => Long.Long;
			multiply: (multiplier: string | number | Long.Long) => Long.Long;
			mul: (multiplier: string | number | Long.Long) => Long.Long;
			negate: () => Long.Long;
			neg: () => Long.Long;
			not: () => Long.Long;
			notEquals: (other: string | number | Long.Long) => boolean;
			neq: (other: string | number | Long.Long) => boolean;
			or: (other: string | number | Long.Long) => Long.Long;
			shiftLeft: (numBits: number | Long.Long) => Long.Long;
			shl: (numBits: number | Long.Long) => Long.Long;
			shiftRight: (numBits: number | Long.Long) => Long.Long;
			shr: (numBits: number | Long.Long) => Long.Long;
			shiftRightUnsigned: (numBits: number | Long.Long) => Long.Long;
			shru: (numBits: number | Long.Long) => Long.Long;
			subtract: (subtrahend: string | number | Long.Long) => Long.Long;
			sub: (subtrahend: string | number | Long.Long) => Long.Long;
			toInt: () => number;
			toNumber: () => number;
			toBytes: (le?: boolean) => number[];
			toBytesLE: () => number[];
			toBytesBE: () => number[];
			toSigned: () => Long.Long;
			toString: (radix?: number) => string;
			toUnsigned: () => Long.Long;
			xor: (other: string | number | Long.Long) => Long.Long;
		} & Record<Exclude<keyof I["sequence"], keyof Long.Long>, never>);
	} & Record<Exclude<keyof I, keyof SignerInfo>, never>>(object: I): SignerInfo;
};
declare const ModeInfo: {
	encode(message: ModeInfo, writer?: _m0.Writer): _m0.Writer;
	decode(input: _m0.Reader | Uint8Array, length?: number): ModeInfo;
	fromJSON(object: any): ModeInfo;
	toJSON(message: ModeInfo): unknown;
	fromPartial<I extends {
		single?: {
			mode?: SignMode;
		};
		multi?: {
			bitarray?: {
				extraBitsStored?: number;
				elems?: Uint8Array;
			};
			modeInfos?: any[];
		};
	} & {
		single?: {
			mode?: SignMode;
		} & {
			mode?: SignMode;
		} & Record<Exclude<keyof I["single"], "mode">, never>;
		multi?: {
			bitarray?: {
				extraBitsStored?: number;
				elems?: Uint8Array;
			};
			modeInfos?: any[];
		} & {
			bitarray?: {
				extraBitsStored?: number;
				elems?: Uint8Array;
			} & {
				extraBitsStored?: number;
				elems?: Uint8Array;
			} & Record<Exclude<keyof I["multi"]["bitarray"], keyof CompactBitArray>, never>;
			modeInfos?: any[] & ({
				single?: {
					mode?: SignMode;
				};
				multi?: {
					bitarray?: {
						extraBitsStored?: number;
						elems?: Uint8Array;
					};
					modeInfos?: any[];
				};
			} & {
				single?: {
					mode?: SignMode;
				} & {
					mode?: SignMode;
				} & Record<Exclude<keyof I["multi"]["modeInfos"][number]["single"], "mode">, never>;
				multi?: {
					bitarray?: {
						extraBitsStored?: number;
						elems?: Uint8Array;
					};
					modeInfos?: any[];
				} & {
					bitarray?: {
						extraBitsStored?: number;
						elems?: Uint8Array;
					} & {
						extraBitsStored?: number;
						elems?: Uint8Array;
					} & Record<Exclude<keyof I["multi"]["modeInfos"][number]["multi"]["bitarray"], keyof CompactBitArray>, never>;
					modeInfos?: any[] & ({
						single?: {
							mode?: SignMode;
						};
						multi?: {
							bitarray?: {
								extraBitsStored?: number;
								elems?: Uint8Array;
							};
							modeInfos?: any[];
						};
					} & {
						single?: {
							mode?: SignMode;
						} & {
							mode?: SignMode;
						} & Record<Exclude<keyof I["multi"]["modeInfos"][number]["multi"]["modeInfos"][number]["single"], "mode">, never>;
						multi?: {
							bitarray?: {
								extraBitsStored?: number;
								elems?: Uint8Array;
							};
							modeInfos?: any[];
						} & {
							bitarray?: {
								extraBitsStored?: number;
								elems?: Uint8Array;
							} & {
								extraBitsStored?: number;
								elems?: Uint8Array;
							} & Record<Exclude<keyof I["multi"]["modeInfos"][number]["multi"]["modeInfos"][number]["multi"]["bitarray"], keyof CompactBitArray>, never>;
							modeInfos?: any[] & ({
								single?: {
									mode?: SignMode;
								};
								multi?: {
									bitarray?: {
										extraBitsStored?: number;
										elems?: Uint8Array;
									};
									modeInfos?: any[];
								};
							} & {
								single?: {
									mode?: SignMode;
								} & {
									mode?: SignMode;
								} & Record<Exclude<keyof I["multi"]["modeInfos"][number]["multi"]["modeInfos"][number]["multi"]["modeInfos"][number]["single"], "mode">, never>;
								multi?: {
									bitarray?: {
										extraBitsStored?: number;
										elems?: Uint8Array;
									};
									modeInfos?: any[];
								} & {
									bitarray?: {
										extraBitsStored?: number;
										elems?: Uint8Array;
									} & {
										extraBitsStored?: number;
										elems?: Uint8Array;
									} & Record<Exclude<keyof I["multi"]["modeInfos"][number]["multi"]["modeInfos"][number]["multi"]["modeInfos"][number]["multi"]["bitarray"], keyof CompactBitArray>, never>;
									modeInfos?: any[] & ({
										single?: {
											mode?: SignMode;
										};
										multi?: {
											bitarray?: {
												extraBitsStored?: number;
												elems?: Uint8Array;
											};
											modeInfos?: any[];
										};
									} & {
										single?: {
											mode?: SignMode;
										} & {
											mode?: SignMode;
										} & Record<Exclude<keyof I["multi"]["modeInfos"][number]["multi"]["modeInfos"][number]["multi"]["modeInfos"][number]["multi"]["modeInfos"][number]["single"], "mode">, never>;
										multi?: {
											bitarray?: {
												extraBitsStored?: number;
												elems?: Uint8Array;
											};
											modeInfos?: any[];
										} & {
											bitarray?: {
												extraBitsStored?: number;
												elems?: Uint8Array;
											} & {
												extraBitsStored?: number;
												elems?: Uint8Array;
											} & Record<Exclude<keyof I["multi"]["modeInfos"][number]["multi"]["modeInfos"][number]["multi"]["modeInfos"][number]["multi"]["modeInfos"][number]["multi"]["bitarray"], keyof CompactBitArray>, never>;
											modeInfos?: any[] & ({
												single?: {
													mode?: SignMode;
												};
												multi?: {
													bitarray?: {
														extraBitsStored?: number;
														elems?: Uint8Array;
													};
													modeInfos?: any[];
												};
											} & {
												single?: {
													mode?: SignMode;
												} & any & Record<Exclude<keyof I["multi"]["modeInfos"][number]["multi"]["modeInfos"][number]["multi"]["modeInfos"][number]["multi"]["modeInfos"][number]["multi"]["modeInfos"][number]["single"], "mode">, never>;
												multi?: {
													bitarray?: {
														extraBitsStored?: number;
														elems?: Uint8Array;
													};
													modeInfos?: any[];
												} & any & Record<Exclude<keyof I["multi"]["modeInfos"][number]["multi"]["modeInfos"][number]["multi"]["modeInfos"][number]["multi"]["modeInfos"][number]["multi"]["modeInfos"][number]["multi"], keyof ModeInfo_Multi>, never>;
											} & Record<Exclude<keyof I["multi"]["modeInfos"][number]["multi"]["modeInfos"][number]["multi"]["modeInfos"][number]["multi"]["modeInfos"][number]["multi"]["modeInfos"][number], keyof ModeInfo>, never>)[] & Record<Exclude<keyof I["multi"]["modeInfos"][number]["multi"]["modeInfos"][number]["multi"]["modeInfos"][number]["multi"]["modeInfos"][number]["multi"]["modeInfos"], keyof any[]>, never>;
										} & Record<Exclude<keyof I["multi"]["modeInfos"][number]["multi"]["modeInfos"][number]["multi"]["modeInfos"][number]["multi"]["modeInfos"][number]["multi"], keyof ModeInfo_Multi>, never>;
									} & Record<Exclude<keyof I["multi"]["modeInfos"][number]["multi"]["modeInfos"][number]["multi"]["modeInfos"][number]["multi"]["modeInfos"][number], keyof ModeInfo>, never>)[] & Record<Exclude<keyof I["multi"]["modeInfos"][number]["multi"]["modeInfos"][number]["multi"]["modeInfos"][number]["multi"]["modeInfos"], keyof any[]>, never>;
								} & Record<Exclude<keyof I["multi"]["modeInfos"][number]["multi"]["modeInfos"][number]["multi"]["modeInfos"][number]["multi"], keyof ModeInfo_Multi>, never>;
							} & Record<Exclude<keyof I["multi"]["modeInfos"][number]["multi"]["modeInfos"][number]["multi"]["modeInfos"][number], keyof ModeInfo>, never>)[] & Record<Exclude<keyof I["multi"]["modeInfos"][number]["multi"]["modeInfos"][number]["multi"]["modeInfos"], keyof any[]>, never>;
						} & Record<Exclude<keyof I["multi"]["modeInfos"][number]["multi"]["modeInfos"][number]["multi"], keyof ModeInfo_Multi>, never>;
					} & Record<Exclude<keyof I["multi"]["modeInfos"][number]["multi"]["modeInfos"][number], keyof ModeInfo>, never>)[] & Record<Exclude<keyof I["multi"]["modeInfos"][number]["multi"]["modeInfos"], keyof any[]>, never>;
				} & Record<Exclude<keyof I["multi"]["modeInfos"][number]["multi"], keyof ModeInfo_Multi>, never>;
			} & Record<Exclude<keyof I["multi"]["modeInfos"][number], keyof ModeInfo>, never>)[] & Record<Exclude<keyof I["multi"]["modeInfos"], keyof any[]>, never>;
		} & Record<Exclude<keyof I["multi"], keyof ModeInfo_Multi>, never>;
	} & Record<Exclude<keyof I, keyof ModeInfo>, never>>(object: I): ModeInfo;
};
declare const ModeInfo_Single: {
	encode(message: ModeInfo_Single, writer?: _m0.Writer): _m0.Writer;
	decode(input: _m0.Reader | Uint8Array, length?: number): ModeInfo_Single;
	fromJSON(object: any): ModeInfo_Single;
	toJSON(message: ModeInfo_Single): unknown;
	fromPartial<I extends {
		mode?: SignMode;
	} & {
		mode?: SignMode;
	} & Record<Exclude<keyof I, "mode">, never>>(object: I): ModeInfo_Single;
};
declare const ModeInfo_Multi: {
	encode(message: ModeInfo_Multi, writer?: _m0.Writer): _m0.Writer;
	decode(input: _m0.Reader | Uint8Array, length?: number): ModeInfo_Multi;
	fromJSON(object: any): ModeInfo_Multi;
	toJSON(message: ModeInfo_Multi): unknown;
	fromPartial<I extends {
		bitarray?: {
			extraBitsStored?: number;
			elems?: Uint8Array;
		};
		modeInfos?: any[];
	} & {
		bitarray?: {
			extraBitsStored?: number;
			elems?: Uint8Array;
		} & {
			extraBitsStored?: number;
			elems?: Uint8Array;
		} & Record<Exclude<keyof I["bitarray"], keyof CompactBitArray>, never>;
		modeInfos?: any[] & ({
			single?: {
				mode?: SignMode;
			};
			multi?: {
				bitarray?: {
					extraBitsStored?: number;
					elems?: Uint8Array;
				};
				modeInfos?: any[];
			};
		} & {
			single?: {
				mode?: SignMode;
			} & {
				mode?: SignMode;
			} & Record<Exclude<keyof I["modeInfos"][number]["single"], "mode">, never>;
			multi?: {
				bitarray?: {
					extraBitsStored?: number;
					elems?: Uint8Array;
				};
				modeInfos?: any[];
			} & {
				bitarray?: {
					extraBitsStored?: number;
					elems?: Uint8Array;
				} & {
					extraBitsStored?: number;
					elems?: Uint8Array;
				} & Record<Exclude<keyof I["modeInfos"][number]["multi"]["bitarray"], keyof CompactBitArray>, never>;
				modeInfos?: any[] & ({
					single?: {
						mode?: SignMode;
					};
					multi?: {
						bitarray?: {
							extraBitsStored?: number;
							elems?: Uint8Array;
						};
						modeInfos?: any[];
					};
				} & {
					single?: {
						mode?: SignMode;
					} & {
						mode?: SignMode;
					} & Record<Exclude<keyof I["modeInfos"][number]["multi"]["modeInfos"][number]["single"], "mode">, never>;
					multi?: {
						bitarray?: {
							extraBitsStored?: number;
							elems?: Uint8Array;
						};
						modeInfos?: any[];
					} & {
						bitarray?: {
							extraBitsStored?: number;
							elems?: Uint8Array;
						} & {
							extraBitsStored?: number;
							elems?: Uint8Array;
						} & Record<Exclude<keyof I["modeInfos"][number]["multi"]["modeInfos"][number]["multi"]["bitarray"], keyof CompactBitArray>, never>;
						modeInfos?: any[] & ({
							single?: {
								mode?: SignMode;
							};
							multi?: {
								bitarray?: {
									extraBitsStored?: number;
									elems?: Uint8Array;
								};
								modeInfos?: any[];
							};
						} & {
							single?: {
								mode?: SignMode;
							} & {
								mode?: SignMode;
							} & Record<Exclude<keyof I["modeInfos"][number]["multi"]["modeInfos"][number]["multi"]["modeInfos"][number]["single"], "mode">, never>;
							multi?: {
								bitarray?: {
									extraBitsStored?: number;
									elems?: Uint8Array;
								};
								modeInfos?: any[];
							} & {
								bitarray?: {
									extraBitsStored?: number;
									elems?: Uint8Array;
								} & {
									extraBitsStored?: number;
									elems?: Uint8Array;
								} & Record<Exclude<keyof I["modeInfos"][number]["multi"]["modeInfos"][number]["multi"]["modeInfos"][number]["multi"]["bitarray"], keyof CompactBitArray>, never>;
								modeInfos?: any[] & ({
									single?: {
										mode?: SignMode;
									};
									multi?: {
										bitarray?: {
											extraBitsStored?: number;
											elems?: Uint8Array;
										};
										modeInfos?: any[];
									};
								} & {
									single?: {
										mode?: SignMode;
									} & {
										mode?: SignMode;
									} & Record<Exclude<keyof I["modeInfos"][number]["multi"]["modeInfos"][number]["multi"]["modeInfos"][number]["multi"]["modeInfos"][number]["single"], "mode">, never>;
									multi?: {
										bitarray?: {
											extraBitsStored?: number;
											elems?: Uint8Array;
										};
										modeInfos?: any[];
									} & {
										bitarray?: {
											extraBitsStored?: number;
											elems?: Uint8Array;
										} & {
											extraBitsStored?: number;
											elems?: Uint8Array;
										} & Record<Exclude<keyof I["modeInfos"][number]["multi"]["modeInfos"][number]["multi"]["modeInfos"][number]["multi"]["modeInfos"][number]["multi"]["bitarray"], keyof CompactBitArray>, never>;
										modeInfos?: any[] & ({
											single?: {
												mode?: SignMode;
											};
											multi?: {
												bitarray?: {
													extraBitsStored?: number;
													elems?: Uint8Array;
												};
												modeInfos?: any[];
											};
										} & {
											single?: {
												mode?: SignMode;
											} & {
												mode?: SignMode;
											} & Record<Exclude<keyof I["modeInfos"][number]["multi"]["modeInfos"][number]["multi"]["modeInfos"][number]["multi"]["modeInfos"][number]["multi"]["modeInfos"][number]["single"], "mode">, never>;
											multi?: {
												bitarray?: {
													extraBitsStored?: number;
													elems?: Uint8Array;
												};
												modeInfos?: any[];
											} & {
												bitarray?: {
													extraBitsStored?: number;
													elems?: Uint8Array;
												} & any & Record<Exclude<keyof I["modeInfos"][number]["multi"]["modeInfos"][number]["multi"]["modeInfos"][number]["multi"]["modeInfos"][number]["multi"]["modeInfos"][number]["multi"]["bitarray"], keyof CompactBitArray>, never>;
												modeInfos?: any[] & ({
													single?: {
														mode?: SignMode;
													};
													multi?: {
														bitarray?: {
															extraBitsStored?: number;
															elems?: Uint8Array;
														};
														modeInfos?: any[];
													};
												} & any & Record<Exclude<keyof I["modeInfos"][number]["multi"]["modeInfos"][number]["multi"]["modeInfos"][number]["multi"]["modeInfos"][number]["multi"]["modeInfos"][number]["multi"]["modeInfos"][number], keyof ModeInfo>, never>)[] & Record<Exclude<keyof I["modeInfos"][number]["multi"]["modeInfos"][number]["multi"]["modeInfos"][number]["multi"]["modeInfos"][number]["multi"]["modeInfos"][number]["multi"]["modeInfos"], keyof any[]>, never>;
											} & Record<Exclude<keyof I["modeInfos"][number]["multi"]["modeInfos"][number]["multi"]["modeInfos"][number]["multi"]["modeInfos"][number]["multi"]["modeInfos"][number]["multi"], keyof ModeInfo_Multi>, never>;
										} & Record<Exclude<keyof I["modeInfos"][number]["multi"]["modeInfos"][number]["multi"]["modeInfos"][number]["multi"]["modeInfos"][number]["multi"]["modeInfos"][number], keyof ModeInfo>, never>)[] & Record<Exclude<keyof I["modeInfos"][number]["multi"]["modeInfos"][number]["multi"]["modeInfos"][number]["multi"]["modeInfos"][number]["multi"]["modeInfos"], keyof any[]>, never>;
									} & Record<Exclude<keyof I["modeInfos"][number]["multi"]["modeInfos"][number]["multi"]["modeInfos"][number]["multi"]["modeInfos"][number]["multi"], keyof ModeInfo_Multi>, never>;
								} & Record<Exclude<keyof I["modeInfos"][number]["multi"]["modeInfos"][number]["multi"]["modeInfos"][number]["multi"]["modeInfos"][number], keyof ModeInfo>, never>)[] & Record<Exclude<keyof I["modeInfos"][number]["multi"]["modeInfos"][number]["multi"]["modeInfos"][number]["multi"]["modeInfos"], keyof any[]>, never>;
							} & Record<Exclude<keyof I["modeInfos"][number]["multi"]["modeInfos"][number]["multi"]["modeInfos"][number]["multi"], keyof ModeInfo_Multi>, never>;
						} & Record<Exclude<keyof I["modeInfos"][number]["multi"]["modeInfos"][number]["multi"]["modeInfos"][number], keyof ModeInfo>, never>)[] & Record<Exclude<keyof I["modeInfos"][number]["multi"]["modeInfos"][number]["multi"]["modeInfos"], keyof any[]>, never>;
					} & Record<Exclude<keyof I["modeInfos"][number]["multi"]["modeInfos"][number]["multi"], keyof ModeInfo_Multi>, never>;
				} & Record<Exclude<keyof I["modeInfos"][number]["multi"]["modeInfos"][number], keyof ModeInfo>, never>)[] & Record<Exclude<keyof I["modeInfos"][number]["multi"]["modeInfos"], keyof any[]>, never>;
			} & Record<Exclude<keyof I["modeInfos"][number]["multi"], keyof ModeInfo_Multi>, never>;
		} & Record<Exclude<keyof I["modeInfos"][number], keyof ModeInfo>, never>)[] & Record<Exclude<keyof I["modeInfos"], keyof any[]>, never>;
	} & Record<Exclude<keyof I, keyof ModeInfo_Multi>, never>>(object: I): ModeInfo_Multi;
};
declare const Fee: {
	encode(message: Fee, writer?: _m0.Writer): _m0.Writer;
	decode(input: _m0.Reader | Uint8Array, length?: number): Fee;
	fromJSON(object: any): Fee;
	toJSON(message: Fee): unknown;
	fromPartial<I extends {
		amount?: {
			denom?: string;
			amount?: string;
		}[];
		gasLimit?: string | number | Long.Long;
		payer?: string;
		granter?: string;
	} & {
		amount?: {
			denom?: string;
			amount?: string;
		}[] & ({
			denom?: string;
			amount?: string;
		} & {
			denom?: string;
			amount?: string;
		} & Record<Exclude<keyof I["amount"][number], keyof Coin>, never>)[] & Record<Exclude<keyof I["amount"], keyof {
			denom?: string;
			amount?: string;
		}[]>, never>;
		gasLimit?: string | number | (Long.Long & {
			high: number;
			low: number;
			unsigned: boolean;
			add: (addend: string | number | Long.Long) => Long.Long;
			and: (other: string | number | Long.Long) => Long.Long;
			compare: (other: string | number | Long.Long) => number;
			comp: (other: string | number | Long.Long) => number;
			divide: (divisor: string | number | Long.Long) => Long.Long;
			div: (divisor: string | number | Long.Long) => Long.Long;
			equals: (other: string | number | Long.Long) => boolean;
			eq: (other: string | number | Long.Long) => boolean;
			getHighBits: () => number;
			getHighBitsUnsigned: () => number;
			getLowBits: () => number;
			getLowBitsUnsigned: () => number;
			getNumBitsAbs: () => number;
			greaterThan: (other: string | number | Long.Long) => boolean;
			gt: (other: string | number | Long.Long) => boolean;
			greaterThanOrEqual: (other: string | number | Long.Long) => boolean;
			gte: (other: string | number | Long.Long) => boolean;
			isEven: () => boolean;
			isNegative: () => boolean;
			isOdd: () => boolean;
			isPositive: () => boolean;
			isZero: () => boolean;
			lessThan: (other: string | number | Long.Long) => boolean;
			lt: (other: string | number | Long.Long) => boolean;
			lessThanOrEqual: (other: string | number | Long.Long) => boolean;
			lte: (other: string | number | Long.Long) => boolean;
			modulo: (other: string | number | Long.Long) => Long.Long;
			mod: (other: string | number | Long.Long) => Long.Long;
			multiply: (multiplier: string | number | Long.Long) => Long.Long;
			mul: (multiplier: string | number | Long.Long) => Long.Long;
			negate: () => Long.Long;
			neg: () => Long.Long;
			not: () => Long.Long;
			notEquals: (other: string | number | Long.Long) => boolean;
			neq: (other: string | number | Long.Long) => boolean;
			or: (other: string | number | Long.Long) => Long.Long;
			shiftLeft: (numBits: number | Long.Long) => Long.Long;
			shl: (numBits: number | Long.Long) => Long.Long;
			shiftRight: (numBits: number | Long.Long) => Long.Long;
			shr: (numBits: number | Long.Long) => Long.Long;
			shiftRightUnsigned: (numBits: number | Long.Long) => Long.Long;
			shru: (numBits: number | Long.Long) => Long.Long;
			subtract: (subtrahend: string | number | Long.Long) => Long.Long;
			sub: (subtrahend: string | number | Long.Long) => Long.Long;
			toInt: () => number;
			toNumber: () => number;
			toBytes: (le?: boolean) => number[];
			toBytesLE: () => number[];
			toBytesBE: () => number[];
			toSigned: () => Long.Long;
			toString: (radix?: number) => string;
			toUnsigned: () => Long.Long;
			xor: (other: string | number | Long.Long) => Long.Long;
		} & Record<Exclude<keyof I["gasLimit"], keyof Long.Long>, never>);
		payer?: string;
		granter?: string;
	} & Record<Exclude<keyof I, keyof Fee>, never>>(object: I): Fee;
};
declare enum OrderBy {
	/** ORDER_BY_UNSPECIFIED - ORDER_BY_UNSPECIFIED specifies an unknown sorting order. OrderBy defaults to ASC in this case. */
	ORDER_BY_UNSPECIFIED = 0,
	/** ORDER_BY_ASC - ORDER_BY_ASC defines ascending order */
	ORDER_BY_ASC = 1,
	/** ORDER_BY_DESC - ORDER_BY_DESC defines descending order */
	ORDER_BY_DESC = 2,
	UNRECOGNIZED = -1
}
declare enum BroadcastMode {
	/** BROADCAST_MODE_UNSPECIFIED - zero-value for mode ordering */
	BROADCAST_MODE_UNSPECIFIED = 0,
	/**
	 * BROADCAST_MODE_BLOCK - BROADCAST_MODE_BLOCK defines a tx broadcasting mode where the client waits for
	 * the tx to be committed in a block.
	 */
	BROADCAST_MODE_BLOCK = 1,
	/**
	 * BROADCAST_MODE_SYNC - BROADCAST_MODE_SYNC defines a tx broadcasting mode where the client waits for
	 * a CheckTx execution response only.
	 */
	BROADCAST_MODE_SYNC = 2,
	/**
	 * BROADCAST_MODE_ASYNC - BROADCAST_MODE_ASYNC defines a tx broadcasting mode where the client returns
	 * immediately.
	 */
	BROADCAST_MODE_ASYNC = 3,
	UNRECOGNIZED = -1
}
/**
 * GetTxsEventRequest is the request type for the Service.TxsByEvents
 * RPC method.
 */
export interface GetTxsEventRequest {
	/** events is the list of transaction event type. */
	events: string[];
	/** pagination defines an pagination for the request. */
	pagination?: PageRequest;
	orderBy: OrderBy;
}
/**
 * GetTxsEventResponse is the response type for the Service.TxsByEvents
 * RPC method.
 */
export interface GetTxsEventResponse {
	/** txs is the list of queried transactions. */
	txs: Tx[];
	/** tx_responses is the list of queried TxResponses. */
	txResponses: TxResponse[];
	/** pagination defines an pagination for the response. */
	pagination?: PageResponse;
}
/**
 * BroadcastTxRequest is the request type for the Service.BroadcastTxRequest
 * RPC method.
 */
export interface BroadcastTxRequest {
	/** tx_bytes is the raw transaction. */
	txBytes: Uint8Array;
	mode: BroadcastMode;
}
/**
 * BroadcastTxResponse is the response type for the
 * Service.BroadcastTx method.
 */
export interface BroadcastTxResponse {
	/** tx_response is the queried TxResponses. */
	txResponse?: TxResponse;
}
/**
 * SimulateRequest is the request type for the Service.Simulate
 * RPC method.
 */
export interface SimulateRequest {
	/**
	 * tx is the transaction to simulate.
	 * Deprecated. Send raw tx bytes instead.
	 *
	 * @deprecated
	 */
	tx?: Tx;
	/** tx_bytes is the raw transaction. */
	txBytes: Uint8Array;
}
/**
 * SimulateResponse is the response type for the
 * Service.SimulateRPC method.
 */
export interface SimulateResponse {
	/** gas_info is the information about gas used in the simulation. */
	gasInfo?: GasInfo;
	/** result is the result of the simulation. */
	result?: Result;
}
/**
 * GetTxRequest is the request type for the Service.GetTx
 * RPC method.
 */
export interface GetTxRequest {
	/** hash is the tx hash to query, encoded as a hex string. */
	hash: string;
}
/** GetTxResponse is the response type for the Service.GetTx method. */
export interface GetTxResponse {
	/** tx is the queried transaction. */
	tx?: Tx;
	/** tx_response is the queried TxResponses. */
	txResponse?: TxResponse;
}
declare const GetTxsEventRequest: {
	encode(message: GetTxsEventRequest, writer?: _m0.Writer): _m0.Writer;
	decode(input: _m0.Reader | Uint8Array, length?: number): GetTxsEventRequest;
	fromJSON(object: any): GetTxsEventRequest;
	toJSON(message: GetTxsEventRequest): unknown;
	fromPartial<I extends {
		events?: string[];
		pagination?: {
			key?: Uint8Array;
			offset?: string | number | Long.Long;
			limit?: string | number | Long.Long;
			countTotal?: boolean;
			reverse?: boolean;
		};
		orderBy?: OrderBy;
	} & {
		events?: string[] & string[] & Record<Exclude<keyof I["events"], keyof string[]>, never>;
		pagination?: {
			key?: Uint8Array;
			offset?: string | number | Long.Long;
			limit?: string | number | Long.Long;
			countTotal?: boolean;
			reverse?: boolean;
		} & {
			key?: Uint8Array;
			offset?: string | number | (Long.Long & {
				high: number;
				low: number;
				unsigned: boolean;
				add: (addend: string | number | Long.Long) => Long.Long;
				and: (other: string | number | Long.Long) => Long.Long;
				compare: (other: string | number | Long.Long) => number;
				comp: (other: string | number | Long.Long) => number;
				divide: (divisor: string | number | Long.Long) => Long.Long;
				div: (divisor: string | number | Long.Long) => Long.Long;
				equals: (other: string | number | Long.Long) => boolean;
				eq: (other: string | number | Long.Long) => boolean;
				getHighBits: () => number;
				getHighBitsUnsigned: () => number;
				getLowBits: () => number;
				getLowBitsUnsigned: () => number;
				getNumBitsAbs: () => number;
				greaterThan: (other: string | number | Long.Long) => boolean;
				gt: (other: string | number | Long.Long) => boolean;
				greaterThanOrEqual: (other: string | number | Long.Long) => boolean;
				gte: (other: string | number | Long.Long) => boolean;
				isEven: () => boolean;
				isNegative: () => boolean;
				isOdd: () => boolean;
				isPositive: () => boolean;
				isZero: () => boolean;
				lessThan: (other: string | number | Long.Long) => boolean;
				lt: (other: string | number | Long.Long) => boolean;
				lessThanOrEqual: (other: string | number | Long.Long) => boolean;
				lte: (other: string | number | Long.Long) => boolean;
				modulo: (other: string | number | Long.Long) => Long.Long;
				mod: (other: string | number | Long.Long) => Long.Long;
				multiply: (multiplier: string | number | Long.Long) => Long.Long;
				mul: (multiplier: string | number | Long.Long) => Long.Long;
				negate: () => Long.Long;
				neg: () => Long.Long;
				not: () => Long.Long;
				notEquals: (other: string | number | Long.Long) => boolean;
				neq: (other: string | number | Long.Long) => boolean;
				or: (other: string | number | Long.Long) => Long.Long;
				shiftLeft: (numBits: number | Long.Long) => Long.Long;
				shl: (numBits: number | Long.Long) => Long.Long;
				shiftRight: (numBits: number | Long.Long) => Long.Long;
				shr: (numBits: number | Long.Long) => Long.Long;
				shiftRightUnsigned: (numBits: number | Long.Long) => Long.Long;
				shru: (numBits: number | Long.Long) => Long.Long;
				subtract: (subtrahend: string | number | Long.Long) => Long.Long;
				sub: (subtrahend: string | number | Long.Long) => Long.Long;
				toInt: () => number;
				toNumber: () => number;
				toBytes: (le?: boolean) => number[];
				toBytesLE: () => number[];
				toBytesBE: () => number[];
				toSigned: () => Long.Long;
				toString: (radix?: number) => string;
				toUnsigned: () => Long.Long;
				xor: (other: string | number | Long.Long) => Long.Long;
			} & Record<Exclude<keyof I["pagination"]["offset"], keyof Long.Long>, never>);
			limit?: string | number | (Long.Long & {
				high: number;
				low: number;
				unsigned: boolean;
				add: (addend: string | number | Long.Long) => Long.Long;
				and: (other: string | number | Long.Long) => Long.Long;
				compare: (other: string | number | Long.Long) => number;
				comp: (other: string | number | Long.Long) => number;
				divide: (divisor: string | number | Long.Long) => Long.Long;
				div: (divisor: string | number | Long.Long) => Long.Long;
				equals: (other: string | number | Long.Long) => boolean;
				eq: (other: string | number | Long.Long) => boolean;
				getHighBits: () => number;
				getHighBitsUnsigned: () => number;
				getLowBits: () => number;
				getLowBitsUnsigned: () => number;
				getNumBitsAbs: () => number;
				greaterThan: (other: string | number | Long.Long) => boolean;
				gt: (other: string | number | Long.Long) => boolean;
				greaterThanOrEqual: (other: string | number | Long.Long) => boolean;
				gte: (other: string | number | Long.Long) => boolean;
				isEven: () => boolean;
				isNegative: () => boolean;
				isOdd: () => boolean;
				isPositive: () => boolean;
				isZero: () => boolean;
				lessThan: (other: string | number | Long.Long) => boolean;
				lt: (other: string | number | Long.Long) => boolean;
				lessThanOrEqual: (other: string | number | Long.Long) => boolean;
				lte: (other: string | number | Long.Long) => boolean;
				modulo: (other: string | number | Long.Long) => Long.Long;
				mod: (other: string | number | Long.Long) => Long.Long;
				multiply: (multiplier: string | number | Long.Long) => Long.Long;
				mul: (multiplier: string | number | Long.Long) => Long.Long;
				negate: () => Long.Long;
				neg: () => Long.Long;
				not: () => Long.Long;
				notEquals: (other: string | number | Long.Long) => boolean;
				neq: (other: string | number | Long.Long) => boolean;
				or: (other: string | number | Long.Long) => Long.Long;
				shiftLeft: (numBits: number | Long.Long) => Long.Long;
				shl: (numBits: number | Long.Long) => Long.Long;
				shiftRight: (numBits: number | Long.Long) => Long.Long;
				shr: (numBits: number | Long.Long) => Long.Long;
				shiftRightUnsigned: (numBits: number | Long.Long) => Long.Long;
				shru: (numBits: number | Long.Long) => Long.Long;
				subtract: (subtrahend: string | number | Long.Long) => Long.Long;
				sub: (subtrahend: string | number | Long.Long) => Long.Long;
				toInt: () => number;
				toNumber: () => number;
				toBytes: (le?: boolean) => number[];
				toBytesLE: () => number[];
				toBytesBE: () => number[];
				toSigned: () => Long.Long;
				toString: (radix?: number) => string;
				toUnsigned: () => Long.Long;
				xor: (other: string | number | Long.Long) => Long.Long;
			} & Record<Exclude<keyof I["pagination"]["limit"], keyof Long.Long>, never>);
			countTotal?: boolean;
			reverse?: boolean;
		} & Record<Exclude<keyof I["pagination"], keyof PageRequest>, never>;
		orderBy?: OrderBy;
	} & Record<Exclude<keyof I, keyof GetTxsEventRequest>, never>>(object: I): GetTxsEventRequest;
};
declare const GetTxsEventResponse: {
	encode(message: GetTxsEventResponse, writer?: _m0.Writer): _m0.Writer;
	decode(input: _m0.Reader | Uint8Array, length?: number): GetTxsEventResponse;
	fromJSON(object: any): GetTxsEventResponse;
	toJSON(message: GetTxsEventResponse): unknown;
	fromPartial<I extends {
		txs?: {
			body?: {
				messages?: {
					typeUrl?: string;
					value?: Uint8Array;
				}[];
				memo?: string;
				timeoutHeight?: string | number | Long.Long;
				extensionOptions?: {
					typeUrl?: string;
					value?: Uint8Array;
				}[];
				nonCriticalExtensionOptions?: {
					typeUrl?: string;
					value?: Uint8Array;
				}[];
			};
			authInfo?: {
				signerInfos?: {
					publicKey?: {
						typeUrl?: string;
						value?: Uint8Array;
					};
					modeInfo?: {
						single?: {
							mode?: SignMode;
						};
						multi?: {
							bitarray?: {
								extraBitsStored?: number;
								elems?: Uint8Array;
							};
							modeInfos?: any[];
						};
					};
					sequence?: string | number | Long.Long;
				}[];
				fee?: {
					amount?: {
						denom?: string;
						amount?: string;
					}[];
					gasLimit?: string | number | Long.Long;
					payer?: string;
					granter?: string;
				};
			};
			signatures?: Uint8Array[];
		}[];
		txResponses?: {
			height?: string | number | Long.Long;
			txhash?: string;
			codespace?: string;
			code?: number;
			data?: string;
			rawLog?: string;
			logs?: {
				msgIndex?: number;
				log?: string;
				events?: {
					type?: string;
					attributes?: {
						key?: string;
						value?: string;
					}[];
				}[];
			}[];
			info?: string;
			gasWanted?: string | number | Long.Long;
			gasUsed?: string | number | Long.Long;
			tx?: {
				typeUrl?: string;
				value?: Uint8Array;
			};
			timestamp?: string;
		}[];
		pagination?: {
			nextKey?: Uint8Array;
			total?: string | number | Long.Long;
		};
	} & {
		txs?: {
			body?: {
				messages?: {
					typeUrl?: string;
					value?: Uint8Array;
				}[];
				memo?: string;
				timeoutHeight?: string | number | Long.Long;
				extensionOptions?: {
					typeUrl?: string;
					value?: Uint8Array;
				}[];
				nonCriticalExtensionOptions?: {
					typeUrl?: string;
					value?: Uint8Array;
				}[];
			};
			authInfo?: {
				signerInfos?: {
					publicKey?: {
						typeUrl?: string;
						value?: Uint8Array;
					};
					modeInfo?: {
						single?: {
							mode?: SignMode;
						};
						multi?: {
							bitarray?: {
								extraBitsStored?: number;
								elems?: Uint8Array;
							};
							modeInfos?: any[];
						};
					};
					sequence?: string | number | Long.Long;
				}[];
				fee?: {
					amount?: {
						denom?: string;
						amount?: string;
					}[];
					gasLimit?: string | number | Long.Long;
					payer?: string;
					granter?: string;
				};
			};
			signatures?: Uint8Array[];
		}[] & ({
			body?: {
				messages?: {
					typeUrl?: string;
					value?: Uint8Array;
				}[];
				memo?: string;
				timeoutHeight?: string | number | Long.Long;
				extensionOptions?: {
					typeUrl?: string;
					value?: Uint8Array;
				}[];
				nonCriticalExtensionOptions?: {
					typeUrl?: string;
					value?: Uint8Array;
				}[];
			};
			authInfo?: {
				signerInfos?: {
					publicKey?: {
						typeUrl?: string;
						value?: Uint8Array;
					};
					modeInfo?: {
						single?: {
							mode?: SignMode;
						};
						multi?: {
							bitarray?: {
								extraBitsStored?: number;
								elems?: Uint8Array;
							};
							modeInfos?: any[];
						};
					};
					sequence?: string | number | Long.Long;
				}[];
				fee?: {
					amount?: {
						denom?: string;
						amount?: string;
					}[];
					gasLimit?: string | number | Long.Long;
					payer?: string;
					granter?: string;
				};
			};
			signatures?: Uint8Array[];
		} & {
			body?: {
				messages?: {
					typeUrl?: string;
					value?: Uint8Array;
				}[];
				memo?: string;
				timeoutHeight?: string | number | Long.Long;
				extensionOptions?: {
					typeUrl?: string;
					value?: Uint8Array;
				}[];
				nonCriticalExtensionOptions?: {
					typeUrl?: string;
					value?: Uint8Array;
				}[];
			} & {
				messages?: {
					typeUrl?: string;
					value?: Uint8Array;
				}[] & ({
					typeUrl?: string;
					value?: Uint8Array;
				} & {
					typeUrl?: string;
					value?: Uint8Array;
				} & Record<Exclude<keyof I["txs"][number]["body"]["messages"][number], keyof Any>, never>)[] & Record<Exclude<keyof I["txs"][number]["body"]["messages"], keyof {
					typeUrl?: string;
					value?: Uint8Array;
				}[]>, never>;
				memo?: string;
				timeoutHeight?: string | number | (Long.Long & {
					high: number;
					low: number;
					unsigned: boolean;
					add: (addend: string | number | Long.Long) => Long.Long;
					and: (other: string | number | Long.Long) => Long.Long;
					compare: (other: string | number | Long.Long) => number;
					comp: (other: string | number | Long.Long) => number;
					divide: (divisor: string | number | Long.Long) => Long.Long;
					div: (divisor: string | number | Long.Long) => Long.Long;
					equals: (other: string | number | Long.Long) => boolean;
					eq: (other: string | number | Long.Long) => boolean;
					getHighBits: () => number;
					getHighBitsUnsigned: () => number;
					getLowBits: () => number;
					getLowBitsUnsigned: () => number;
					getNumBitsAbs: () => number;
					greaterThan: (other: string | number | Long.Long) => boolean;
					gt: (other: string | number | Long.Long) => boolean;
					greaterThanOrEqual: (other: string | number | Long.Long) => boolean;
					gte: (other: string | number | Long.Long) => boolean;
					isEven: () => boolean;
					isNegative: () => boolean;
					isOdd: () => boolean;
					isPositive: () => boolean;
					isZero: () => boolean;
					lessThan: (other: string | number | Long.Long) => boolean;
					lt: (other: string | number | Long.Long) => boolean;
					lessThanOrEqual: (other: string | number | Long.Long) => boolean;
					lte: (other: string | number | Long.Long) => boolean;
					modulo: (other: string | number | Long.Long) => Long.Long;
					mod: (other: string | number | Long.Long) => Long.Long;
					multiply: (multiplier: string | number | Long.Long) => Long.Long;
					mul: (multiplier: string | number | Long.Long) => Long.Long;
					negate: () => Long.Long;
					neg: () => Long.Long;
					not: () => Long.Long;
					notEquals: (other: string | number | Long.Long) => boolean;
					neq: (other: string | number | Long.Long) => boolean;
					or: (other: string | number | Long.Long) => Long.Long;
					shiftLeft: (numBits: number | Long.Long) => Long.Long;
					shl: (numBits: number | Long.Long) => Long.Long;
					shiftRight: (numBits: number | Long.Long) => Long.Long;
					shr: (numBits: number | Long.Long) => Long.Long;
					shiftRightUnsigned: (numBits: number | Long.Long) => Long.Long;
					shru: (numBits: number | Long.Long) => Long.Long;
					subtract: (subtrahend: string | number | Long.Long) => Long.Long;
					sub: (subtrahend: string | number | Long.Long) => Long.Long;
					toInt: () => number;
					toNumber: () => number;
					toBytes: (le?: boolean) => number[];
					toBytesLE: () => number[];
					toBytesBE: () => number[];
					toSigned: () => Long.Long;
					toString: (radix?: number) => string;
					toUnsigned: () => Long.Long;
					xor: (other: string | number | Long.Long) => Long.Long;
				} & Record<Exclude<keyof I["txs"][number]["body"]["timeoutHeight"], keyof Long.Long>, never>);
				extensionOptions?: {
					typeUrl?: string;
					value?: Uint8Array;
				}[] & ({
					typeUrl?: string;
					value?: Uint8Array;
				} & {
					typeUrl?: string;
					value?: Uint8Array;
				} & Record<Exclude<keyof I["txs"][number]["body"]["extensionOptions"][number], keyof Any>, never>)[] & Record<Exclude<keyof I["txs"][number]["body"]["extensionOptions"], keyof {
					typeUrl?: string;
					value?: Uint8Array;
				}[]>, never>;
				nonCriticalExtensionOptions?: {
					typeUrl?: string;
					value?: Uint8Array;
				}[] & ({
					typeUrl?: string;
					value?: Uint8Array;
				} & {
					typeUrl?: string;
					value?: Uint8Array;
				} & Record<Exclude<keyof I["txs"][number]["body"]["nonCriticalExtensionOptions"][number], keyof Any>, never>)[] & Record<Exclude<keyof I["txs"][number]["body"]["nonCriticalExtensionOptions"], keyof {
					typeUrl?: string;
					value?: Uint8Array;
				}[]>, never>;
			} & Record<Exclude<keyof I["txs"][number]["body"], keyof TxBody>, never>;
			authInfo?: {
				signerInfos?: {
					publicKey?: {
						typeUrl?: string;
						value?: Uint8Array;
					};
					modeInfo?: {
						single?: {
							mode?: SignMode;
						};
						multi?: {
							bitarray?: {
								extraBitsStored?: number;
								elems?: Uint8Array;
							};
							modeInfos?: any[];
						};
					};
					sequence?: string | number | Long.Long;
				}[];
				fee?: {
					amount?: {
						denom?: string;
						amount?: string;
					}[];
					gasLimit?: string | number | Long.Long;
					payer?: string;
					granter?: string;
				};
			} & {
				signerInfos?: {
					publicKey?: {
						typeUrl?: string;
						value?: Uint8Array;
					};
					modeInfo?: {
						single?: {
							mode?: SignMode;
						};
						multi?: {
							bitarray?: {
								extraBitsStored?: number;
								elems?: Uint8Array;
							};
							modeInfos?: any[];
						};
					};
					sequence?: string | number | Long.Long;
				}[] & ({
					publicKey?: {
						typeUrl?: string;
						value?: Uint8Array;
					};
					modeInfo?: {
						single?: {
							mode?: SignMode;
						};
						multi?: {
							bitarray?: {
								extraBitsStored?: number;
								elems?: Uint8Array;
							};
							modeInfos?: any[];
						};
					};
					sequence?: string | number | Long.Long;
				} & {
					publicKey?: {
						typeUrl?: string;
						value?: Uint8Array;
					} & {
						typeUrl?: string;
						value?: Uint8Array;
					} & Record<Exclude<keyof I["txs"][number]["authInfo"]["signerInfos"][number]["publicKey"], keyof Any>, never>;
					modeInfo?: {
						single?: {
							mode?: SignMode;
						};
						multi?: {
							bitarray?: {
								extraBitsStored?: number;
								elems?: Uint8Array;
							};
							modeInfos?: any[];
						};
					} & {
						single?: {
							mode?: SignMode;
						} & {
							mode?: SignMode;
						} & Record<Exclude<keyof I["txs"][number]["authInfo"]["signerInfos"][number]["modeInfo"]["single"], "mode">, never>;
						multi?: {
							bitarray?: {
								extraBitsStored?: number;
								elems?: Uint8Array;
							};
							modeInfos?: any[];
						} & {
							bitarray?: {
								extraBitsStored?: number;
								elems?: Uint8Array;
							} & {
								extraBitsStored?: number;
								elems?: Uint8Array;
							} & Record<Exclude<keyof I["txs"][number]["authInfo"]["signerInfos"][number]["modeInfo"]["multi"]["bitarray"], keyof CompactBitArray>, never>;
							modeInfos?: any[] & ({
								single?: {
									mode?: SignMode;
								};
								multi?: {
									bitarray?: {
										extraBitsStored?: number;
										elems?: Uint8Array;
									};
									modeInfos?: any[];
								};
							} & {
								single?: {
									mode?: SignMode;
								} & {
									mode?: SignMode;
								} & Record<Exclude<keyof I["txs"][number]["authInfo"]["signerInfos"][number]["modeInfo"]["multi"]["modeInfos"][number]["single"], "mode">, never>;
								multi?: {
									bitarray?: {
										extraBitsStored?: number;
										elems?: Uint8Array;
									};
									modeInfos?: any[];
								} & {
									bitarray?: {
										extraBitsStored?: number;
										elems?: Uint8Array;
									} & {
										extraBitsStored?: number;
										elems?: Uint8Array;
									} & Record<Exclude<keyof I["txs"][number]["authInfo"]["signerInfos"][number]["modeInfo"]["multi"]["modeInfos"][number]["multi"]["bitarray"], keyof CompactBitArray>, never>;
									modeInfos?: any[] & ({
										single?: {
											mode?: SignMode;
										};
										multi?: {
											bitarray?: {
												extraBitsStored?: number;
												elems?: Uint8Array;
											};
											modeInfos?: any[];
										};
									} & {
										single?: {
											mode?: SignMode;
										} & {
											mode?: SignMode;
										} & Record<Exclude<keyof I["txs"][number]["authInfo"]["signerInfos"][number]["modeInfo"]["multi"]["modeInfos"][number]["multi"]["modeInfos"][number]["single"], "mode">, never>;
										multi?: {
											bitarray?: {
												extraBitsStored?: number;
												elems?: Uint8Array;
											};
											modeInfos?: any[];
										} & {
											bitarray?: {
												extraBitsStored?: number;
												elems?: Uint8Array;
											} & {
												extraBitsStored?: number;
												elems?: Uint8Array;
											} & Record<Exclude<keyof I["txs"][number]["authInfo"]["signerInfos"][number]["modeInfo"]["multi"]["modeInfos"][number]["multi"]["modeInfos"][number]["multi"]["bitarray"], keyof CompactBitArray>, never>;
											modeInfos?: any[] & ({
												single?: {
													mode?: SignMode;
												};
												multi?: {
													bitarray?: {
														extraBitsStored?: number;
														elems?: Uint8Array;
													};
													modeInfos?: any[];
												};
											} & {
												single?: {
													mode?: SignMode;
												} & any & Record<Exclude<keyof I["txs"][number]["authInfo"]["signerInfos"][number]["modeInfo"]["multi"]["modeInfos"][number]["multi"]["modeInfos"][number]["multi"]["modeInfos"][number]["single"], "mode">, never>;
												multi?: {
													bitarray?: {
														extraBitsStored?: number;
														elems?: Uint8Array;
													};
													modeInfos?: any[];
												} & any & Record<Exclude<keyof I["txs"][number]["authInfo"]["signerInfos"][number]["modeInfo"]["multi"]["modeInfos"][number]["multi"]["modeInfos"][number]["multi"]["modeInfos"][number]["multi"], keyof ModeInfo_Multi>, never>;
											} & Record<Exclude<keyof I["txs"][number]["authInfo"]["signerInfos"][number]["modeInfo"]["multi"]["modeInfos"][number]["multi"]["modeInfos"][number]["multi"]["modeInfos"][number], keyof ModeInfo>, never>)[] & Record<Exclude<keyof I["txs"][number]["authInfo"]["signerInfos"][number]["modeInfo"]["multi"]["modeInfos"][number]["multi"]["modeInfos"][number]["multi"]["modeInfos"], keyof any[]>, never>;
										} & Record<Exclude<keyof I["txs"][number]["authInfo"]["signerInfos"][number]["modeInfo"]["multi"]["modeInfos"][number]["multi"]["modeInfos"][number]["multi"], keyof ModeInfo_Multi>, never>;
									} & Record<Exclude<keyof I["txs"][number]["authInfo"]["signerInfos"][number]["modeInfo"]["multi"]["modeInfos"][number]["multi"]["modeInfos"][number], keyof ModeInfo>, never>)[] & Record<Exclude<keyof I["txs"][number]["authInfo"]["signerInfos"][number]["modeInfo"]["multi"]["modeInfos"][number]["multi"]["modeInfos"], keyof any[]>, never>;
								} & Record<Exclude<keyof I["txs"][number]["authInfo"]["signerInfos"][number]["modeInfo"]["multi"]["modeInfos"][number]["multi"], keyof ModeInfo_Multi>, never>;
							} & Record<Exclude<keyof I["txs"][number]["authInfo"]["signerInfos"][number]["modeInfo"]["multi"]["modeInfos"][number], keyof ModeInfo>, never>)[] & Record<Exclude<keyof I["txs"][number]["authInfo"]["signerInfos"][number]["modeInfo"]["multi"]["modeInfos"], keyof any[]>, never>;
						} & Record<Exclude<keyof I["txs"][number]["authInfo"]["signerInfos"][number]["modeInfo"]["multi"], keyof ModeInfo_Multi>, never>;
					} & Record<Exclude<keyof I["txs"][number]["authInfo"]["signerInfos"][number]["modeInfo"], keyof ModeInfo>, never>;
					sequence?: string | number | (Long.Long & {
						high: number;
						low: number;
						unsigned: boolean;
						add: (addend: string | number | Long.Long) => Long.Long;
						and: (other: string | number | Long.Long) => Long.Long;
						compare: (other: string | number | Long.Long) => number;
						comp: (other: string | number | Long.Long) => number;
						divide: (divisor: string | number | Long.Long) => Long.Long;
						div: (divisor: string | number | Long.Long) => Long.Long;
						equals: (other: string | number | Long.Long) => boolean;
						eq: (other: string | number | Long.Long) => boolean;
						getHighBits: () => number;
						getHighBitsUnsigned: () => number;
						getLowBits: () => number;
						getLowBitsUnsigned: () => number;
						getNumBitsAbs: () => number;
						greaterThan: (other: string | number | Long.Long) => boolean;
						gt: (other: string | number | Long.Long) => boolean;
						greaterThanOrEqual: (other: string | number | Long.Long) => boolean;
						gte: (other: string | number | Long.Long) => boolean;
						isEven: () => boolean;
						isNegative: () => boolean;
						isOdd: () => boolean;
						isPositive: () => boolean;
						isZero: () => boolean;
						lessThan: (other: string | number | Long.Long) => boolean;
						lt: (other: string | number | Long.Long) => boolean;
						lessThanOrEqual: (other: string | number | Long.Long) => boolean;
						lte: (other: string | number | Long.Long) => boolean;
						modulo: (other: string | number | Long.Long) => Long.Long;
						mod: (other: string | number | Long.Long) => Long.Long;
						multiply: (multiplier: string | number | Long.Long) => Long.Long;
						mul: (multiplier: string | number | Long.Long) => Long.Long;
						negate: () => Long.Long;
						neg: () => Long.Long;
						not: () => Long.Long;
						notEquals: (other: string | number | Long.Long) => boolean;
						neq: (other: string | number | Long.Long) => boolean;
						or: (other: string | number | Long.Long) => Long.Long;
						shiftLeft: (numBits: number | Long.Long) => Long.Long;
						shl: (numBits: number | Long.Long) => Long.Long;
						shiftRight: (numBits: number | Long.Long) => Long.Long;
						shr: (numBits: number | Long.Long) => Long.Long;
						shiftRightUnsigned: (numBits: number | Long.Long) => Long.Long;
						shru: (numBits: number | Long.Long) => Long.Long;
						subtract: (subtrahend: string | number | Long.Long) => Long.Long;
						sub: (subtrahend: string | number | Long.Long) => Long.Long;
						toInt: () => number;
						toNumber: () => number;
						toBytes: (le?: boolean) => number[];
						toBytesLE: () => number[];
						toBytesBE: () => number[];
						toSigned: () => Long.Long;
						toString: (radix?: number) => string;
						toUnsigned: () => Long.Long;
						xor: (other: string | number | Long.Long) => Long.Long;
					} & Record<Exclude<keyof I["txs"][number]["authInfo"]["signerInfos"][number]["sequence"], keyof Long.Long>, never>);
				} & Record<Exclude<keyof I["txs"][number]["authInfo"]["signerInfos"][number], keyof SignerInfo>, never>)[] & Record<Exclude<keyof I["txs"][number]["authInfo"]["signerInfos"], keyof {
					publicKey?: {
						typeUrl?: string;
						value?: Uint8Array;
					};
					modeInfo?: {
						single?: {
							mode?: SignMode;
						};
						multi?: {
							bitarray?: {
								extraBitsStored?: number;
								elems?: Uint8Array;
							};
							modeInfos?: any[];
						};
					};
					sequence?: string | number | Long.Long;
				}[]>, never>;
				fee?: {
					amount?: {
						denom?: string;
						amount?: string;
					}[];
					gasLimit?: string | number | Long.Long;
					payer?: string;
					granter?: string;
				} & {
					amount?: {
						denom?: string;
						amount?: string;
					}[] & ({
						denom?: string;
						amount?: string;
					} & {
						denom?: string;
						amount?: string;
					} & Record<Exclude<keyof I["txs"][number]["authInfo"]["fee"]["amount"][number], keyof Coin>, never>)[] & Record<Exclude<keyof I["txs"][number]["authInfo"]["fee"]["amount"], keyof {
						denom?: string;
						amount?: string;
					}[]>, never>;
					gasLimit?: string | number | (Long.Long & {
						high: number;
						low: number;
						unsigned: boolean;
						add: (addend: string | number | Long.Long) => Long.Long;
						and: (other: string | number | Long.Long) => Long.Long;
						compare: (other: string | number | Long.Long) => number;
						comp: (other: string | number | Long.Long) => number;
						divide: (divisor: string | number | Long.Long) => Long.Long;
						div: (divisor: string | number | Long.Long) => Long.Long;
						equals: (other: string | number | Long.Long) => boolean;
						eq: (other: string | number | Long.Long) => boolean;
						getHighBits: () => number;
						getHighBitsUnsigned: () => number;
						getLowBits: () => number;
						getLowBitsUnsigned: () => number;
						getNumBitsAbs: () => number;
						greaterThan: (other: string | number | Long.Long) => boolean;
						gt: (other: string | number | Long.Long) => boolean;
						greaterThanOrEqual: (other: string | number | Long.Long) => boolean;
						gte: (other: string | number | Long.Long) => boolean;
						isEven: () => boolean;
						isNegative: () => boolean;
						isOdd: () => boolean;
						isPositive: () => boolean;
						isZero: () => boolean;
						lessThan: (other: string | number | Long.Long) => boolean;
						lt: (other: string | number | Long.Long) => boolean;
						lessThanOrEqual: (other: string | number | Long.Long) => boolean;
						lte: (other: string | number | Long.Long) => boolean;
						modulo: (other: string | number | Long.Long) => Long.Long;
						mod: (other: string | number | Long.Long) => Long.Long;
						multiply: (multiplier: string | number | Long.Long) => Long.Long;
						mul: (multiplier: string | number | Long.Long) => Long.Long;
						negate: () => Long.Long;
						neg: () => Long.Long;
						not: () => Long.Long;
						notEquals: (other: string | number | Long.Long) => boolean;
						neq: (other: string | number | Long.Long) => boolean;
						or: (other: string | number | Long.Long) => Long.Long;
						shiftLeft: (numBits: number | Long.Long) => Long.Long;
						shl: (numBits: number | Long.Long) => Long.Long;
						shiftRight: (numBits: number | Long.Long) => Long.Long;
						shr: (numBits: number | Long.Long) => Long.Long;
						shiftRightUnsigned: (numBits: number | Long.Long) => Long.Long;
						shru: (numBits: number | Long.Long) => Long.Long;
						subtract: (subtrahend: string | number | Long.Long) => Long.Long;
						sub: (subtrahend: string | number | Long.Long) => Long.Long;
						toInt: () => number;
						toNumber: () => number;
						toBytes: (le?: boolean) => number[];
						toBytesLE: () => number[];
						toBytesBE: () => number[];
						toSigned: () => Long.Long;
						toString: (radix?: number) => string;
						toUnsigned: () => Long.Long;
						xor: (other: string | number | Long.Long) => Long.Long;
					} & Record<Exclude<keyof I["txs"][number]["authInfo"]["fee"]["gasLimit"], keyof Long.Long>, never>);
					payer?: string;
					granter?: string;
				} & Record<Exclude<keyof I["txs"][number]["authInfo"]["fee"], keyof Fee>, never>;
			} & Record<Exclude<keyof I["txs"][number]["authInfo"], keyof AuthInfo>, never>;
			signatures?: Uint8Array[] & Uint8Array[] & Record<Exclude<keyof I["txs"][number]["signatures"], keyof Uint8Array[]>, never>;
		} & Record<Exclude<keyof I["txs"][number], keyof Tx>, never>)[] & Record<Exclude<keyof I["txs"], keyof {
			body?: {
				messages?: {
					typeUrl?: string;
					value?: Uint8Array;
				}[];
				memo?: string;
				timeoutHeight?: string | number | Long.Long;
				extensionOptions?: {
					typeUrl?: string;
					value?: Uint8Array;
				}[];
				nonCriticalExtensionOptions?: {
					typeUrl?: string;
					value?: Uint8Array;
				}[];
			};
			authInfo?: {
				signerInfos?: {
					publicKey?: {
						typeUrl?: string;
						value?: Uint8Array;
					};
					modeInfo?: {
						single?: {
							mode?: SignMode;
						};
						multi?: {
							bitarray?: {
								extraBitsStored?: number;
								elems?: Uint8Array;
							};
							modeInfos?: any[];
						};
					};
					sequence?: string | number | Long.Long;
				}[];
				fee?: {
					amount?: {
						denom?: string;
						amount?: string;
					}[];
					gasLimit?: string | number | Long.Long;
					payer?: string;
					granter?: string;
				};
			};
			signatures?: Uint8Array[];
		}[]>, never>;
		txResponses?: {
			height?: string | number | Long.Long;
			txhash?: string;
			codespace?: string;
			code?: number;
			data?: string;
			rawLog?: string;
			logs?: {
				msgIndex?: number;
				log?: string;
				events?: {
					type?: string;
					attributes?: {
						key?: string;
						value?: string;
					}[];
				}[];
			}[];
			info?: string;
			gasWanted?: string | number | Long.Long;
			gasUsed?: string | number | Long.Long;
			tx?: {
				typeUrl?: string;
				value?: Uint8Array;
			};
			timestamp?: string;
		}[] & ({
			height?: string | number | Long.Long;
			txhash?: string;
			codespace?: string;
			code?: number;
			data?: string;
			rawLog?: string;
			logs?: {
				msgIndex?: number;
				log?: string;
				events?: {
					type?: string;
					attributes?: {
						key?: string;
						value?: string;
					}[];
				}[];
			}[];
			info?: string;
			gasWanted?: string | number | Long.Long;
			gasUsed?: string | number | Long.Long;
			tx?: {
				typeUrl?: string;
				value?: Uint8Array;
			};
			timestamp?: string;
		} & {
			height?: string | number | (Long.Long & {
				high: number;
				low: number;
				unsigned: boolean;
				add: (addend: string | number | Long.Long) => Long.Long;
				and: (other: string | number | Long.Long) => Long.Long;
				compare: (other: string | number | Long.Long) => number;
				comp: (other: string | number | Long.Long) => number;
				divide: (divisor: string | number | Long.Long) => Long.Long;
				div: (divisor: string | number | Long.Long) => Long.Long;
				equals: (other: string | number | Long.Long) => boolean;
				eq: (other: string | number | Long.Long) => boolean;
				getHighBits: () => number;
				getHighBitsUnsigned: () => number;
				getLowBits: () => number;
				getLowBitsUnsigned: () => number;
				getNumBitsAbs: () => number;
				greaterThan: (other: string | number | Long.Long) => boolean;
				gt: (other: string | number | Long.Long) => boolean;
				greaterThanOrEqual: (other: string | number | Long.Long) => boolean;
				gte: (other: string | number | Long.Long) => boolean;
				isEven: () => boolean;
				isNegative: () => boolean;
				isOdd: () => boolean;
				isPositive: () => boolean;
				isZero: () => boolean;
				lessThan: (other: string | number | Long.Long) => boolean;
				lt: (other: string | number | Long.Long) => boolean;
				lessThanOrEqual: (other: string | number | Long.Long) => boolean;
				lte: (other: string | number | Long.Long) => boolean;
				modulo: (other: string | number | Long.Long) => Long.Long;
				mod: (other: string | number | Long.Long) => Long.Long;
				multiply: (multiplier: string | number | Long.Long) => Long.Long;
				mul: (multiplier: string | number | Long.Long) => Long.Long;
				negate: () => Long.Long;
				neg: () => Long.Long;
				not: () => Long.Long;
				notEquals: (other: string | number | Long.Long) => boolean;
				neq: (other: string | number | Long.Long) => boolean;
				or: (other: string | number | Long.Long) => Long.Long;
				shiftLeft: (numBits: number | Long.Long) => Long.Long;
				shl: (numBits: number | Long.Long) => Long.Long;
				shiftRight: (numBits: number | Long.Long) => Long.Long;
				shr: (numBits: number | Long.Long) => Long.Long;
				shiftRightUnsigned: (numBits: number | Long.Long) => Long.Long;
				shru: (numBits: number | Long.Long) => Long.Long;
				subtract: (subtrahend: string | number | Long.Long) => Long.Long;
				sub: (subtrahend: string | number | Long.Long) => Long.Long;
				toInt: () => number;
				toNumber: () => number;
				toBytes: (le?: boolean) => number[];
				toBytesLE: () => number[];
				toBytesBE: () => number[];
				toSigned: () => Long.Long;
				toString: (radix?: number) => string;
				toUnsigned: () => Long.Long;
				xor: (other: string | number | Long.Long) => Long.Long;
			} & Record<Exclude<keyof I["txResponses"][number]["height"], keyof Long.Long>, never>);
			txhash?: string;
			codespace?: string;
			code?: number;
			data?: string;
			rawLog?: string;
			logs?: {
				msgIndex?: number;
				log?: string;
				events?: {
					type?: string;
					attributes?: {
						key?: string;
						value?: string;
					}[];
				}[];
			}[] & ({
				msgIndex?: number;
				log?: string;
				events?: {
					type?: string;
					attributes?: {
						key?: string;
						value?: string;
					}[];
				}[];
			} & {
				msgIndex?: number;
				log?: string;
				events?: {
					type?: string;
					attributes?: {
						key?: string;
						value?: string;
					}[];
				}[] & ({
					type?: string;
					attributes?: {
						key?: string;
						value?: string;
					}[];
				} & {
					type?: string;
					attributes?: {
						key?: string;
						value?: string;
					}[] & ({
						key?: string;
						value?: string;
					} & {
						key?: string;
						value?: string;
					} & Record<Exclude<keyof I["txResponses"][number]["logs"][number]["events"][number]["attributes"][number], keyof Attribute>, never>)[] & Record<Exclude<keyof I["txResponses"][number]["logs"][number]["events"][number]["attributes"], keyof {
						key?: string;
						value?: string;
					}[]>, never>;
				} & Record<Exclude<keyof I["txResponses"][number]["logs"][number]["events"][number], keyof StringEvent>, never>)[] & Record<Exclude<keyof I["txResponses"][number]["logs"][number]["events"], keyof {
					type?: string;
					attributes?: {
						key?: string;
						value?: string;
					}[];
				}[]>, never>;
			} & Record<Exclude<keyof I["txResponses"][number]["logs"][number], keyof ABCIMessageLog>, never>)[] & Record<Exclude<keyof I["txResponses"][number]["logs"], keyof {
				msgIndex?: number;
				log?: string;
				events?: {
					type?: string;
					attributes?: {
						key?: string;
						value?: string;
					}[];
				}[];
			}[]>, never>;
			info?: string;
			gasWanted?: string | number | (Long.Long & {
				high: number;
				low: number;
				unsigned: boolean;
				add: (addend: string | number | Long.Long) => Long.Long;
				and: (other: string | number | Long.Long) => Long.Long;
				compare: (other: string | number | Long.Long) => number;
				comp: (other: string | number | Long.Long) => number;
				divide: (divisor: string | number | Long.Long) => Long.Long;
				div: (divisor: string | number | Long.Long) => Long.Long;
				equals: (other: string | number | Long.Long) => boolean;
				eq: (other: string | number | Long.Long) => boolean;
				getHighBits: () => number;
				getHighBitsUnsigned: () => number;
				getLowBits: () => number;
				getLowBitsUnsigned: () => number;
				getNumBitsAbs: () => number;
				greaterThan: (other: string | number | Long.Long) => boolean;
				gt: (other: string | number | Long.Long) => boolean;
				greaterThanOrEqual: (other: string | number | Long.Long) => boolean;
				gte: (other: string | number | Long.Long) => boolean;
				isEven: () => boolean;
				isNegative: () => boolean;
				isOdd: () => boolean;
				isPositive: () => boolean;
				isZero: () => boolean;
				lessThan: (other: string | number | Long.Long) => boolean;
				lt: (other: string | number | Long.Long) => boolean;
				lessThanOrEqual: (other: string | number | Long.Long) => boolean;
				lte: (other: string | number | Long.Long) => boolean;
				modulo: (other: string | number | Long.Long) => Long.Long;
				mod: (other: string | number | Long.Long) => Long.Long;
				multiply: (multiplier: string | number | Long.Long) => Long.Long;
				mul: (multiplier: string | number | Long.Long) => Long.Long;
				negate: () => Long.Long;
				neg: () => Long.Long;
				not: () => Long.Long;
				notEquals: (other: string | number | Long.Long) => boolean;
				neq: (other: string | number | Long.Long) => boolean;
				or: (other: string | number | Long.Long) => Long.Long;
				shiftLeft: (numBits: number | Long.Long) => Long.Long;
				shl: (numBits: number | Long.Long) => Long.Long;
				shiftRight: (numBits: number | Long.Long) => Long.Long;
				shr: (numBits: number | Long.Long) => Long.Long;
				shiftRightUnsigned: (numBits: number | Long.Long) => Long.Long;
				shru: (numBits: number | Long.Long) => Long.Long;
				subtract: (subtrahend: string | number | Long.Long) => Long.Long;
				sub: (subtrahend: string | number | Long.Long) => Long.Long;
				toInt: () => number;
				toNumber: () => number;
				toBytes: (le?: boolean) => number[];
				toBytesLE: () => number[];
				toBytesBE: () => number[];
				toSigned: () => Long.Long;
				toString: (radix?: number) => string;
				toUnsigned: () => Long.Long;
				xor: (other: string | number | Long.Long) => Long.Long;
			} & Record<Exclude<keyof I["txResponses"][number]["gasWanted"], keyof Long.Long>, never>);
			gasUsed?: string | number | (Long.Long & {
				high: number;
				low: number;
				unsigned: boolean;
				add: (addend: string | number | Long.Long) => Long.Long;
				and: (other: string | number | Long.Long) => Long.Long;
				compare: (other: string | number | Long.Long) => number;
				comp: (other: string | number | Long.Long) => number;
				divide: (divisor: string | number | Long.Long) => Long.Long;
				div: (divisor: string | number | Long.Long) => Long.Long;
				equals: (other: string | number | Long.Long) => boolean;
				eq: (other: string | number | Long.Long) => boolean;
				getHighBits: () => number;
				getHighBitsUnsigned: () => number;
				getLowBits: () => number;
				getLowBitsUnsigned: () => number;
				getNumBitsAbs: () => number;
				greaterThan: (other: string | number | Long.Long) => boolean;
				gt: (other: string | number | Long.Long) => boolean;
				greaterThanOrEqual: (other: string | number | Long.Long) => boolean;
				gte: (other: string | number | Long.Long) => boolean;
				isEven: () => boolean;
				isNegative: () => boolean;
				isOdd: () => boolean;
				isPositive: () => boolean;
				isZero: () => boolean;
				lessThan: (other: string | number | Long.Long) => boolean;
				lt: (other: string | number | Long.Long) => boolean;
				lessThanOrEqual: (other: string | number | Long.Long) => boolean;
				lte: (other: string | number | Long.Long) => boolean;
				modulo: (other: string | number | Long.Long) => Long.Long;
				mod: (other: string | number | Long.Long) => Long.Long;
				multiply: (multiplier: string | number | Long.Long) => Long.Long;
				mul: (multiplier: string | number | Long.Long) => Long.Long;
				negate: () => Long.Long;
				neg: () => Long.Long;
				not: () => Long.Long;
				notEquals: (other: string | number | Long.Long) => boolean;
				neq: (other: string | number | Long.Long) => boolean;
				or: (other: string | number | Long.Long) => Long.Long;
				shiftLeft: (numBits: number | Long.Long) => Long.Long;
				shl: (numBits: number | Long.Long) => Long.Long;
				shiftRight: (numBits: number | Long.Long) => Long.Long;
				shr: (numBits: number | Long.Long) => Long.Long;
				shiftRightUnsigned: (numBits: number | Long.Long) => Long.Long;
				shru: (numBits: number | Long.Long) => Long.Long;
				subtract: (subtrahend: string | number | Long.Long) => Long.Long;
				sub: (subtrahend: string | number | Long.Long) => Long.Long;
				toInt: () => number;
				toNumber: () => number;
				toBytes: (le?: boolean) => number[];
				toBytesLE: () => number[];
				toBytesBE: () => number[];
				toSigned: () => Long.Long;
				toString: (radix?: number) => string;
				toUnsigned: () => Long.Long;
				xor: (other: string | number | Long.Long) => Long.Long;
			} & Record<Exclude<keyof I["txResponses"][number]["gasUsed"], keyof Long.Long>, never>);
			tx?: {
				typeUrl?: string;
				value?: Uint8Array;
			} & {
				typeUrl?: string;
				value?: Uint8Array;
			} & Record<Exclude<keyof I["txResponses"][number]["tx"], keyof Any>, never>;
			timestamp?: string;
		} & Record<Exclude<keyof I["txResponses"][number], keyof TxResponse>, never>)[] & Record<Exclude<keyof I["txResponses"], keyof {
			height?: string | number | Long.Long;
			txhash?: string;
			codespace?: string;
			code?: number;
			data?: string;
			rawLog?: string;
			logs?: {
				msgIndex?: number;
				log?: string;
				events?: {
					type?: string;
					attributes?: {
						key?: string;
						value?: string;
					}[];
				}[];
			}[];
			info?: string;
			gasWanted?: string | number | Long.Long;
			gasUsed?: string | number | Long.Long;
			tx?: {
				typeUrl?: string;
				value?: Uint8Array;
			};
			timestamp?: string;
		}[]>, never>;
		pagination?: {
			nextKey?: Uint8Array;
			total?: string | number | Long.Long;
		} & {
			nextKey?: Uint8Array;
			total?: string | number | (Long.Long & {
				high: number;
				low: number;
				unsigned: boolean;
				add: (addend: string | number | Long.Long) => Long.Long;
				and: (other: string | number | Long.Long) => Long.Long;
				compare: (other: string | number | Long.Long) => number;
				comp: (other: string | number | Long.Long) => number;
				divide: (divisor: string | number | Long.Long) => Long.Long;
				div: (divisor: string | number | Long.Long) => Long.Long;
				equals: (other: string | number | Long.Long) => boolean;
				eq: (other: string | number | Long.Long) => boolean;
				getHighBits: () => number;
				getHighBitsUnsigned: () => number;
				getLowBits: () => number;
				getLowBitsUnsigned: () => number;
				getNumBitsAbs: () => number;
				greaterThan: (other: string | number | Long.Long) => boolean;
				gt: (other: string | number | Long.Long) => boolean;
				greaterThanOrEqual: (other: string | number | Long.Long) => boolean;
				gte: (other: string | number | Long.Long) => boolean;
				isEven: () => boolean;
				isNegative: () => boolean;
				isOdd: () => boolean;
				isPositive: () => boolean;
				isZero: () => boolean;
				lessThan: (other: string | number | Long.Long) => boolean;
				lt: (other: string | number | Long.Long) => boolean;
				lessThanOrEqual: (other: string | number | Long.Long) => boolean;
				lte: (other: string | number | Long.Long) => boolean;
				modulo: (other: string | number | Long.Long) => Long.Long;
				mod: (other: string | number | Long.Long) => Long.Long;
				multiply: (multiplier: string | number | Long.Long) => Long.Long;
				mul: (multiplier: string | number | Long.Long) => Long.Long;
				negate: () => Long.Long;
				neg: () => Long.Long;
				not: () => Long.Long;
				notEquals: (other: string | number | Long.Long) => boolean;
				neq: (other: string | number | Long.Long) => boolean;
				or: (other: string | number | Long.Long) => Long.Long;
				shiftLeft: (numBits: number | Long.Long) => Long.Long;
				shl: (numBits: number | Long.Long) => Long.Long;
				shiftRight: (numBits: number | Long.Long) => Long.Long;
				shr: (numBits: number | Long.Long) => Long.Long;
				shiftRightUnsigned: (numBits: number | Long.Long) => Long.Long;
				shru: (numBits: number | Long.Long) => Long.Long;
				subtract: (subtrahend: string | number | Long.Long) => Long.Long;
				sub: (subtrahend: string | number | Long.Long) => Long.Long;
				toInt: () => number;
				toNumber: () => number;
				toBytes: (le?: boolean) => number[];
				toBytesLE: () => number[];
				toBytesBE: () => number[];
				toSigned: () => Long.Long;
				toString: (radix?: number) => string;
				toUnsigned: () => Long.Long;
				xor: (other: string | number | Long.Long) => Long.Long;
			} & Record<Exclude<keyof I["pagination"]["total"], keyof Long.Long>, never>);
		} & Record<Exclude<keyof I["pagination"], keyof PageResponse>, never>;
	} & Record<Exclude<keyof I, keyof GetTxsEventResponse>, never>>(object: I): GetTxsEventResponse;
};
declare const BroadcastTxRequest: {
	encode(message: BroadcastTxRequest, writer?: _m0.Writer): _m0.Writer;
	decode(input: _m0.Reader | Uint8Array, length?: number): BroadcastTxRequest;
	fromJSON(object: any): BroadcastTxRequest;
	toJSON(message: BroadcastTxRequest): unknown;
	fromPartial<I extends {
		txBytes?: Uint8Array;
		mode?: BroadcastMode;
	} & {
		txBytes?: Uint8Array;
		mode?: BroadcastMode;
	} & Record<Exclude<keyof I, keyof BroadcastTxRequest>, never>>(object: I): BroadcastTxRequest;
};
declare const BroadcastTxResponse: {
	encode(message: BroadcastTxResponse, writer?: _m0.Writer): _m0.Writer;
	decode(input: _m0.Reader | Uint8Array, length?: number): BroadcastTxResponse;
	fromJSON(object: any): BroadcastTxResponse;
	toJSON(message: BroadcastTxResponse): unknown;
	fromPartial<I extends {
		txResponse?: {
			height?: string | number | Long.Long;
			txhash?: string;
			codespace?: string;
			code?: number;
			data?: string;
			rawLog?: string;
			logs?: {
				msgIndex?: number;
				log?: string;
				events?: {
					type?: string;
					attributes?: {
						key?: string;
						value?: string;
					}[];
				}[];
			}[];
			info?: string;
			gasWanted?: string | number | Long.Long;
			gasUsed?: string | number | Long.Long;
			tx?: {
				typeUrl?: string;
				value?: Uint8Array;
			};
			timestamp?: string;
		};
	} & {
		txResponse?: {
			height?: string | number | Long.Long;
			txhash?: string;
			codespace?: string;
			code?: number;
			data?: string;
			rawLog?: string;
			logs?: {
				msgIndex?: number;
				log?: string;
				events?: {
					type?: string;
					attributes?: {
						key?: string;
						value?: string;
					}[];
				}[];
			}[];
			info?: string;
			gasWanted?: string | number | Long.Long;
			gasUsed?: string | number | Long.Long;
			tx?: {
				typeUrl?: string;
				value?: Uint8Array;
			};
			timestamp?: string;
		} & {
			height?: string | number | (Long.Long & {
				high: number;
				low: number;
				unsigned: boolean;
				add: (addend: string | number | Long.Long) => Long.Long;
				and: (other: string | number | Long.Long) => Long.Long;
				compare: (other: string | number | Long.Long) => number;
				comp: (other: string | number | Long.Long) => number;
				divide: (divisor: string | number | Long.Long) => Long.Long;
				div: (divisor: string | number | Long.Long) => Long.Long;
				equals: (other: string | number | Long.Long) => boolean;
				eq: (other: string | number | Long.Long) => boolean;
				getHighBits: () => number;
				getHighBitsUnsigned: () => number;
				getLowBits: () => number;
				getLowBitsUnsigned: () => number;
				getNumBitsAbs: () => number;
				greaterThan: (other: string | number | Long.Long) => boolean;
				gt: (other: string | number | Long.Long) => boolean;
				greaterThanOrEqual: (other: string | number | Long.Long) => boolean;
				gte: (other: string | number | Long.Long) => boolean;
				isEven: () => boolean;
				isNegative: () => boolean;
				isOdd: () => boolean;
				isPositive: () => boolean;
				isZero: () => boolean;
				lessThan: (other: string | number | Long.Long) => boolean;
				lt: (other: string | number | Long.Long) => boolean;
				lessThanOrEqual: (other: string | number | Long.Long) => boolean;
				lte: (other: string | number | Long.Long) => boolean;
				modulo: (other: string | number | Long.Long) => Long.Long;
				mod: (other: string | number | Long.Long) => Long.Long;
				multiply: (multiplier: string | number | Long.Long) => Long.Long;
				mul: (multiplier: string | number | Long.Long) => Long.Long;
				negate: () => Long.Long;
				neg: () => Long.Long;
				not: () => Long.Long;
				notEquals: (other: string | number | Long.Long) => boolean;
				neq: (other: string | number | Long.Long) => boolean;
				or: (other: string | number | Long.Long) => Long.Long;
				shiftLeft: (numBits: number | Long.Long) => Long.Long;
				shl: (numBits: number | Long.Long) => Long.Long;
				shiftRight: (numBits: number | Long.Long) => Long.Long;
				shr: (numBits: number | Long.Long) => Long.Long;
				shiftRightUnsigned: (numBits: number | Long.Long) => Long.Long;
				shru: (numBits: number | Long.Long) => Long.Long;
				subtract: (subtrahend: string | number | Long.Long) => Long.Long;
				sub: (subtrahend: string | number | Long.Long) => Long.Long;
				toInt: () => number;
				toNumber: () => number;
				toBytes: (le?: boolean) => number[];
				toBytesLE: () => number[];
				toBytesBE: () => number[];
				toSigned: () => Long.Long;
				toString: (radix?: number) => string;
				toUnsigned: () => Long.Long;
				xor: (other: string | number | Long.Long) => Long.Long;
			} & Record<Exclude<keyof I["txResponse"]["height"], keyof Long.Long>, never>);
			txhash?: string;
			codespace?: string;
			code?: number;
			data?: string;
			rawLog?: string;
			logs?: {
				msgIndex?: number;
				log?: string;
				events?: {
					type?: string;
					attributes?: {
						key?: string;
						value?: string;
					}[];
				}[];
			}[] & ({
				msgIndex?: number;
				log?: string;
				events?: {
					type?: string;
					attributes?: {
						key?: string;
						value?: string;
					}[];
				}[];
			} & {
				msgIndex?: number;
				log?: string;
				events?: {
					type?: string;
					attributes?: {
						key?: string;
						value?: string;
					}[];
				}[] & ({
					type?: string;
					attributes?: {
						key?: string;
						value?: string;
					}[];
				} & {
					type?: string;
					attributes?: {
						key?: string;
						value?: string;
					}[] & ({
						key?: string;
						value?: string;
					} & {
						key?: string;
						value?: string;
					} & Record<Exclude<keyof I["txResponse"]["logs"][number]["events"][number]["attributes"][number], keyof Attribute>, never>)[] & Record<Exclude<keyof I["txResponse"]["logs"][number]["events"][number]["attributes"], keyof {
						key?: string;
						value?: string;
					}[]>, never>;
				} & Record<Exclude<keyof I["txResponse"]["logs"][number]["events"][number], keyof StringEvent>, never>)[] & Record<Exclude<keyof I["txResponse"]["logs"][number]["events"], keyof {
					type?: string;
					attributes?: {
						key?: string;
						value?: string;
					}[];
				}[]>, never>;
			} & Record<Exclude<keyof I["txResponse"]["logs"][number], keyof ABCIMessageLog>, never>)[] & Record<Exclude<keyof I["txResponse"]["logs"], keyof {
				msgIndex?: number;
				log?: string;
				events?: {
					type?: string;
					attributes?: {
						key?: string;
						value?: string;
					}[];
				}[];
			}[]>, never>;
			info?: string;
			gasWanted?: string | number | (Long.Long & {
				high: number;
				low: number;
				unsigned: boolean;
				add: (addend: string | number | Long.Long) => Long.Long;
				and: (other: string | number | Long.Long) => Long.Long;
				compare: (other: string | number | Long.Long) => number;
				comp: (other: string | number | Long.Long) => number;
				divide: (divisor: string | number | Long.Long) => Long.Long;
				div: (divisor: string | number | Long.Long) => Long.Long;
				equals: (other: string | number | Long.Long) => boolean;
				eq: (other: string | number | Long.Long) => boolean;
				getHighBits: () => number;
				getHighBitsUnsigned: () => number;
				getLowBits: () => number;
				getLowBitsUnsigned: () => number;
				getNumBitsAbs: () => number;
				greaterThan: (other: string | number | Long.Long) => boolean;
				gt: (other: string | number | Long.Long) => boolean;
				greaterThanOrEqual: (other: string | number | Long.Long) => boolean;
				gte: (other: string | number | Long.Long) => boolean;
				isEven: () => boolean;
				isNegative: () => boolean;
				isOdd: () => boolean;
				isPositive: () => boolean;
				isZero: () => boolean;
				lessThan: (other: string | number | Long.Long) => boolean;
				lt: (other: string | number | Long.Long) => boolean;
				lessThanOrEqual: (other: string | number | Long.Long) => boolean;
				lte: (other: string | number | Long.Long) => boolean;
				modulo: (other: string | number | Long.Long) => Long.Long;
				mod: (other: string | number | Long.Long) => Long.Long;
				multiply: (multiplier: string | number | Long.Long) => Long.Long;
				mul: (multiplier: string | number | Long.Long) => Long.Long;
				negate: () => Long.Long;
				neg: () => Long.Long;
				not: () => Long.Long;
				notEquals: (other: string | number | Long.Long) => boolean;
				neq: (other: string | number | Long.Long) => boolean;
				or: (other: string | number | Long.Long) => Long.Long;
				shiftLeft: (numBits: number | Long.Long) => Long.Long;
				shl: (numBits: number | Long.Long) => Long.Long;
				shiftRight: (numBits: number | Long.Long) => Long.Long;
				shr: (numBits: number | Long.Long) => Long.Long;
				shiftRightUnsigned: (numBits: number | Long.Long) => Long.Long;
				shru: (numBits: number | Long.Long) => Long.Long;
				subtract: (subtrahend: string | number | Long.Long) => Long.Long;
				sub: (subtrahend: string | number | Long.Long) => Long.Long;
				toInt: () => number;
				toNumber: () => number;
				toBytes: (le?: boolean) => number[];
				toBytesLE: () => number[];
				toBytesBE: () => number[];
				toSigned: () => Long.Long;
				toString: (radix?: number) => string;
				toUnsigned: () => Long.Long;
				xor: (other: string | number | Long.Long) => Long.Long;
			} & Record<Exclude<keyof I["txResponse"]["gasWanted"], keyof Long.Long>, never>);
			gasUsed?: string | number | (Long.Long & {
				high: number;
				low: number;
				unsigned: boolean;
				add: (addend: string | number | Long.Long) => Long.Long;
				and: (other: string | number | Long.Long) => Long.Long;
				compare: (other: string | number | Long.Long) => number;
				comp: (other: string | number | Long.Long) => number;
				divide: (divisor: string | number | Long.Long) => Long.Long;
				div: (divisor: string | number | Long.Long) => Long.Long;
				equals: (other: string | number | Long.Long) => boolean;
				eq: (other: string | number | Long.Long) => boolean;
				getHighBits: () => number;
				getHighBitsUnsigned: () => number;
				getLowBits: () => number;
				getLowBitsUnsigned: () => number;
				getNumBitsAbs: () => number;
				greaterThan: (other: string | number | Long.Long) => boolean;
				gt: (other: string | number | Long.Long) => boolean;
				greaterThanOrEqual: (other: string | number | Long.Long) => boolean;
				gte: (other: string | number | Long.Long) => boolean;
				isEven: () => boolean;
				isNegative: () => boolean;
				isOdd: () => boolean;
				isPositive: () => boolean;
				isZero: () => boolean;
				lessThan: (other: string | number | Long.Long) => boolean;
				lt: (other: string | number | Long.Long) => boolean;
				lessThanOrEqual: (other: string | number | Long.Long) => boolean;
				lte: (other: string | number | Long.Long) => boolean;
				modulo: (other: string | number | Long.Long) => Long.Long;
				mod: (other: string | number | Long.Long) => Long.Long;
				multiply: (multiplier: string | number | Long.Long) => Long.Long;
				mul: (multiplier: string | number | Long.Long) => Long.Long;
				negate: () => Long.Long;
				neg: () => Long.Long;
				not: () => Long.Long;
				notEquals: (other: string | number | Long.Long) => boolean;
				neq: (other: string | number | Long.Long) => boolean;
				or: (other: string | number | Long.Long) => Long.Long;
				shiftLeft: (numBits: number | Long.Long) => Long.Long;
				shl: (numBits: number | Long.Long) => Long.Long;
				shiftRight: (numBits: number | Long.Long) => Long.Long;
				shr: (numBits: number | Long.Long) => Long.Long;
				shiftRightUnsigned: (numBits: number | Long.Long) => Long.Long;
				shru: (numBits: number | Long.Long) => Long.Long;
				subtract: (subtrahend: string | number | Long.Long) => Long.Long;
				sub: (subtrahend: string | number | Long.Long) => Long.Long;
				toInt: () => number;
				toNumber: () => number;
				toBytes: (le?: boolean) => number[];
				toBytesLE: () => number[];
				toBytesBE: () => number[];
				toSigned: () => Long.Long;
				toString: (radix?: number) => string;
				toUnsigned: () => Long.Long;
				xor: (other: string | number | Long.Long) => Long.Long;
			} & Record<Exclude<keyof I["txResponse"]["gasUsed"], keyof Long.Long>, never>);
			tx?: {
				typeUrl?: string;
				value?: Uint8Array;
			} & {
				typeUrl?: string;
				value?: Uint8Array;
			} & Record<Exclude<keyof I["txResponse"]["tx"], keyof Any>, never>;
			timestamp?: string;
		} & Record<Exclude<keyof I["txResponse"], keyof TxResponse>, never>;
	} & Record<Exclude<keyof I, "txResponse">, never>>(object: I): BroadcastTxResponse;
};
declare const SimulateRequest: {
	encode(message: SimulateRequest, writer?: _m0.Writer): _m0.Writer;
	decode(input: _m0.Reader | Uint8Array, length?: number): SimulateRequest;
	fromJSON(object: any): SimulateRequest;
	toJSON(message: SimulateRequest): unknown;
	fromPartial<I extends {
		tx?: {
			body?: {
				messages?: {
					typeUrl?: string;
					value?: Uint8Array;
				}[];
				memo?: string;
				timeoutHeight?: string | number | Long.Long;
				extensionOptions?: {
					typeUrl?: string;
					value?: Uint8Array;
				}[];
				nonCriticalExtensionOptions?: {
					typeUrl?: string;
					value?: Uint8Array;
				}[];
			};
			authInfo?: {
				signerInfos?: {
					publicKey?: {
						typeUrl?: string;
						value?: Uint8Array;
					};
					modeInfo?: {
						single?: {
							mode?: SignMode;
						};
						multi?: {
							bitarray?: {
								extraBitsStored?: number;
								elems?: Uint8Array;
							};
							modeInfos?: any[];
						};
					};
					sequence?: string | number | Long.Long;
				}[];
				fee?: {
					amount?: {
						denom?: string;
						amount?: string;
					}[];
					gasLimit?: string | number | Long.Long;
					payer?: string;
					granter?: string;
				};
			};
			signatures?: Uint8Array[];
		};
		txBytes?: Uint8Array;
	} & {
		tx?: {
			body?: {
				messages?: {
					typeUrl?: string;
					value?: Uint8Array;
				}[];
				memo?: string;
				timeoutHeight?: string | number | Long.Long;
				extensionOptions?: {
					typeUrl?: string;
					value?: Uint8Array;
				}[];
				nonCriticalExtensionOptions?: {
					typeUrl?: string;
					value?: Uint8Array;
				}[];
			};
			authInfo?: {
				signerInfos?: {
					publicKey?: {
						typeUrl?: string;
						value?: Uint8Array;
					};
					modeInfo?: {
						single?: {
							mode?: SignMode;
						};
						multi?: {
							bitarray?: {
								extraBitsStored?: number;
								elems?: Uint8Array;
							};
							modeInfos?: any[];
						};
					};
					sequence?: string | number | Long.Long;
				}[];
				fee?: {
					amount?: {
						denom?: string;
						amount?: string;
					}[];
					gasLimit?: string | number | Long.Long;
					payer?: string;
					granter?: string;
				};
			};
			signatures?: Uint8Array[];
		} & {
			body?: {
				messages?: {
					typeUrl?: string;
					value?: Uint8Array;
				}[];
				memo?: string;
				timeoutHeight?: string | number | Long.Long;
				extensionOptions?: {
					typeUrl?: string;
					value?: Uint8Array;
				}[];
				nonCriticalExtensionOptions?: {
					typeUrl?: string;
					value?: Uint8Array;
				}[];
			} & {
				messages?: {
					typeUrl?: string;
					value?: Uint8Array;
				}[] & ({
					typeUrl?: string;
					value?: Uint8Array;
				} & {
					typeUrl?: string;
					value?: Uint8Array;
				} & Record<Exclude<keyof I["tx"]["body"]["messages"][number], keyof Any>, never>)[] & Record<Exclude<keyof I["tx"]["body"]["messages"], keyof {
					typeUrl?: string;
					value?: Uint8Array;
				}[]>, never>;
				memo?: string;
				timeoutHeight?: string | number | (Long.Long & {
					high: number;
					low: number;
					unsigned: boolean;
					add: (addend: string | number | Long.Long) => Long.Long;
					and: (other: string | number | Long.Long) => Long.Long;
					compare: (other: string | number | Long.Long) => number;
					comp: (other: string | number | Long.Long) => number;
					divide: (divisor: string | number | Long.Long) => Long.Long;
					div: (divisor: string | number | Long.Long) => Long.Long;
					equals: (other: string | number | Long.Long) => boolean;
					eq: (other: string | number | Long.Long) => boolean;
					getHighBits: () => number;
					getHighBitsUnsigned: () => number;
					getLowBits: () => number;
					getLowBitsUnsigned: () => number;
					getNumBitsAbs: () => number;
					greaterThan: (other: string | number | Long.Long) => boolean;
					gt: (other: string | number | Long.Long) => boolean;
					greaterThanOrEqual: (other: string | number | Long.Long) => boolean;
					gte: (other: string | number | Long.Long) => boolean;
					isEven: () => boolean;
					isNegative: () => boolean;
					isOdd: () => boolean;
					isPositive: () => boolean;
					isZero: () => boolean;
					lessThan: (other: string | number | Long.Long) => boolean;
					lt: (other: string | number | Long.Long) => boolean;
					lessThanOrEqual: (other: string | number | Long.Long) => boolean;
					lte: (other: string | number | Long.Long) => boolean;
					modulo: (other: string | number | Long.Long) => Long.Long;
					mod: (other: string | number | Long.Long) => Long.Long;
					multiply: (multiplier: string | number | Long.Long) => Long.Long;
					mul: (multiplier: string | number | Long.Long) => Long.Long;
					negate: () => Long.Long;
					neg: () => Long.Long;
					not: () => Long.Long;
					notEquals: (other: string | number | Long.Long) => boolean;
					neq: (other: string | number | Long.Long) => boolean;
					or: (other: string | number | Long.Long) => Long.Long;
					shiftLeft: (numBits: number | Long.Long) => Long.Long;
					shl: (numBits: number | Long.Long) => Long.Long;
					shiftRight: (numBits: number | Long.Long) => Long.Long;
					shr: (numBits: number | Long.Long) => Long.Long;
					shiftRightUnsigned: (numBits: number | Long.Long) => Long.Long;
					shru: (numBits: number | Long.Long) => Long.Long;
					subtract: (subtrahend: string | number | Long.Long) => Long.Long;
					sub: (subtrahend: string | number | Long.Long) => Long.Long;
					toInt: () => number;
					toNumber: () => number;
					toBytes: (le?: boolean) => number[];
					toBytesLE: () => number[];
					toBytesBE: () => number[];
					toSigned: () => Long.Long;
					toString: (radix?: number) => string;
					toUnsigned: () => Long.Long;
					xor: (other: string | number | Long.Long) => Long.Long;
				} & Record<Exclude<keyof I["tx"]["body"]["timeoutHeight"], keyof Long.Long>, never>);
				extensionOptions?: {
					typeUrl?: string;
					value?: Uint8Array;
				}[] & ({
					typeUrl?: string;
					value?: Uint8Array;
				} & {
					typeUrl?: string;
					value?: Uint8Array;
				} & Record<Exclude<keyof I["tx"]["body"]["extensionOptions"][number], keyof Any>, never>)[] & Record<Exclude<keyof I["tx"]["body"]["extensionOptions"], keyof {
					typeUrl?: string;
					value?: Uint8Array;
				}[]>, never>;
				nonCriticalExtensionOptions?: {
					typeUrl?: string;
					value?: Uint8Array;
				}[] & ({
					typeUrl?: string;
					value?: Uint8Array;
				} & {
					typeUrl?: string;
					value?: Uint8Array;
				} & Record<Exclude<keyof I["tx"]["body"]["nonCriticalExtensionOptions"][number], keyof Any>, never>)[] & Record<Exclude<keyof I["tx"]["body"]["nonCriticalExtensionOptions"], keyof {
					typeUrl?: string;
					value?: Uint8Array;
				}[]>, never>;
			} & Record<Exclude<keyof I["tx"]["body"], keyof TxBody>, never>;
			authInfo?: {
				signerInfos?: {
					publicKey?: {
						typeUrl?: string;
						value?: Uint8Array;
					};
					modeInfo?: {
						single?: {
							mode?: SignMode;
						};
						multi?: {
							bitarray?: {
								extraBitsStored?: number;
								elems?: Uint8Array;
							};
							modeInfos?: any[];
						};
					};
					sequence?: string | number | Long.Long;
				}[];
				fee?: {
					amount?: {
						denom?: string;
						amount?: string;
					}[];
					gasLimit?: string | number | Long.Long;
					payer?: string;
					granter?: string;
				};
			} & {
				signerInfos?: {
					publicKey?: {
						typeUrl?: string;
						value?: Uint8Array;
					};
					modeInfo?: {
						single?: {
							mode?: SignMode;
						};
						multi?: {
							bitarray?: {
								extraBitsStored?: number;
								elems?: Uint8Array;
							};
							modeInfos?: any[];
						};
					};
					sequence?: string | number | Long.Long;
				}[] & ({
					publicKey?: {
						typeUrl?: string;
						value?: Uint8Array;
					};
					modeInfo?: {
						single?: {
							mode?: SignMode;
						};
						multi?: {
							bitarray?: {
								extraBitsStored?: number;
								elems?: Uint8Array;
							};
							modeInfos?: any[];
						};
					};
					sequence?: string | number | Long.Long;
				} & {
					publicKey?: {
						typeUrl?: string;
						value?: Uint8Array;
					} & {
						typeUrl?: string;
						value?: Uint8Array;
					} & Record<Exclude<keyof I["tx"]["authInfo"]["signerInfos"][number]["publicKey"], keyof Any>, never>;
					modeInfo?: {
						single?: {
							mode?: SignMode;
						};
						multi?: {
							bitarray?: {
								extraBitsStored?: number;
								elems?: Uint8Array;
							};
							modeInfos?: any[];
						};
					} & {
						single?: {
							mode?: SignMode;
						} & {
							mode?: SignMode;
						} & Record<Exclude<keyof I["tx"]["authInfo"]["signerInfos"][number]["modeInfo"]["single"], "mode">, never>;
						multi?: {
							bitarray?: {
								extraBitsStored?: number;
								elems?: Uint8Array;
							};
							modeInfos?: any[];
						} & {
							bitarray?: {
								extraBitsStored?: number;
								elems?: Uint8Array;
							} & {
								extraBitsStored?: number;
								elems?: Uint8Array;
							} & Record<Exclude<keyof I["tx"]["authInfo"]["signerInfos"][number]["modeInfo"]["multi"]["bitarray"], keyof CompactBitArray>, never>;
							modeInfos?: any[] & ({
								single?: {
									mode?: SignMode;
								};
								multi?: {
									bitarray?: {
										extraBitsStored?: number;
										elems?: Uint8Array;
									};
									modeInfos?: any[];
								};
							} & {
								single?: {
									mode?: SignMode;
								} & {
									mode?: SignMode;
								} & Record<Exclude<keyof I["tx"]["authInfo"]["signerInfos"][number]["modeInfo"]["multi"]["modeInfos"][number]["single"], "mode">, never>;
								multi?: {
									bitarray?: {
										extraBitsStored?: number;
										elems?: Uint8Array;
									};
									modeInfos?: any[];
								} & {
									bitarray?: {
										extraBitsStored?: number;
										elems?: Uint8Array;
									} & {
										extraBitsStored?: number;
										elems?: Uint8Array;
									} & Record<Exclude<keyof I["tx"]["authInfo"]["signerInfos"][number]["modeInfo"]["multi"]["modeInfos"][number]["multi"]["bitarray"], keyof CompactBitArray>, never>;
									modeInfos?: any[] & ({
										single?: {
											mode?: SignMode;
										};
										multi?: {
											bitarray?: {
												extraBitsStored?: number;
												elems?: Uint8Array;
											};
											modeInfos?: any[];
										};
									} & {
										single?: {
											mode?: SignMode;
										} & {
											mode?: SignMode;
										} & Record<Exclude<keyof I["tx"]["authInfo"]["signerInfos"][number]["modeInfo"]["multi"]["modeInfos"][number]["multi"]["modeInfos"][number]["single"], "mode">, never>;
										multi?: {
											bitarray?: {
												extraBitsStored?: number;
												elems?: Uint8Array;
											};
											modeInfos?: any[];
										} & {
											bitarray?: {
												extraBitsStored?: number;
												elems?: Uint8Array;
											} & {
												extraBitsStored?: number;
												elems?: Uint8Array;
											} & Record<Exclude<keyof I["tx"]["authInfo"]["signerInfos"][number]["modeInfo"]["multi"]["modeInfos"][number]["multi"]["modeInfos"][number]["multi"]["bitarray"], keyof CompactBitArray>, never>;
											modeInfos?: any[] & ({
												single?: {
													mode?: SignMode;
												};
												multi?: {
													bitarray?: {
														extraBitsStored?: number;
														elems?: Uint8Array;
													};
													modeInfos?: any[];
												};
											} & {
												single?: {
													mode?: SignMode;
												} & any & Record<Exclude<keyof I["tx"]["authInfo"]["signerInfos"][number]["modeInfo"]["multi"]["modeInfos"][number]["multi"]["modeInfos"][number]["multi"]["modeInfos"][number]["single"], "mode">, never>;
												multi?: {
													bitarray?: {
														extraBitsStored?: number;
														elems?: Uint8Array;
													};
													modeInfos?: any[];
												} & any & Record<Exclude<keyof I["tx"]["authInfo"]["signerInfos"][number]["modeInfo"]["multi"]["modeInfos"][number]["multi"]["modeInfos"][number]["multi"]["modeInfos"][number]["multi"], keyof ModeInfo_Multi>, never>;
											} & Record<Exclude<keyof I["tx"]["authInfo"]["signerInfos"][number]["modeInfo"]["multi"]["modeInfos"][number]["multi"]["modeInfos"][number]["multi"]["modeInfos"][number], keyof ModeInfo>, never>)[] & Record<Exclude<keyof I["tx"]["authInfo"]["signerInfos"][number]["modeInfo"]["multi"]["modeInfos"][number]["multi"]["modeInfos"][number]["multi"]["modeInfos"], keyof any[]>, never>;
										} & Record<Exclude<keyof I["tx"]["authInfo"]["signerInfos"][number]["modeInfo"]["multi"]["modeInfos"][number]["multi"]["modeInfos"][number]["multi"], keyof ModeInfo_Multi>, never>;
									} & Record<Exclude<keyof I["tx"]["authInfo"]["signerInfos"][number]["modeInfo"]["multi"]["modeInfos"][number]["multi"]["modeInfos"][number], keyof ModeInfo>, never>)[] & Record<Exclude<keyof I["tx"]["authInfo"]["signerInfos"][number]["modeInfo"]["multi"]["modeInfos"][number]["multi"]["modeInfos"], keyof any[]>, never>;
								} & Record<Exclude<keyof I["tx"]["authInfo"]["signerInfos"][number]["modeInfo"]["multi"]["modeInfos"][number]["multi"], keyof ModeInfo_Multi>, never>;
							} & Record<Exclude<keyof I["tx"]["authInfo"]["signerInfos"][number]["modeInfo"]["multi"]["modeInfos"][number], keyof ModeInfo>, never>)[] & Record<Exclude<keyof I["tx"]["authInfo"]["signerInfos"][number]["modeInfo"]["multi"]["modeInfos"], keyof any[]>, never>;
						} & Record<Exclude<keyof I["tx"]["authInfo"]["signerInfos"][number]["modeInfo"]["multi"], keyof ModeInfo_Multi>, never>;
					} & Record<Exclude<keyof I["tx"]["authInfo"]["signerInfos"][number]["modeInfo"], keyof ModeInfo>, never>;
					sequence?: string | number | (Long.Long & {
						high: number;
						low: number;
						unsigned: boolean;
						add: (addend: string | number | Long.Long) => Long.Long;
						and: (other: string | number | Long.Long) => Long.Long;
						compare: (other: string | number | Long.Long) => number;
						comp: (other: string | number | Long.Long) => number;
						divide: (divisor: string | number | Long.Long) => Long.Long;
						div: (divisor: string | number | Long.Long) => Long.Long;
						equals: (other: string | number | Long.Long) => boolean;
						eq: (other: string | number | Long.Long) => boolean;
						getHighBits: () => number;
						getHighBitsUnsigned: () => number;
						getLowBits: () => number;
						getLowBitsUnsigned: () => number;
						getNumBitsAbs: () => number;
						greaterThan: (other: string | number | Long.Long) => boolean;
						gt: (other: string | number | Long.Long) => boolean;
						greaterThanOrEqual: (other: string | number | Long.Long) => boolean;
						gte: (other: string | number | Long.Long) => boolean;
						isEven: () => boolean;
						isNegative: () => boolean;
						isOdd: () => boolean;
						isPositive: () => boolean;
						isZero: () => boolean;
						lessThan: (other: string | number | Long.Long) => boolean;
						lt: (other: string | number | Long.Long) => boolean;
						lessThanOrEqual: (other: string | number | Long.Long) => boolean;
						lte: (other: string | number | Long.Long) => boolean;
						modulo: (other: string | number | Long.Long) => Long.Long;
						mod: (other: string | number | Long.Long) => Long.Long;
						multiply: (multiplier: string | number | Long.Long) => Long.Long;
						mul: (multiplier: string | number | Long.Long) => Long.Long;
						negate: () => Long.Long;
						neg: () => Long.Long;
						not: () => Long.Long;
						notEquals: (other: string | number | Long.Long) => boolean;
						neq: (other: string | number | Long.Long) => boolean;
						or: (other: string | number | Long.Long) => Long.Long;
						shiftLeft: (numBits: number | Long.Long) => Long.Long;
						shl: (numBits: number | Long.Long) => Long.Long;
						shiftRight: (numBits: number | Long.Long) => Long.Long;
						shr: (numBits: number | Long.Long) => Long.Long;
						shiftRightUnsigned: (numBits: number | Long.Long) => Long.Long;
						shru: (numBits: number | Long.Long) => Long.Long;
						subtract: (subtrahend: string | number | Long.Long) => Long.Long;
						sub: (subtrahend: string | number | Long.Long) => Long.Long;
						toInt: () => number;
						toNumber: () => number;
						toBytes: (le?: boolean) => number[];
						toBytesLE: () => number[];
						toBytesBE: () => number[];
						toSigned: () => Long.Long;
						toString: (radix?: number) => string;
						toUnsigned: () => Long.Long;
						xor: (other: string | number | Long.Long) => Long.Long;
					} & Record<Exclude<keyof I["tx"]["authInfo"]["signerInfos"][number]["sequence"], keyof Long.Long>, never>);
				} & Record<Exclude<keyof I["tx"]["authInfo"]["signerInfos"][number], keyof SignerInfo>, never>)[] & Record<Exclude<keyof I["tx"]["authInfo"]["signerInfos"], keyof {
					publicKey?: {
						typeUrl?: string;
						value?: Uint8Array;
					};
					modeInfo?: {
						single?: {
							mode?: SignMode;
						};
						multi?: {
							bitarray?: {
								extraBitsStored?: number;
								elems?: Uint8Array;
							};
							modeInfos?: any[];
						};
					};
					sequence?: string | number | Long.Long;
				}[]>, never>;
				fee?: {
					amount?: {
						denom?: string;
						amount?: string;
					}[];
					gasLimit?: string | number | Long.Long;
					payer?: string;
					granter?: string;
				} & {
					amount?: {
						denom?: string;
						amount?: string;
					}[] & ({
						denom?: string;
						amount?: string;
					} & {
						denom?: string;
						amount?: string;
					} & Record<Exclude<keyof I["tx"]["authInfo"]["fee"]["amount"][number], keyof Coin>, never>)[] & Record<Exclude<keyof I["tx"]["authInfo"]["fee"]["amount"], keyof {
						denom?: string;
						amount?: string;
					}[]>, never>;
					gasLimit?: string | number | (Long.Long & {
						high: number;
						low: number;
						unsigned: boolean;
						add: (addend: string | number | Long.Long) => Long.Long;
						and: (other: string | number | Long.Long) => Long.Long;
						compare: (other: string | number | Long.Long) => number;
						comp: (other: string | number | Long.Long) => number;
						divide: (divisor: string | number | Long.Long) => Long.Long;
						div: (divisor: string | number | Long.Long) => Long.Long;
						equals: (other: string | number | Long.Long) => boolean;
						eq: (other: string | number | Long.Long) => boolean;
						getHighBits: () => number;
						getHighBitsUnsigned: () => number;
						getLowBits: () => number;
						getLowBitsUnsigned: () => number;
						getNumBitsAbs: () => number;
						greaterThan: (other: string | number | Long.Long) => boolean;
						gt: (other: string | number | Long.Long) => boolean;
						greaterThanOrEqual: (other: string | number | Long.Long) => boolean;
						gte: (other: string | number | Long.Long) => boolean;
						isEven: () => boolean;
						isNegative: () => boolean;
						isOdd: () => boolean;
						isPositive: () => boolean;
						isZero: () => boolean;
						lessThan: (other: string | number | Long.Long) => boolean;
						lt: (other: string | number | Long.Long) => boolean;
						lessThanOrEqual: (other: string | number | Long.Long) => boolean;
						lte: (other: string | number | Long.Long) => boolean;
						modulo: (other: string | number | Long.Long) => Long.Long;
						mod: (other: string | number | Long.Long) => Long.Long;
						multiply: (multiplier: string | number | Long.Long) => Long.Long;
						mul: (multiplier: string | number | Long.Long) => Long.Long;
						negate: () => Long.Long;
						neg: () => Long.Long;
						not: () => Long.Long;
						notEquals: (other: string | number | Long.Long) => boolean;
						neq: (other: string | number | Long.Long) => boolean;
						or: (other: string | number | Long.Long) => Long.Long;
						shiftLeft: (numBits: number | Long.Long) => Long.Long;
						shl: (numBits: number | Long.Long) => Long.Long;
						shiftRight: (numBits: number | Long.Long) => Long.Long;
						shr: (numBits: number | Long.Long) => Long.Long;
						shiftRightUnsigned: (numBits: number | Long.Long) => Long.Long;
						shru: (numBits: number | Long.Long) => Long.Long;
						subtract: (subtrahend: string | number | Long.Long) => Long.Long;
						sub: (subtrahend: string | number | Long.Long) => Long.Long;
						toInt: () => number;
						toNumber: () => number;
						toBytes: (le?: boolean) => number[];
						toBytesLE: () => number[];
						toBytesBE: () => number[];
						toSigned: () => Long.Long;
						toString: (radix?: number) => string;
						toUnsigned: () => Long.Long;
						xor: (other: string | number | Long.Long) => Long.Long;
					} & Record<Exclude<keyof I["tx"]["authInfo"]["fee"]["gasLimit"], keyof Long.Long>, never>);
					payer?: string;
					granter?: string;
				} & Record<Exclude<keyof I["tx"]["authInfo"]["fee"], keyof Fee>, never>;
			} & Record<Exclude<keyof I["tx"]["authInfo"], keyof AuthInfo>, never>;
			signatures?: Uint8Array[] & Uint8Array[] & Record<Exclude<keyof I["tx"]["signatures"], keyof Uint8Array[]>, never>;
		} & Record<Exclude<keyof I["tx"], keyof Tx>, never>;
		txBytes?: Uint8Array;
	} & Record<Exclude<keyof I, keyof SimulateRequest>, never>>(object: I): SimulateRequest;
};
declare const SimulateResponse: {
	encode(message: SimulateResponse, writer?: _m0.Writer): _m0.Writer;
	decode(input: _m0.Reader | Uint8Array, length?: number): SimulateResponse;
	fromJSON(object: any): SimulateResponse;
	toJSON(message: SimulateResponse): unknown;
	fromPartial<I extends {
		gasInfo?: {
			gasWanted?: string | number | Long.Long;
			gasUsed?: string | number | Long.Long;
		};
		result?: {
			data?: Uint8Array;
			log?: string;
			events?: {
				type?: string;
				attributes?: {
					key?: Uint8Array;
					value?: Uint8Array;
					index?: boolean;
				}[];
			}[];
		};
	} & {
		gasInfo?: {
			gasWanted?: string | number | Long.Long;
			gasUsed?: string | number | Long.Long;
		} & {
			gasWanted?: string | number | (Long.Long & {
				high: number;
				low: number;
				unsigned: boolean;
				add: (addend: string | number | Long.Long) => Long.Long;
				and: (other: string | number | Long.Long) => Long.Long;
				compare: (other: string | number | Long.Long) => number;
				comp: (other: string | number | Long.Long) => number;
				divide: (divisor: string | number | Long.Long) => Long.Long;
				div: (divisor: string | number | Long.Long) => Long.Long;
				equals: (other: string | number | Long.Long) => boolean;
				eq: (other: string | number | Long.Long) => boolean;
				getHighBits: () => number;
				getHighBitsUnsigned: () => number;
				getLowBits: () => number;
				getLowBitsUnsigned: () => number;
				getNumBitsAbs: () => number;
				greaterThan: (other: string | number | Long.Long) => boolean;
				gt: (other: string | number | Long.Long) => boolean;
				greaterThanOrEqual: (other: string | number | Long.Long) => boolean;
				gte: (other: string | number | Long.Long) => boolean;
				isEven: () => boolean;
				isNegative: () => boolean;
				isOdd: () => boolean;
				isPositive: () => boolean;
				isZero: () => boolean;
				lessThan: (other: string | number | Long.Long) => boolean;
				lt: (other: string | number | Long.Long) => boolean;
				lessThanOrEqual: (other: string | number | Long.Long) => boolean;
				lte: (other: string | number | Long.Long) => boolean;
				modulo: (other: string | number | Long.Long) => Long.Long;
				mod: (other: string | number | Long.Long) => Long.Long;
				multiply: (multiplier: string | number | Long.Long) => Long.Long;
				mul: (multiplier: string | number | Long.Long) => Long.Long;
				negate: () => Long.Long;
				neg: () => Long.Long;
				not: () => Long.Long;
				notEquals: (other: string | number | Long.Long) => boolean;
				neq: (other: string | number | Long.Long) => boolean;
				or: (other: string | number | Long.Long) => Long.Long;
				shiftLeft: (numBits: number | Long.Long) => Long.Long;
				shl: (numBits: number | Long.Long) => Long.Long;
				shiftRight: (numBits: number | Long.Long) => Long.Long;
				shr: (numBits: number | Long.Long) => Long.Long;
				shiftRightUnsigned: (numBits: number | Long.Long) => Long.Long;
				shru: (numBits: number | Long.Long) => Long.Long;
				subtract: (subtrahend: string | number | Long.Long) => Long.Long;
				sub: (subtrahend: string | number | Long.Long) => Long.Long;
				toInt: () => number;
				toNumber: () => number;
				toBytes: (le?: boolean) => number[];
				toBytesLE: () => number[];
				toBytesBE: () => number[];
				toSigned: () => Long.Long;
				toString: (radix?: number) => string;
				toUnsigned: () => Long.Long;
				xor: (other: string | number | Long.Long) => Long.Long;
			} & Record<Exclude<keyof I["gasInfo"]["gasWanted"], keyof Long.Long>, never>);
			gasUsed?: string | number | (Long.Long & {
				high: number;
				low: number;
				unsigned: boolean;
				add: (addend: string | number | Long.Long) => Long.Long;
				and: (other: string | number | Long.Long) => Long.Long;
				compare: (other: string | number | Long.Long) => number;
				comp: (other: string | number | Long.Long) => number;
				divide: (divisor: string | number | Long.Long) => Long.Long;
				div: (divisor: string | number | Long.Long) => Long.Long;
				equals: (other: string | number | Long.Long) => boolean;
				eq: (other: string | number | Long.Long) => boolean;
				getHighBits: () => number;
				getHighBitsUnsigned: () => number;
				getLowBits: () => number;
				getLowBitsUnsigned: () => number;
				getNumBitsAbs: () => number;
				greaterThan: (other: string | number | Long.Long) => boolean;
				gt: (other: string | number | Long.Long) => boolean;
				greaterThanOrEqual: (other: string | number | Long.Long) => boolean;
				gte: (other: string | number | Long.Long) => boolean;
				isEven: () => boolean;
				isNegative: () => boolean;
				isOdd: () => boolean;
				isPositive: () => boolean;
				isZero: () => boolean;
				lessThan: (other: string | number | Long.Long) => boolean;
				lt: (other: string | number | Long.Long) => boolean;
				lessThanOrEqual: (other: string | number | Long.Long) => boolean;
				lte: (other: string | number | Long.Long) => boolean;
				modulo: (other: string | number | Long.Long) => Long.Long;
				mod: (other: string | number | Long.Long) => Long.Long;
				multiply: (multiplier: string | number | Long.Long) => Long.Long;
				mul: (multiplier: string | number | Long.Long) => Long.Long;
				negate: () => Long.Long;
				neg: () => Long.Long;
				not: () => Long.Long;
				notEquals: (other: string | number | Long.Long) => boolean;
				neq: (other: string | number | Long.Long) => boolean;
				or: (other: string | number | Long.Long) => Long.Long;
				shiftLeft: (numBits: number | Long.Long) => Long.Long;
				shl: (numBits: number | Long.Long) => Long.Long;
				shiftRight: (numBits: number | Long.Long) => Long.Long;
				shr: (numBits: number | Long.Long) => Long.Long;
				shiftRightUnsigned: (numBits: number | Long.Long) => Long.Long;
				shru: (numBits: number | Long.Long) => Long.Long;
				subtract: (subtrahend: string | number | Long.Long) => Long.Long;
				sub: (subtrahend: string | number | Long.Long) => Long.Long;
				toInt: () => number;
				toNumber: () => number;
				toBytes: (le?: boolean) => number[];
				toBytesLE: () => number[];
				toBytesBE: () => number[];
				toSigned: () => Long.Long;
				toString: (radix?: number) => string;
				toUnsigned: () => Long.Long;
				xor: (other: string | number | Long.Long) => Long.Long;
			} & Record<Exclude<keyof I["gasInfo"]["gasUsed"], keyof Long.Long>, never>);
		} & Record<Exclude<keyof I["gasInfo"], keyof GasInfo>, never>;
		result?: {
			data?: Uint8Array;
			log?: string;
			events?: {
				type?: string;
				attributes?: {
					key?: Uint8Array;
					value?: Uint8Array;
					index?: boolean;
				}[];
			}[];
		} & {
			data?: Uint8Array;
			log?: string;
			events?: {
				type?: string;
				attributes?: {
					key?: Uint8Array;
					value?: Uint8Array;
					index?: boolean;
				}[];
			}[] & ({
				type?: string;
				attributes?: {
					key?: Uint8Array;
					value?: Uint8Array;
					index?: boolean;
				}[];
			} & {
				type?: string;
				attributes?: {
					key?: Uint8Array;
					value?: Uint8Array;
					index?: boolean;
				}[] & ({
					key?: Uint8Array;
					value?: Uint8Array;
					index?: boolean;
				} & {
					key?: Uint8Array;
					value?: Uint8Array;
					index?: boolean;
				} & Record<Exclude<keyof I["result"]["events"][number]["attributes"][number], keyof EventAttribute>, never>)[] & Record<Exclude<keyof I["result"]["events"][number]["attributes"], keyof {
					key?: Uint8Array;
					value?: Uint8Array;
					index?: boolean;
				}[]>, never>;
			} & Record<Exclude<keyof I["result"]["events"][number], keyof Event>, never>)[] & Record<Exclude<keyof I["result"]["events"], keyof {
				type?: string;
				attributes?: {
					key?: Uint8Array;
					value?: Uint8Array;
					index?: boolean;
				}[];
			}[]>, never>;
		} & Record<Exclude<keyof I["result"], keyof Result>, never>;
	} & Record<Exclude<keyof I, keyof SimulateResponse>, never>>(object: I): SimulateResponse;
};
declare const GetTxRequest: {
	encode(message: GetTxRequest, writer?: _m0.Writer): _m0.Writer;
	decode(input: _m0.Reader | Uint8Array, length?: number): GetTxRequest;
	fromJSON(object: any): GetTxRequest;
	toJSON(message: GetTxRequest): unknown;
	fromPartial<I extends {
		hash?: string;
	} & {
		hash?: string;
	} & Record<Exclude<keyof I, "hash">, never>>(object: I): GetTxRequest;
};
declare const GetTxResponse: {
	encode(message: GetTxResponse, writer?: _m0.Writer): _m0.Writer;
	decode(input: _m0.Reader | Uint8Array, length?: number): GetTxResponse;
	fromJSON(object: any): GetTxResponse;
	toJSON(message: GetTxResponse): unknown;
	fromPartial<I extends {
		tx?: {
			body?: {
				messages?: {
					typeUrl?: string;
					value?: Uint8Array;
				}[];
				memo?: string;
				timeoutHeight?: string | number | Long.Long;
				extensionOptions?: {
					typeUrl?: string;
					value?: Uint8Array;
				}[];
				nonCriticalExtensionOptions?: {
					typeUrl?: string;
					value?: Uint8Array;
				}[];
			};
			authInfo?: {
				signerInfos?: {
					publicKey?: {
						typeUrl?: string;
						value?: Uint8Array;
					};
					modeInfo?: {
						single?: {
							mode?: SignMode;
						};
						multi?: {
							bitarray?: {
								extraBitsStored?: number;
								elems?: Uint8Array;
							};
							modeInfos?: any[];
						};
					};
					sequence?: string | number | Long.Long;
				}[];
				fee?: {
					amount?: {
						denom?: string;
						amount?: string;
					}[];
					gasLimit?: string | number | Long.Long;
					payer?: string;
					granter?: string;
				};
			};
			signatures?: Uint8Array[];
		};
		txResponse?: {
			height?: string | number | Long.Long;
			txhash?: string;
			codespace?: string;
			code?: number;
			data?: string;
			rawLog?: string;
			logs?: {
				msgIndex?: number;
				log?: string;
				events?: {
					type?: string;
					attributes?: {
						key?: string;
						value?: string;
					}[];
				}[];
			}[];
			info?: string;
			gasWanted?: string | number | Long.Long;
			gasUsed?: string | number | Long.Long;
			tx?: {
				typeUrl?: string;
				value?: Uint8Array;
			};
			timestamp?: string;
		};
	} & {
		tx?: {
			body?: {
				messages?: {
					typeUrl?: string;
					value?: Uint8Array;
				}[];
				memo?: string;
				timeoutHeight?: string | number | Long.Long;
				extensionOptions?: {
					typeUrl?: string;
					value?: Uint8Array;
				}[];
				nonCriticalExtensionOptions?: {
					typeUrl?: string;
					value?: Uint8Array;
				}[];
			};
			authInfo?: {
				signerInfos?: {
					publicKey?: {
						typeUrl?: string;
						value?: Uint8Array;
					};
					modeInfo?: {
						single?: {
							mode?: SignMode;
						};
						multi?: {
							bitarray?: {
								extraBitsStored?: number;
								elems?: Uint8Array;
							};
							modeInfos?: any[];
						};
					};
					sequence?: string | number | Long.Long;
				}[];
				fee?: {
					amount?: {
						denom?: string;
						amount?: string;
					}[];
					gasLimit?: string | number | Long.Long;
					payer?: string;
					granter?: string;
				};
			};
			signatures?: Uint8Array[];
		} & {
			body?: {
				messages?: {
					typeUrl?: string;
					value?: Uint8Array;
				}[];
				memo?: string;
				timeoutHeight?: string | number | Long.Long;
				extensionOptions?: {
					typeUrl?: string;
					value?: Uint8Array;
				}[];
				nonCriticalExtensionOptions?: {
					typeUrl?: string;
					value?: Uint8Array;
				}[];
			} & {
				messages?: {
					typeUrl?: string;
					value?: Uint8Array;
				}[] & ({
					typeUrl?: string;
					value?: Uint8Array;
				} & {
					typeUrl?: string;
					value?: Uint8Array;
				} & Record<Exclude<keyof I["tx"]["body"]["messages"][number], keyof Any>, never>)[] & Record<Exclude<keyof I["tx"]["body"]["messages"], keyof {
					typeUrl?: string;
					value?: Uint8Array;
				}[]>, never>;
				memo?: string;
				timeoutHeight?: string | number | (Long.Long & {
					high: number;
					low: number;
					unsigned: boolean;
					add: (addend: string | number | Long.Long) => Long.Long;
					and: (other: string | number | Long.Long) => Long.Long;
					compare: (other: string | number | Long.Long) => number;
					comp: (other: string | number | Long.Long) => number;
					divide: (divisor: string | number | Long.Long) => Long.Long;
					div: (divisor: string | number | Long.Long) => Long.Long;
					equals: (other: string | number | Long.Long) => boolean;
					eq: (other: string | number | Long.Long) => boolean;
					getHighBits: () => number;
					getHighBitsUnsigned: () => number;
					getLowBits: () => number;
					getLowBitsUnsigned: () => number;
					getNumBitsAbs: () => number;
					greaterThan: (other: string | number | Long.Long) => boolean;
					gt: (other: string | number | Long.Long) => boolean;
					greaterThanOrEqual: (other: string | number | Long.Long) => boolean;
					gte: (other: string | number | Long.Long) => boolean;
					isEven: () => boolean;
					isNegative: () => boolean;
					isOdd: () => boolean;
					isPositive: () => boolean;
					isZero: () => boolean;
					lessThan: (other: string | number | Long.Long) => boolean;
					lt: (other: string | number | Long.Long) => boolean;
					lessThanOrEqual: (other: string | number | Long.Long) => boolean;
					lte: (other: string | number | Long.Long) => boolean;
					modulo: (other: string | number | Long.Long) => Long.Long;
					mod: (other: string | number | Long.Long) => Long.Long;
					multiply: (multiplier: string | number | Long.Long) => Long.Long;
					mul: (multiplier: string | number | Long.Long) => Long.Long;
					negate: () => Long.Long;
					neg: () => Long.Long;
					not: () => Long.Long;
					notEquals: (other: string | number | Long.Long) => boolean;
					neq: (other: string | number | Long.Long) => boolean;
					or: (other: string | number | Long.Long) => Long.Long;
					shiftLeft: (numBits: number | Long.Long) => Long.Long;
					shl: (numBits: number | Long.Long) => Long.Long;
					shiftRight: (numBits: number | Long.Long) => Long.Long;
					shr: (numBits: number | Long.Long) => Long.Long;
					shiftRightUnsigned: (numBits: number | Long.Long) => Long.Long;
					shru: (numBits: number | Long.Long) => Long.Long;
					subtract: (subtrahend: string | number | Long.Long) => Long.Long;
					sub: (subtrahend: string | number | Long.Long) => Long.Long;
					toInt: () => number;
					toNumber: () => number;
					toBytes: (le?: boolean) => number[];
					toBytesLE: () => number[];
					toBytesBE: () => number[];
					toSigned: () => Long.Long;
					toString: (radix?: number) => string;
					toUnsigned: () => Long.Long;
					xor: (other: string | number | Long.Long) => Long.Long;
				} & Record<Exclude<keyof I["tx"]["body"]["timeoutHeight"], keyof Long.Long>, never>);
				extensionOptions?: {
					typeUrl?: string;
					value?: Uint8Array;
				}[] & ({
					typeUrl?: string;
					value?: Uint8Array;
				} & {
					typeUrl?: string;
					value?: Uint8Array;
				} & Record<Exclude<keyof I["tx"]["body"]["extensionOptions"][number], keyof Any>, never>)[] & Record<Exclude<keyof I["tx"]["body"]["extensionOptions"], keyof {
					typeUrl?: string;
					value?: Uint8Array;
				}[]>, never>;
				nonCriticalExtensionOptions?: {
					typeUrl?: string;
					value?: Uint8Array;
				}[] & ({
					typeUrl?: string;
					value?: Uint8Array;
				} & {
					typeUrl?: string;
					value?: Uint8Array;
				} & Record<Exclude<keyof I["tx"]["body"]["nonCriticalExtensionOptions"][number], keyof Any>, never>)[] & Record<Exclude<keyof I["tx"]["body"]["nonCriticalExtensionOptions"], keyof {
					typeUrl?: string;
					value?: Uint8Array;
				}[]>, never>;
			} & Record<Exclude<keyof I["tx"]["body"], keyof TxBody>, never>;
			authInfo?: {
				signerInfos?: {
					publicKey?: {
						typeUrl?: string;
						value?: Uint8Array;
					};
					modeInfo?: {
						single?: {
							mode?: SignMode;
						};
						multi?: {
							bitarray?: {
								extraBitsStored?: number;
								elems?: Uint8Array;
							};
							modeInfos?: any[];
						};
					};
					sequence?: string | number | Long.Long;
				}[];
				fee?: {
					amount?: {
						denom?: string;
						amount?: string;
					}[];
					gasLimit?: string | number | Long.Long;
					payer?: string;
					granter?: string;
				};
			} & {
				signerInfos?: {
					publicKey?: {
						typeUrl?: string;
						value?: Uint8Array;
					};
					modeInfo?: {
						single?: {
							mode?: SignMode;
						};
						multi?: {
							bitarray?: {
								extraBitsStored?: number;
								elems?: Uint8Array;
							};
							modeInfos?: any[];
						};
					};
					sequence?: string | number | Long.Long;
				}[] & ({
					publicKey?: {
						typeUrl?: string;
						value?: Uint8Array;
					};
					modeInfo?: {
						single?: {
							mode?: SignMode;
						};
						multi?: {
							bitarray?: {
								extraBitsStored?: number;
								elems?: Uint8Array;
							};
							modeInfos?: any[];
						};
					};
					sequence?: string | number | Long.Long;
				} & {
					publicKey?: {
						typeUrl?: string;
						value?: Uint8Array;
					} & {
						typeUrl?: string;
						value?: Uint8Array;
					} & Record<Exclude<keyof I["tx"]["authInfo"]["signerInfos"][number]["publicKey"], keyof Any>, never>;
					modeInfo?: {
						single?: {
							mode?: SignMode;
						};
						multi?: {
							bitarray?: {
								extraBitsStored?: number;
								elems?: Uint8Array;
							};
							modeInfos?: any[];
						};
					} & {
						single?: {
							mode?: SignMode;
						} & {
							mode?: SignMode;
						} & Record<Exclude<keyof I["tx"]["authInfo"]["signerInfos"][number]["modeInfo"]["single"], "mode">, never>;
						multi?: {
							bitarray?: {
								extraBitsStored?: number;
								elems?: Uint8Array;
							};
							modeInfos?: any[];
						} & {
							bitarray?: {
								extraBitsStored?: number;
								elems?: Uint8Array;
							} & {
								extraBitsStored?: number;
								elems?: Uint8Array;
							} & Record<Exclude<keyof I["tx"]["authInfo"]["signerInfos"][number]["modeInfo"]["multi"]["bitarray"], keyof CompactBitArray>, never>;
							modeInfos?: any[] & ({
								single?: {
									mode?: SignMode;
								};
								multi?: {
									bitarray?: {
										extraBitsStored?: number;
										elems?: Uint8Array;
									};
									modeInfos?: any[];
								};
							} & {
								single?: {
									mode?: SignMode;
								} & {
									mode?: SignMode;
								} & Record<Exclude<keyof I["tx"]["authInfo"]["signerInfos"][number]["modeInfo"]["multi"]["modeInfos"][number]["single"], "mode">, never>;
								multi?: {
									bitarray?: {
										extraBitsStored?: number;
										elems?: Uint8Array;
									};
									modeInfos?: any[];
								} & {
									bitarray?: {
										extraBitsStored?: number;
										elems?: Uint8Array;
									} & {
										extraBitsStored?: number;
										elems?: Uint8Array;
									} & Record<Exclude<keyof I["tx"]["authInfo"]["signerInfos"][number]["modeInfo"]["multi"]["modeInfos"][number]["multi"]["bitarray"], keyof CompactBitArray>, never>;
									modeInfos?: any[] & ({
										single?: {
											mode?: SignMode;
										};
										multi?: {
											bitarray?: {
												extraBitsStored?: number;
												elems?: Uint8Array;
											};
											modeInfos?: any[];
										};
									} & {
										single?: {
											mode?: SignMode;
										} & {
											mode?: SignMode;
										} & Record<Exclude<keyof I["tx"]["authInfo"]["signerInfos"][number]["modeInfo"]["multi"]["modeInfos"][number]["multi"]["modeInfos"][number]["single"], "mode">, never>;
										multi?: {
											bitarray?: {
												extraBitsStored?: number;
												elems?: Uint8Array;
											};
											modeInfos?: any[];
										} & {
											bitarray?: {
												extraBitsStored?: number;
												elems?: Uint8Array;
											} & {
												extraBitsStored?: number;
												elems?: Uint8Array;
											} & Record<Exclude<keyof I["tx"]["authInfo"]["signerInfos"][number]["modeInfo"]["multi"]["modeInfos"][number]["multi"]["modeInfos"][number]["multi"]["bitarray"], keyof CompactBitArray>, never>;
											modeInfos?: any[] & ({
												single?: {
													mode?: SignMode;
												};
												multi?: {
													bitarray?: {
														extraBitsStored?: number;
														elems?: Uint8Array;
													};
													modeInfos?: any[];
												};
											} & {
												single?: {
													mode?: SignMode;
												} & any & Record<Exclude<keyof I["tx"]["authInfo"]["signerInfos"][number]["modeInfo"]["multi"]["modeInfos"][number]["multi"]["modeInfos"][number]["multi"]["modeInfos"][number]["single"], "mode">, never>;
												multi?: {
													bitarray?: {
														extraBitsStored?: number;
														elems?: Uint8Array;
													};
													modeInfos?: any[];
												} & any & Record<Exclude<keyof I["tx"]["authInfo"]["signerInfos"][number]["modeInfo"]["multi"]["modeInfos"][number]["multi"]["modeInfos"][number]["multi"]["modeInfos"][number]["multi"], keyof ModeInfo_Multi>, never>;
											} & Record<Exclude<keyof I["tx"]["authInfo"]["signerInfos"][number]["modeInfo"]["multi"]["modeInfos"][number]["multi"]["modeInfos"][number]["multi"]["modeInfos"][number], keyof ModeInfo>, never>)[] & Record<Exclude<keyof I["tx"]["authInfo"]["signerInfos"][number]["modeInfo"]["multi"]["modeInfos"][number]["multi"]["modeInfos"][number]["multi"]["modeInfos"], keyof any[]>, never>;
										} & Record<Exclude<keyof I["tx"]["authInfo"]["signerInfos"][number]["modeInfo"]["multi"]["modeInfos"][number]["multi"]["modeInfos"][number]["multi"], keyof ModeInfo_Multi>, never>;
									} & Record<Exclude<keyof I["tx"]["authInfo"]["signerInfos"][number]["modeInfo"]["multi"]["modeInfos"][number]["multi"]["modeInfos"][number], keyof ModeInfo>, never>)[] & Record<Exclude<keyof I["tx"]["authInfo"]["signerInfos"][number]["modeInfo"]["multi"]["modeInfos"][number]["multi"]["modeInfos"], keyof any[]>, never>;
								} & Record<Exclude<keyof I["tx"]["authInfo"]["signerInfos"][number]["modeInfo"]["multi"]["modeInfos"][number]["multi"], keyof ModeInfo_Multi>, never>;
							} & Record<Exclude<keyof I["tx"]["authInfo"]["signerInfos"][number]["modeInfo"]["multi"]["modeInfos"][number], keyof ModeInfo>, never>)[] & Record<Exclude<keyof I["tx"]["authInfo"]["signerInfos"][number]["modeInfo"]["multi"]["modeInfos"], keyof any[]>, never>;
						} & Record<Exclude<keyof I["tx"]["authInfo"]["signerInfos"][number]["modeInfo"]["multi"], keyof ModeInfo_Multi>, never>;
					} & Record<Exclude<keyof I["tx"]["authInfo"]["signerInfos"][number]["modeInfo"], keyof ModeInfo>, never>;
					sequence?: string | number | (Long.Long & {
						high: number;
						low: number;
						unsigned: boolean;
						add: (addend: string | number | Long.Long) => Long.Long;
						and: (other: string | number | Long.Long) => Long.Long;
						compare: (other: string | number | Long.Long) => number;
						comp: (other: string | number | Long.Long) => number;
						divide: (divisor: string | number | Long.Long) => Long.Long;
						div: (divisor: string | number | Long.Long) => Long.Long;
						equals: (other: string | number | Long.Long) => boolean;
						eq: (other: string | number | Long.Long) => boolean;
						getHighBits: () => number;
						getHighBitsUnsigned: () => number;
						getLowBits: () => number;
						getLowBitsUnsigned: () => number;
						getNumBitsAbs: () => number;
						greaterThan: (other: string | number | Long.Long) => boolean;
						gt: (other: string | number | Long.Long) => boolean;
						greaterThanOrEqual: (other: string | number | Long.Long) => boolean;
						gte: (other: string | number | Long.Long) => boolean;
						isEven: () => boolean;
						isNegative: () => boolean;
						isOdd: () => boolean;
						isPositive: () => boolean;
						isZero: () => boolean;
						lessThan: (other: string | number | Long.Long) => boolean;
						lt: (other: string | number | Long.Long) => boolean;
						lessThanOrEqual: (other: string | number | Long.Long) => boolean;
						lte: (other: string | number | Long.Long) => boolean;
						modulo: (other: string | number | Long.Long) => Long.Long;
						mod: (other: string | number | Long.Long) => Long.Long;
						multiply: (multiplier: string | number | Long.Long) => Long.Long;
						mul: (multiplier: string | number | Long.Long) => Long.Long;
						negate: () => Long.Long;
						neg: () => Long.Long;
						not: () => Long.Long;
						notEquals: (other: string | number | Long.Long) => boolean;
						neq: (other: string | number | Long.Long) => boolean;
						or: (other: string | number | Long.Long) => Long.Long;
						shiftLeft: (numBits: number | Long.Long) => Long.Long;
						shl: (numBits: number | Long.Long) => Long.Long;
						shiftRight: (numBits: number | Long.Long) => Long.Long;
						shr: (numBits: number | Long.Long) => Long.Long;
						shiftRightUnsigned: (numBits: number | Long.Long) => Long.Long;
						shru: (numBits: number | Long.Long) => Long.Long;
						subtract: (subtrahend: string | number | Long.Long) => Long.Long;
						sub: (subtrahend: string | number | Long.Long) => Long.Long;
						toInt: () => number;
						toNumber: () => number;
						toBytes: (le?: boolean) => number[];
						toBytesLE: () => number[];
						toBytesBE: () => number[];
						toSigned: () => Long.Long;
						toString: (radix?: number) => string;
						toUnsigned: () => Long.Long;
						xor: (other: string | number | Long.Long) => Long.Long;
					} & Record<Exclude<keyof I["tx"]["authInfo"]["signerInfos"][number]["sequence"], keyof Long.Long>, never>);
				} & Record<Exclude<keyof I["tx"]["authInfo"]["signerInfos"][number], keyof SignerInfo>, never>)[] & Record<Exclude<keyof I["tx"]["authInfo"]["signerInfos"], keyof {
					publicKey?: {
						typeUrl?: string;
						value?: Uint8Array;
					};
					modeInfo?: {
						single?: {
							mode?: SignMode;
						};
						multi?: {
							bitarray?: {
								extraBitsStored?: number;
								elems?: Uint8Array;
							};
							modeInfos?: any[];
						};
					};
					sequence?: string | number | Long.Long;
				}[]>, never>;
				fee?: {
					amount?: {
						denom?: string;
						amount?: string;
					}[];
					gasLimit?: string | number | Long.Long;
					payer?: string;
					granter?: string;
				} & {
					amount?: {
						denom?: string;
						amount?: string;
					}[] & ({
						denom?: string;
						amount?: string;
					} & {
						denom?: string;
						amount?: string;
					} & Record<Exclude<keyof I["tx"]["authInfo"]["fee"]["amount"][number], keyof Coin>, never>)[] & Record<Exclude<keyof I["tx"]["authInfo"]["fee"]["amount"], keyof {
						denom?: string;
						amount?: string;
					}[]>, never>;
					gasLimit?: string | number | (Long.Long & {
						high: number;
						low: number;
						unsigned: boolean;
						add: (addend: string | number | Long.Long) => Long.Long;
						and: (other: string | number | Long.Long) => Long.Long;
						compare: (other: string | number | Long.Long) => number;
						comp: (other: string | number | Long.Long) => number;
						divide: (divisor: string | number | Long.Long) => Long.Long;
						div: (divisor: string | number | Long.Long) => Long.Long;
						equals: (other: string | number | Long.Long) => boolean;
						eq: (other: string | number | Long.Long) => boolean;
						getHighBits: () => number;
						getHighBitsUnsigned: () => number;
						getLowBits: () => number;
						getLowBitsUnsigned: () => number;
						getNumBitsAbs: () => number;
						greaterThan: (other: string | number | Long.Long) => boolean;
						gt: (other: string | number | Long.Long) => boolean;
						greaterThanOrEqual: (other: string | number | Long.Long) => boolean;
						gte: (other: string | number | Long.Long) => boolean;
						isEven: () => boolean;
						isNegative: () => boolean;
						isOdd: () => boolean;
						isPositive: () => boolean;
						isZero: () => boolean;
						lessThan: (other: string | number | Long.Long) => boolean;
						lt: (other: string | number | Long.Long) => boolean;
						lessThanOrEqual: (other: string | number | Long.Long) => boolean;
						lte: (other: string | number | Long.Long) => boolean;
						modulo: (other: string | number | Long.Long) => Long.Long;
						mod: (other: string | number | Long.Long) => Long.Long;
						multiply: (multiplier: string | number | Long.Long) => Long.Long;
						mul: (multiplier: string | number | Long.Long) => Long.Long;
						negate: () => Long.Long;
						neg: () => Long.Long;
						not: () => Long.Long;
						notEquals: (other: string | number | Long.Long) => boolean;
						neq: (other: string | number | Long.Long) => boolean;
						or: (other: string | number | Long.Long) => Long.Long;
						shiftLeft: (numBits: number | Long.Long) => Long.Long;
						shl: (numBits: number | Long.Long) => Long.Long;
						shiftRight: (numBits: number | Long.Long) => Long.Long;
						shr: (numBits: number | Long.Long) => Long.Long;
						shiftRightUnsigned: (numBits: number | Long.Long) => Long.Long;
						shru: (numBits: number | Long.Long) => Long.Long;
						subtract: (subtrahend: string | number | Long.Long) => Long.Long;
						sub: (subtrahend: string | number | Long.Long) => Long.Long;
						toInt: () => number;
						toNumber: () => number;
						toBytes: (le?: boolean) => number[];
						toBytesLE: () => number[];
						toBytesBE: () => number[];
						toSigned: () => Long.Long;
						toString: (radix?: number) => string;
						toUnsigned: () => Long.Long;
						xor: (other: string | number | Long.Long) => Long.Long;
					} & Record<Exclude<keyof I["tx"]["authInfo"]["fee"]["gasLimit"], keyof Long.Long>, never>);
					payer?: string;
					granter?: string;
				} & Record<Exclude<keyof I["tx"]["authInfo"]["fee"], keyof Fee>, never>;
			} & Record<Exclude<keyof I["tx"]["authInfo"], keyof AuthInfo>, never>;
			signatures?: Uint8Array[] & Uint8Array[] & Record<Exclude<keyof I["tx"]["signatures"], keyof Uint8Array[]>, never>;
		} & Record<Exclude<keyof I["tx"], keyof Tx>, never>;
		txResponse?: {
			height?: string | number | Long.Long;
			txhash?: string;
			codespace?: string;
			code?: number;
			data?: string;
			rawLog?: string;
			logs?: {
				msgIndex?: number;
				log?: string;
				events?: {
					type?: string;
					attributes?: {
						key?: string;
						value?: string;
					}[];
				}[];
			}[];
			info?: string;
			gasWanted?: string | number | Long.Long;
			gasUsed?: string | number | Long.Long;
			tx?: {
				typeUrl?: string;
				value?: Uint8Array;
			};
			timestamp?: string;
		} & {
			height?: string | number | (Long.Long & {
				high: number;
				low: number;
				unsigned: boolean;
				add: (addend: string | number | Long.Long) => Long.Long;
				and: (other: string | number | Long.Long) => Long.Long;
				compare: (other: string | number | Long.Long) => number;
				comp: (other: string | number | Long.Long) => number;
				divide: (divisor: string | number | Long.Long) => Long.Long;
				div: (divisor: string | number | Long.Long) => Long.Long;
				equals: (other: string | number | Long.Long) => boolean;
				eq: (other: string | number | Long.Long) => boolean;
				getHighBits: () => number;
				getHighBitsUnsigned: () => number;
				getLowBits: () => number;
				getLowBitsUnsigned: () => number;
				getNumBitsAbs: () => number;
				greaterThan: (other: string | number | Long.Long) => boolean;
				gt: (other: string | number | Long.Long) => boolean;
				greaterThanOrEqual: (other: string | number | Long.Long) => boolean;
				gte: (other: string | number | Long.Long) => boolean;
				isEven: () => boolean;
				isNegative: () => boolean;
				isOdd: () => boolean;
				isPositive: () => boolean;
				isZero: () => boolean;
				lessThan: (other: string | number | Long.Long) => boolean;
				lt: (other: string | number | Long.Long) => boolean;
				lessThanOrEqual: (other: string | number | Long.Long) => boolean;
				lte: (other: string | number | Long.Long) => boolean;
				modulo: (other: string | number | Long.Long) => Long.Long;
				mod: (other: string | number | Long.Long) => Long.Long;
				multiply: (multiplier: string | number | Long.Long) => Long.Long;
				mul: (multiplier: string | number | Long.Long) => Long.Long;
				negate: () => Long.Long;
				neg: () => Long.Long;
				not: () => Long.Long;
				notEquals: (other: string | number | Long.Long) => boolean;
				neq: (other: string | number | Long.Long) => boolean;
				or: (other: string | number | Long.Long) => Long.Long;
				shiftLeft: (numBits: number | Long.Long) => Long.Long;
				shl: (numBits: number | Long.Long) => Long.Long;
				shiftRight: (numBits: number | Long.Long) => Long.Long;
				shr: (numBits: number | Long.Long) => Long.Long;
				shiftRightUnsigned: (numBits: number | Long.Long) => Long.Long;
				shru: (numBits: number | Long.Long) => Long.Long;
				subtract: (subtrahend: string | number | Long.Long) => Long.Long;
				sub: (subtrahend: string | number | Long.Long) => Long.Long;
				toInt: () => number;
				toNumber: () => number;
				toBytes: (le?: boolean) => number[];
				toBytesLE: () => number[];
				toBytesBE: () => number[];
				toSigned: () => Long.Long;
				toString: (radix?: number) => string;
				toUnsigned: () => Long.Long;
				xor: (other: string | number | Long.Long) => Long.Long;
			} & Record<Exclude<keyof I["txResponse"]["height"], keyof Long.Long>, never>);
			txhash?: string;
			codespace?: string;
			code?: number;
			data?: string;
			rawLog?: string;
			logs?: {
				msgIndex?: number;
				log?: string;
				events?: {
					type?: string;
					attributes?: {
						key?: string;
						value?: string;
					}[];
				}[];
			}[] & ({
				msgIndex?: number;
				log?: string;
				events?: {
					type?: string;
					attributes?: {
						key?: string;
						value?: string;
					}[];
				}[];
			} & {
				msgIndex?: number;
				log?: string;
				events?: {
					type?: string;
					attributes?: {
						key?: string;
						value?: string;
					}[];
				}[] & ({
					type?: string;
					attributes?: {
						key?: string;
						value?: string;
					}[];
				} & {
					type?: string;
					attributes?: {
						key?: string;
						value?: string;
					}[] & ({
						key?: string;
						value?: string;
					} & {
						key?: string;
						value?: string;
					} & Record<Exclude<keyof I["txResponse"]["logs"][number]["events"][number]["attributes"][number], keyof Attribute>, never>)[] & Record<Exclude<keyof I["txResponse"]["logs"][number]["events"][number]["attributes"], keyof {
						key?: string;
						value?: string;
					}[]>, never>;
				} & Record<Exclude<keyof I["txResponse"]["logs"][number]["events"][number], keyof StringEvent>, never>)[] & Record<Exclude<keyof I["txResponse"]["logs"][number]["events"], keyof {
					type?: string;
					attributes?: {
						key?: string;
						value?: string;
					}[];
				}[]>, never>;
			} & Record<Exclude<keyof I["txResponse"]["logs"][number], keyof ABCIMessageLog>, never>)[] & Record<Exclude<keyof I["txResponse"]["logs"], keyof {
				msgIndex?: number;
				log?: string;
				events?: {
					type?: string;
					attributes?: {
						key?: string;
						value?: string;
					}[];
				}[];
			}[]>, never>;
			info?: string;
			gasWanted?: string | number | (Long.Long & {
				high: number;
				low: number;
				unsigned: boolean;
				add: (addend: string | number | Long.Long) => Long.Long;
				and: (other: string | number | Long.Long) => Long.Long;
				compare: (other: string | number | Long.Long) => number;
				comp: (other: string | number | Long.Long) => number;
				divide: (divisor: string | number | Long.Long) => Long.Long;
				div: (divisor: string | number | Long.Long) => Long.Long;
				equals: (other: string | number | Long.Long) => boolean;
				eq: (other: string | number | Long.Long) => boolean;
				getHighBits: () => number;
				getHighBitsUnsigned: () => number;
				getLowBits: () => number;
				getLowBitsUnsigned: () => number;
				getNumBitsAbs: () => number;
				greaterThan: (other: string | number | Long.Long) => boolean;
				gt: (other: string | number | Long.Long) => boolean;
				greaterThanOrEqual: (other: string | number | Long.Long) => boolean;
				gte: (other: string | number | Long.Long) => boolean;
				isEven: () => boolean;
				isNegative: () => boolean;
				isOdd: () => boolean;
				isPositive: () => boolean;
				isZero: () => boolean;
				lessThan: (other: string | number | Long.Long) => boolean;
				lt: (other: string | number | Long.Long) => boolean;
				lessThanOrEqual: (other: string | number | Long.Long) => boolean;
				lte: (other: string | number | Long.Long) => boolean;
				modulo: (other: string | number | Long.Long) => Long.Long;
				mod: (other: string | number | Long.Long) => Long.Long;
				multiply: (multiplier: string | number | Long.Long) => Long.Long;
				mul: (multiplier: string | number | Long.Long) => Long.Long;
				negate: () => Long.Long;
				neg: () => Long.Long;
				not: () => Long.Long;
				notEquals: (other: string | number | Long.Long) => boolean;
				neq: (other: string | number | Long.Long) => boolean;
				or: (other: string | number | Long.Long) => Long.Long;
				shiftLeft: (numBits: number | Long.Long) => Long.Long;
				shl: (numBits: number | Long.Long) => Long.Long;
				shiftRight: (numBits: number | Long.Long) => Long.Long;
				shr: (numBits: number | Long.Long) => Long.Long;
				shiftRightUnsigned: (numBits: number | Long.Long) => Long.Long;
				shru: (numBits: number | Long.Long) => Long.Long;
				subtract: (subtrahend: string | number | Long.Long) => Long.Long;
				sub: (subtrahend: string | number | Long.Long) => Long.Long;
				toInt: () => number;
				toNumber: () => number;
				toBytes: (le?: boolean) => number[];
				toBytesLE: () => number[];
				toBytesBE: () => number[];
				toSigned: () => Long.Long;
				toString: (radix?: number) => string;
				toUnsigned: () => Long.Long;
				xor: (other: string | number | Long.Long) => Long.Long;
			} & Record<Exclude<keyof I["txResponse"]["gasWanted"], keyof Long.Long>, never>);
			gasUsed?: string | number | (Long.Long & {
				high: number;
				low: number;
				unsigned: boolean;
				add: (addend: string | number | Long.Long) => Long.Long;
				and: (other: string | number | Long.Long) => Long.Long;
				compare: (other: string | number | Long.Long) => number;
				comp: (other: string | number | Long.Long) => number;
				divide: (divisor: string | number | Long.Long) => Long.Long;
				div: (divisor: string | number | Long.Long) => Long.Long;
				equals: (other: string | number | Long.Long) => boolean;
				eq: (other: string | number | Long.Long) => boolean;
				getHighBits: () => number;
				getHighBitsUnsigned: () => number;
				getLowBits: () => number;
				getLowBitsUnsigned: () => number;
				getNumBitsAbs: () => number;
				greaterThan: (other: string | number | Long.Long) => boolean;
				gt: (other: string | number | Long.Long) => boolean;
				greaterThanOrEqual: (other: string | number | Long.Long) => boolean;
				gte: (other: string | number | Long.Long) => boolean;
				isEven: () => boolean;
				isNegative: () => boolean;
				isOdd: () => boolean;
				isPositive: () => boolean;
				isZero: () => boolean;
				lessThan: (other: string | number | Long.Long) => boolean;
				lt: (other: string | number | Long.Long) => boolean;
				lessThanOrEqual: (other: string | number | Long.Long) => boolean;
				lte: (other: string | number | Long.Long) => boolean;
				modulo: (other: string | number | Long.Long) => Long.Long;
				mod: (other: string | number | Long.Long) => Long.Long;
				multiply: (multiplier: string | number | Long.Long) => Long.Long;
				mul: (multiplier: string | number | Long.Long) => Long.Long;
				negate: () => Long.Long;
				neg: () => Long.Long;
				not: () => Long.Long;
				notEquals: (other: string | number | Long.Long) => boolean;
				neq: (other: string | number | Long.Long) => boolean;
				or: (other: string | number | Long.Long) => Long.Long;
				shiftLeft: (numBits: number | Long.Long) => Long.Long;
				shl: (numBits: number | Long.Long) => Long.Long;
				shiftRight: (numBits: number | Long.Long) => Long.Long;
				shr: (numBits: number | Long.Long) => Long.Long;
				shiftRightUnsigned: (numBits: number | Long.Long) => Long.Long;
				shru: (numBits: number | Long.Long) => Long.Long;
				subtract: (subtrahend: string | number | Long.Long) => Long.Long;
				sub: (subtrahend: string | number | Long.Long) => Long.Long;
				toInt: () => number;
				toNumber: () => number;
				toBytes: (le?: boolean) => number[];
				toBytesLE: () => number[];
				toBytesBE: () => number[];
				toSigned: () => Long.Long;
				toString: (radix?: number) => string;
				toUnsigned: () => Long.Long;
				xor: (other: string | number | Long.Long) => Long.Long;
			} & Record<Exclude<keyof I["txResponse"]["gasUsed"], keyof Long.Long>, never>);
			tx?: {
				typeUrl?: string;
				value?: Uint8Array;
			} & {
				typeUrl?: string;
				value?: Uint8Array;
			} & Record<Exclude<keyof I["txResponse"]["tx"], keyof Any>, never>;
			timestamp?: string;
		} & Record<Exclude<keyof I["txResponse"], keyof TxResponse>, never>;
	} & Record<Exclude<keyof I, keyof GetTxResponse>, never>>(object: I): GetTxResponse;
};
/** Service defines a gRPC service for interacting with transactions. */
export interface Service {
	/** Simulate simulates executing a transaction for estimating gas usage. */
	Simulate(request: SimulateRequest): Promise<SimulateResponse>;
	/** GetTx fetches a tx by hash. */
	GetTx(request: GetTxRequest): Promise<GetTxResponse>;
	/** BroadcastTx broadcast transaction. */
	BroadcastTx(request: BroadcastTxRequest): Promise<BroadcastTxResponse>;
	/** GetTxsEvent fetches txs by event. */
	GetTxsEvent(request: GetTxsEventRequest): Promise<GetTxsEventResponse>;
}
declare class ServiceClientImpl implements Service {
	private readonly rpc;
	constructor(rpc: Rpc);
	Simulate(request: SimulateRequest): Promise<SimulateResponse>;
	GetTx(request: GetTxRequest): Promise<GetTxResponse>;
	BroadcastTx(request: BroadcastTxRequest): Promise<BroadcastTxResponse>;
	GetTxsEvent(request: GetTxsEventRequest): Promise<GetTxsEventResponse>;
}
export interface Rpc {
	request(service: string, method: string, data: Uint8Array): Promise<Uint8Array>;
}
export declare type QueryClientImpl = {
	storage: StorageQueryClientImpl;
	bank: BankQueryClientImpl;
	faucet: FaucetQueryClientImpl;
	tax: TaxQueryClientImpl;
	staking: StakingQueryClientImpl;
	distribution: DistributionQueryClientImpl;
	tx: ServiceClientImpl;
};
export interface BluzelleClient {
	url: string;
	address: string;
	sgClient: SigningStargateClient;
	queryClient: QueryClientImpl;
	tmClient: Tendermint34Client;
}
export declare const newBluzelleClient: (config: {
	wallet: () => Promise<BluzelleWallet>;
	url: string;
}) => Promise<BluzelleClient>;
declare class SigningBluzelleClient extends SigningStargateClient {
	private wallet;
	protected constructor(tmClient: Tendermint34Client | undefined, signer: BluzelleWallet, options: SigningStargateClientOptions);
	getSequenceFromNetwork(address: string): Promise<SequenceResponse>;
	getSequence(address: string): Promise<SequenceResponse>;
	static connectWithSigner(endpoint: string, signer: BluzelleWallet, options?: {}): Promise<SigningBluzelleClient>;
}
export interface BluzelleWallet extends OfflineDirectSigner {
	getSequence: (client: SigningBluzelleClient, signerAddress: string) => Promise<SequenceResponse>;
}
export interface LocalWalletOptions {
	coinType?: number;
	index?: number;
}
export declare const newLocalWallet: (mnemonic: string, options?: LocalWalletOptions) => () => Promise<BluzelleWallet>;
export declare type AccountAddress = string;
export declare class BluzelleLocalWallet extends DirectSecp256k1HdWallet implements BluzelleWallet {
	sequenceTable: Record<AccountAddress, SequenceResponse>;
	getSequenceQueue: Promise<SequenceResponse>;
	static fromMnemonic(mnemonic: string, options?: Partial<DirectSecp256k1HdWalletOptions>): Promise<BluzelleLocalWallet>;
	getSequence(client: SigningBluzelleClient, signerAddress: string): Promise<SequenceResponse>;
}
export interface SignDoc {
	bodyBytes: Uint8Array;
	authInfoBytes: Uint8Array;
	chainId: string;
	accountNumber: Long;
}
export declare type Ports = {
	rpcPort: number;
	restPort: number;
};
export declare const newKeplrWallet: (nodeAddress: string, ports?: Ports) => () => Promise<BluzelleWallet>;
export declare type AccountAddress = string;
export declare class BluzelleKeplrWallet implements BluzelleWallet {
	getAccounts: () => Promise<readonly AccountData[]>;
	signDirect: (signerAddress: string, signDoc: SignDoc) => Promise<DirectSignResponse>;
	constructor(keplrOfflineSigner: OfflineDirectSigner);
	sequenceTable: Record<AccountAddress, SequenceResponse>;
	getSequenceQueue: Promise<SequenceResponse>;
	getSequence(client: SigningBluzelleClient, signerAddress: string): Promise<SequenceResponse>;
}
export declare function createAddress(): Promise<{
	mnemonic: string;
	address: string;
}>;
export declare function mint(client: BluzelleClient, address?: string): Promise<{
	mnemonic: string;
	address: string;
}>;
export declare type BluzelleDelegatorDelegationsResponse = {
	pagination: PageResponse;
	delegations: BluzelleDelegationResponse[];
};
export declare type BluzelleDelegationResponse = {
	delegation: BluzelleDelegation;
	balance: BluzelleCoin;
};
export declare type BluzelleDelegation = {
	validatorAddress: string;
	delegatorAddress: string;
	shares: number;
};
export declare type BluzelleCoin = {
	denom: "ubnt";
	amount: number;
};
export declare type BluzelleValidatorsResponse = {
	pagination: PageResponse;
	validators: BluzelleValidator[];
};
export declare type BluzelleValidator = {
	operatorAddress: string;
	description: {
		moniker: string;
		details: string;
		website: string;
		securityContact: string;
	};
	commission: {
		commissionRates: {
			rate: number;
			maxRate: number;
			maxChangeRate: number;
		};
		updateTime: Date;
	};
	minSelfDelegation: number;
	delegatorShares: number;
	jailed: boolean;
};
export declare type BluzellePageRequest = {
	key: Uint8Array;
	offset: number;
	limit: number;
	countTotal: boolean;
	reverse: boolean;
};
export declare type BluzelleDelegationTotalRewardsResponse = {
	rewards: BluzelleDelegationDelegatorReward[];
	total: BluzelleCoin[];
};
export declare type BluzelleDelegationDelegatorReward = {
	reward: BluzelleCoin[];
	validatorAddress: string;
	totalReward: BluzelleCoin;
};
export declare const getTx: (client: BluzelleClient, hash: string) => Promise<GetTxResponse>;
export declare const hasContent: (client: BluzelleClient, cid: string) => Promise<boolean>;
export declare const getAccountBalance: (client: BluzelleClient, address: string, denom?: string) => Promise<number>;
export declare const getTaxInfo: (client: BluzelleClient) => Promise<QueryGetTaxInfoResponse>;
export declare const getDelegations: (client: BluzelleClient, delegatorAddress: string, options?: BluzellePageRequest) => Promise<BluzelleDelegatorDelegationsResponse>;
export declare const getDelegation: (client: BluzelleClient, delegatorAddress: string, validatorAddress: string) => Promise<BluzelleDelegationResponse>;
export declare const getValidatorsInfo: (client: BluzelleClient, status?: "BOND_STATUS_UNBONDED" | "BOND_STATUS_UNBONDING" | "BOND_STATUS_BONDED", options?: BluzellePageRequest) => Promise<BluzelleValidatorsResponse>;
export declare const getDelegationRewards: (client: BluzelleClient, delegatorAddress: string, validatorAddress: string) => Promise<BluzelleCoin[]>;
export declare const getDelegationTotalRewards: (client: BluzelleClient, delegatorAddress: string) => Promise<BluzelleDelegationTotalRewardsResponse>;
export interface NodeStatusResponse {
	nodeId: string;
	chainId: string;
	moniker: string;
	blockHeight: number;
	caughtUp: boolean;
}
export interface ValidatorResponse {
	address: string;
	votingPower: number;
}
export declare const getStatus: (client: BluzelleClient) => Promise<NodeStatusResponse>;
export declare const getValidators: (client: BluzelleClient) => Promise<ValidatorResponse[]>;
export declare type BluzelleTxResponse = DeliverTxResponse;
export declare const withTransaction: (client: BluzelleClient, fn: () => unknown) => Promise<DeliverTxResponse>;
export interface BroadcastOptions {
	gasPrice: number;
	maxGas: number;
	memo?: string;
}
export declare const pinCid: (client: BluzelleClient, cid: string, options: BroadcastOptions) => undefined;
export declare const send: (client: BluzelleClient, toAddress: string, amount: number, options: BroadcastOptions, denom?: string) => undefined;
export declare const delegate: (client: BluzelleClient, delegatorAddress: string, validatorAddress: string, amount: number, options: BroadcastOptions) => Promise<BluzelleTxResponse>;
export declare const undelegate: (client: BluzelleClient, delegatorAddress: string, validatorAddress: string, amount: number, options: BroadcastOptions) => Promise<BluzelleTxResponse>;
export declare const redelegate: (client: BluzelleClient, delegatorAddress: string, validatorSrcAddress: string, validatorDstAddress: string, amount: number, options: BroadcastOptions) => Promise<BluzelleTxResponse>;
export declare const withdrawDelegatorReward: (client: BluzelleClient, delegatorAddress: string, validatorAddress: string, options: BroadcastOptions) => Promise<BluzelleTxResponse>;
export declare const generateMnemonic: (wordNum?: 24 | 12) => string;

export {};
