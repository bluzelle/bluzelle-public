// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: nft/nft.proto

package types

import (
	fmt "fmt"
	types "github.com/cosmos/cosmos-sdk/types"
	_ "github.com/gogo/protobuf/gogoproto"
	proto "github.com/gogo/protobuf/proto"
	io "io"
	math "math"
	math_bits "math/bits"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.GoGoProtoPackageIsVersion3 // please upgrade the proto package

type MasterEdition struct {
	Supply    uint64 `protobuf:"varint,1,opt,name=supply,proto3" json:"supply,omitempty"`
	MaxSupply uint64 `protobuf:"varint,2,opt,name=max_supply,json=maxSupply,proto3" json:"max_supply,omitempty"`
}

func (m *MasterEdition) Reset()         { *m = MasterEdition{} }
func (m *MasterEdition) String() string { return proto.CompactTextString(m) }
func (*MasterEdition) ProtoMessage()    {}
func (*MasterEdition) Descriptor() ([]byte, []int) {
	return fileDescriptor_fe8ab7e15b7f0646, []int{0}
}
func (m *MasterEdition) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MasterEdition) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MasterEdition.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MasterEdition) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MasterEdition.Merge(m, src)
}
func (m *MasterEdition) XXX_Size() int {
	return m.Size()
}
func (m *MasterEdition) XXX_DiscardUnknown() {
	xxx_messageInfo_MasterEdition.DiscardUnknown(m)
}

var xxx_messageInfo_MasterEdition proto.InternalMessageInfo

func (m *MasterEdition) GetSupply() uint64 {
	if m != nil {
		return m.Supply
	}
	return 0
}

func (m *MasterEdition) GetMaxSupply() uint64 {
	if m != nil {
		return m.MaxSupply
	}
	return 0
}

type Metadata struct {
	Id uint64 `protobuf:"varint,1,opt,name=id,proto3" json:"id,omitempty"`
	// The name of the asset
	Name string `protobuf:"bytes,2,opt,name=name,proto3" json:"name,omitempty"`
	// URI pointing to JSON representing the asset
	Uri string `protobuf:"bytes,3,opt,name=uri,proto3" json:"uri,omitempty"`
	// Royalty basis points that goes to creators in secondary sales (0-10000)
	SellerFeeBasisPoints uint32 `protobuf:"varint,4,opt,name=seller_fee_basis_points,json=sellerFeeBasisPoints,proto3" json:"seller_fee_basis_points,omitempty"`
	// Immutable, once flipped, all sales of this metadata are considered
	// secondary.
	PrimarySaleHappened bool `protobuf:"varint,5,opt,name=primary_sale_happened,json=primarySaleHappened,proto3" json:"primary_sale_happened,omitempty"`
	// Whether or not the data struct is mutable, default is not
	IsMutable bool `protobuf:"varint,6,opt,name=is_mutable,json=isMutable,proto3" json:"is_mutable,omitempty"`
	// Array of creators, optional
	Creators []Creator `protobuf:"bytes,7,rep,name=creators,proto3" json:"creators"`
	// who can update metadata (if is_mutable is true)
	MetadataAuthority string `protobuf:"bytes,8,opt,name=metadata_authority,json=metadataAuthority,proto3" json:"metadata_authority,omitempty"`
	// who can mint the editions
	MintAuthority string         `protobuf:"bytes,9,opt,name=mint_authority,json=mintAuthority,proto3" json:"mint_authority,omitempty"`
	MasterEdition *MasterEdition `protobuf:"bytes,10,opt,name=master_edition,json=masterEdition,proto3" json:"master_edition,omitempty"`
}

func (m *Metadata) Reset()         { *m = Metadata{} }
func (m *Metadata) String() string { return proto.CompactTextString(m) }
func (*Metadata) ProtoMessage()    {}
func (*Metadata) Descriptor() ([]byte, []int) {
	return fileDescriptor_fe8ab7e15b7f0646, []int{1}
}
func (m *Metadata) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Metadata) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Metadata.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Metadata) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Metadata.Merge(m, src)
}
func (m *Metadata) XXX_Size() int {
	return m.Size()
}
func (m *Metadata) XXX_DiscardUnknown() {
	xxx_messageInfo_Metadata.DiscardUnknown(m)
}

var xxx_messageInfo_Metadata proto.InternalMessageInfo

func (m *Metadata) GetId() uint64 {
	if m != nil {
		return m.Id
	}
	return 0
}

func (m *Metadata) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *Metadata) GetUri() string {
	if m != nil {
		return m.Uri
	}
	return ""
}

func (m *Metadata) GetSellerFeeBasisPoints() uint32 {
	if m != nil {
		return m.SellerFeeBasisPoints
	}
	return 0
}

func (m *Metadata) GetPrimarySaleHappened() bool {
	if m != nil {
		return m.PrimarySaleHappened
	}
	return false
}

func (m *Metadata) GetIsMutable() bool {
	if m != nil {
		return m.IsMutable
	}
	return false
}

func (m *Metadata) GetCreators() []Creator {
	if m != nil {
		return m.Creators
	}
	return nil
}

func (m *Metadata) GetMetadataAuthority() string {
	if m != nil {
		return m.MetadataAuthority
	}
	return ""
}

func (m *Metadata) GetMintAuthority() string {
	if m != nil {
		return m.MintAuthority
	}
	return ""
}

func (m *Metadata) GetMasterEdition() *MasterEdition {
	if m != nil {
		return m.MasterEdition
	}
	return nil
}

type Collection struct {
	Id uint64 `protobuf:"varint,1,opt,name=id,proto3" json:"id,omitempty"`
	// The symbol for the asset
	Symbol string `protobuf:"bytes,2,opt,name=symbol,proto3" json:"symbol,omitempty"`
	Name   string `protobuf:"bytes,3,opt,name=name,proto3" json:"name,omitempty"`
	Uri    string `protobuf:"bytes,4,opt,name=uri,proto3" json:"uri,omitempty"`
	// Whether or not the data struct is mutable, default is not
	IsMutable bool `protobuf:"varint,5,opt,name=is_mutable,json=isMutable,proto3" json:"is_mutable,omitempty"`
	// who can update metadata (if is_mutable is true)
	UpdateAuthority string `protobuf:"bytes,6,opt,name=update_authority,json=updateAuthority,proto3" json:"update_authority,omitempty"`
}

func (m *Collection) Reset()         { *m = Collection{} }
func (m *Collection) String() string { return proto.CompactTextString(m) }
func (*Collection) ProtoMessage()    {}
func (*Collection) Descriptor() ([]byte, []int) {
	return fileDescriptor_fe8ab7e15b7f0646, []int{2}
}
func (m *Collection) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Collection) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Collection.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Collection) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Collection.Merge(m, src)
}
func (m *Collection) XXX_Size() int {
	return m.Size()
}
func (m *Collection) XXX_DiscardUnknown() {
	xxx_messageInfo_Collection.DiscardUnknown(m)
}

var xxx_messageInfo_Collection proto.InternalMessageInfo

func (m *Collection) GetId() uint64 {
	if m != nil {
		return m.Id
	}
	return 0
}

func (m *Collection) GetSymbol() string {
	if m != nil {
		return m.Symbol
	}
	return ""
}

func (m *Collection) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *Collection) GetUri() string {
	if m != nil {
		return m.Uri
	}
	return ""
}

func (m *Collection) GetIsMutable() bool {
	if m != nil {
		return m.IsMutable
	}
	return false
}

func (m *Collection) GetUpdateAuthority() string {
	if m != nil {
		return m.UpdateAuthority
	}
	return ""
}

type Creator struct {
	Address  string `protobuf:"bytes,1,opt,name=address,proto3" json:"address,omitempty"`
	Verified bool   `protobuf:"varint,2,opt,name=verified,proto3" json:"verified,omitempty"`
	// In percentages, NOT basis points ;) Watch out!
	Share uint32 `protobuf:"varint,3,opt,name=share,proto3" json:"share,omitempty"`
}

func (m *Creator) Reset()         { *m = Creator{} }
func (m *Creator) String() string { return proto.CompactTextString(m) }
func (*Creator) ProtoMessage()    {}
func (*Creator) Descriptor() ([]byte, []int) {
	return fileDescriptor_fe8ab7e15b7f0646, []int{3}
}
func (m *Creator) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Creator) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Creator.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Creator) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Creator.Merge(m, src)
}
func (m *Creator) XXX_Size() int {
	return m.Size()
}
func (m *Creator) XXX_DiscardUnknown() {
	xxx_messageInfo_Creator.DiscardUnknown(m)
}

var xxx_messageInfo_Creator proto.InternalMessageInfo

func (m *Creator) GetAddress() string {
	if m != nil {
		return m.Address
	}
	return ""
}

func (m *Creator) GetVerified() bool {
	if m != nil {
		return m.Verified
	}
	return false
}

func (m *Creator) GetShare() uint32 {
	if m != nil {
		return m.Share
	}
	return 0
}

type NFT struct {
	CollId     uint64 `protobuf:"varint,1,opt,name=coll_id,json=collId,proto3" json:"coll_id,omitempty"`
	MetadataId uint64 `protobuf:"varint,2,opt,name=metadata_id,json=metadataId,proto3" json:"metadata_id,omitempty"`
	Seq        uint64 `protobuf:"varint,3,opt,name=seq,proto3" json:"seq,omitempty"`
	Owner      string `protobuf:"bytes,4,opt,name=owner,proto3" json:"owner,omitempty"`
}

func (m *NFT) Reset()         { *m = NFT{} }
func (m *NFT) String() string { return proto.CompactTextString(m) }
func (*NFT) ProtoMessage()    {}
func (*NFT) Descriptor() ([]byte, []int) {
	return fileDescriptor_fe8ab7e15b7f0646, []int{4}
}
func (m *NFT) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *NFT) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_NFT.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *NFT) XXX_Merge(src proto.Message) {
	xxx_messageInfo_NFT.Merge(m, src)
}
func (m *NFT) XXX_Size() int {
	return m.Size()
}
func (m *NFT) XXX_DiscardUnknown() {
	xxx_messageInfo_NFT.DiscardUnknown(m)
}

var xxx_messageInfo_NFT proto.InternalMessageInfo

func (m *NFT) GetCollId() uint64 {
	if m != nil {
		return m.CollId
	}
	return 0
}

func (m *NFT) GetMetadataId() uint64 {
	if m != nil {
		return m.MetadataId
	}
	return 0
}

func (m *NFT) GetSeq() uint64 {
	if m != nil {
		return m.Seq
	}
	return 0
}

func (m *NFT) GetOwner() string {
	if m != nil {
		return m.Owner
	}
	return ""
}

// Params defines nft module's parameters
type Params struct {
	IssuePrice types.Coin `protobuf:"bytes,1,opt,name=issue_price,json=issuePrice,proto3" json:"issue_price" yaml:"issue_price"`
}

func (m *Params) Reset()      { *m = Params{} }
func (*Params) ProtoMessage() {}
func (*Params) Descriptor() ([]byte, []int) {
	return fileDescriptor_fe8ab7e15b7f0646, []int{5}
}
func (m *Params) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Params) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Params.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Params) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Params.Merge(m, src)
}
func (m *Params) XXX_Size() int {
	return m.Size()
}
func (m *Params) XXX_DiscardUnknown() {
	xxx_messageInfo_Params.DiscardUnknown(m)
}

var xxx_messageInfo_Params proto.InternalMessageInfo

func (m *Params) GetIssuePrice() types.Coin {
	if m != nil {
		return m.IssuePrice
	}
	return types.Coin{}
}

type EventMetadataCreation struct {
	Creator    string `protobuf:"bytes,1,opt,name=creator,proto3" json:"creator,omitempty"`
	MetadataId uint64 `protobuf:"varint,2,opt,name=metadata_id,json=metadataId,proto3" json:"metadata_id,omitempty"`
}

func (m *EventMetadataCreation) Reset()         { *m = EventMetadataCreation{} }
func (m *EventMetadataCreation) String() string { return proto.CompactTextString(m) }
func (*EventMetadataCreation) ProtoMessage()    {}
func (*EventMetadataCreation) Descriptor() ([]byte, []int) {
	return fileDescriptor_fe8ab7e15b7f0646, []int{6}
}
func (m *EventMetadataCreation) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *EventMetadataCreation) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_EventMetadataCreation.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *EventMetadataCreation) XXX_Merge(src proto.Message) {
	xxx_messageInfo_EventMetadataCreation.Merge(m, src)
}
func (m *EventMetadataCreation) XXX_Size() int {
	return m.Size()
}
func (m *EventMetadataCreation) XXX_DiscardUnknown() {
	xxx_messageInfo_EventMetadataCreation.DiscardUnknown(m)
}

var xxx_messageInfo_EventMetadataCreation proto.InternalMessageInfo

func (m *EventMetadataCreation) GetCreator() string {
	if m != nil {
		return m.Creator
	}
	return ""
}

func (m *EventMetadataCreation) GetMetadataId() uint64 {
	if m != nil {
		return m.MetadataId
	}
	return 0
}

type EventNFTCreation struct {
	Creator string `protobuf:"bytes,1,opt,name=creator,proto3" json:"creator,omitempty"`
	NftId   string `protobuf:"bytes,2,opt,name=nft_id,json=nftId,proto3" json:"nft_id,omitempty"`
}

func (m *EventNFTCreation) Reset()         { *m = EventNFTCreation{} }
func (m *EventNFTCreation) String() string { return proto.CompactTextString(m) }
func (*EventNFTCreation) ProtoMessage()    {}
func (*EventNFTCreation) Descriptor() ([]byte, []int) {
	return fileDescriptor_fe8ab7e15b7f0646, []int{7}
}
func (m *EventNFTCreation) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *EventNFTCreation) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_EventNFTCreation.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *EventNFTCreation) XXX_Merge(src proto.Message) {
	xxx_messageInfo_EventNFTCreation.Merge(m, src)
}
func (m *EventNFTCreation) XXX_Size() int {
	return m.Size()
}
func (m *EventNFTCreation) XXX_DiscardUnknown() {
	xxx_messageInfo_EventNFTCreation.DiscardUnknown(m)
}

var xxx_messageInfo_EventNFTCreation proto.InternalMessageInfo

func (m *EventNFTCreation) GetCreator() string {
	if m != nil {
		return m.Creator
	}
	return ""
}

func (m *EventNFTCreation) GetNftId() string {
	if m != nil {
		return m.NftId
	}
	return ""
}

type EventPrintEdition struct {
	MetadataId string `protobuf:"bytes,1,opt,name=metadata_id,json=metadataId,proto3" json:"metadata_id,omitempty"`
	Edition    uint64 `protobuf:"varint,2,opt,name=edition,proto3" json:"edition,omitempty"`
}

func (m *EventPrintEdition) Reset()         { *m = EventPrintEdition{} }
func (m *EventPrintEdition) String() string { return proto.CompactTextString(m) }
func (*EventPrintEdition) ProtoMessage()    {}
func (*EventPrintEdition) Descriptor() ([]byte, []int) {
	return fileDescriptor_fe8ab7e15b7f0646, []int{8}
}
func (m *EventPrintEdition) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *EventPrintEdition) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_EventPrintEdition.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *EventPrintEdition) XXX_Merge(src proto.Message) {
	xxx_messageInfo_EventPrintEdition.Merge(m, src)
}
func (m *EventPrintEdition) XXX_Size() int {
	return m.Size()
}
func (m *EventPrintEdition) XXX_DiscardUnknown() {
	xxx_messageInfo_EventPrintEdition.DiscardUnknown(m)
}

var xxx_messageInfo_EventPrintEdition proto.InternalMessageInfo

func (m *EventPrintEdition) GetMetadataId() string {
	if m != nil {
		return m.MetadataId
	}
	return ""
}

func (m *EventPrintEdition) GetEdition() uint64 {
	if m != nil {
		return m.Edition
	}
	return 0
}

type EventNFTTransfer struct {
	NftId    string `protobuf:"bytes,1,opt,name=nft_id,json=nftId,proto3" json:"nft_id,omitempty"`
	Sender   string `protobuf:"bytes,2,opt,name=sender,proto3" json:"sender,omitempty"`
	Receiver string `protobuf:"bytes,3,opt,name=receiver,proto3" json:"receiver,omitempty"`
}

func (m *EventNFTTransfer) Reset()         { *m = EventNFTTransfer{} }
func (m *EventNFTTransfer) String() string { return proto.CompactTextString(m) }
func (*EventNFTTransfer) ProtoMessage()    {}
func (*EventNFTTransfer) Descriptor() ([]byte, []int) {
	return fileDescriptor_fe8ab7e15b7f0646, []int{9}
}
func (m *EventNFTTransfer) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *EventNFTTransfer) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_EventNFTTransfer.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *EventNFTTransfer) XXX_Merge(src proto.Message) {
	xxx_messageInfo_EventNFTTransfer.Merge(m, src)
}
func (m *EventNFTTransfer) XXX_Size() int {
	return m.Size()
}
func (m *EventNFTTransfer) XXX_DiscardUnknown() {
	xxx_messageInfo_EventNFTTransfer.DiscardUnknown(m)
}

var xxx_messageInfo_EventNFTTransfer proto.InternalMessageInfo

func (m *EventNFTTransfer) GetNftId() string {
	if m != nil {
		return m.NftId
	}
	return ""
}

func (m *EventNFTTransfer) GetSender() string {
	if m != nil {
		return m.Sender
	}
	return ""
}

func (m *EventNFTTransfer) GetReceiver() string {
	if m != nil {
		return m.Receiver
	}
	return ""
}

type EventMetadataSign struct {
	Signer     string `protobuf:"bytes,1,opt,name=signer,proto3" json:"signer,omitempty"`
	MetadataId uint64 `protobuf:"varint,2,opt,name=metadata_id,json=metadataId,proto3" json:"metadata_id,omitempty"`
}

func (m *EventMetadataSign) Reset()         { *m = EventMetadataSign{} }
func (m *EventMetadataSign) String() string { return proto.CompactTextString(m) }
func (*EventMetadataSign) ProtoMessage()    {}
func (*EventMetadataSign) Descriptor() ([]byte, []int) {
	return fileDescriptor_fe8ab7e15b7f0646, []int{10}
}
func (m *EventMetadataSign) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *EventMetadataSign) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_EventMetadataSign.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *EventMetadataSign) XXX_Merge(src proto.Message) {
	xxx_messageInfo_EventMetadataSign.Merge(m, src)
}
func (m *EventMetadataSign) XXX_Size() int {
	return m.Size()
}
func (m *EventMetadataSign) XXX_DiscardUnknown() {
	xxx_messageInfo_EventMetadataSign.DiscardUnknown(m)
}

var xxx_messageInfo_EventMetadataSign proto.InternalMessageInfo

func (m *EventMetadataSign) GetSigner() string {
	if m != nil {
		return m.Signer
	}
	return ""
}

func (m *EventMetadataSign) GetMetadataId() uint64 {
	if m != nil {
		return m.MetadataId
	}
	return 0
}

type EventMetadataUpdate struct {
	Updater    string `protobuf:"bytes,1,opt,name=updater,proto3" json:"updater,omitempty"`
	MetadataId uint64 `protobuf:"varint,2,opt,name=metadata_id,json=metadataId,proto3" json:"metadata_id,omitempty"`
}

func (m *EventMetadataUpdate) Reset()         { *m = EventMetadataUpdate{} }
func (m *EventMetadataUpdate) String() string { return proto.CompactTextString(m) }
func (*EventMetadataUpdate) ProtoMessage()    {}
func (*EventMetadataUpdate) Descriptor() ([]byte, []int) {
	return fileDescriptor_fe8ab7e15b7f0646, []int{11}
}
func (m *EventMetadataUpdate) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *EventMetadataUpdate) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_EventMetadataUpdate.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *EventMetadataUpdate) XXX_Merge(src proto.Message) {
	xxx_messageInfo_EventMetadataUpdate.Merge(m, src)
}
func (m *EventMetadataUpdate) XXX_Size() int {
	return m.Size()
}
func (m *EventMetadataUpdate) XXX_DiscardUnknown() {
	xxx_messageInfo_EventMetadataUpdate.DiscardUnknown(m)
}

var xxx_messageInfo_EventMetadataUpdate proto.InternalMessageInfo

func (m *EventMetadataUpdate) GetUpdater() string {
	if m != nil {
		return m.Updater
	}
	return ""
}

func (m *EventMetadataUpdate) GetMetadataId() uint64 {
	if m != nil {
		return m.MetadataId
	}
	return 0
}

type EventMetadataAuthorityUpdate struct {
	MetadataId   string `protobuf:"bytes,1,opt,name=metadata_id,json=metadataId,proto3" json:"metadata_id,omitempty"`
	NewAuthority string `protobuf:"bytes,2,opt,name=new_authority,json=newAuthority,proto3" json:"new_authority,omitempty"`
}

func (m *EventMetadataAuthorityUpdate) Reset()         { *m = EventMetadataAuthorityUpdate{} }
func (m *EventMetadataAuthorityUpdate) String() string { return proto.CompactTextString(m) }
func (*EventMetadataAuthorityUpdate) ProtoMessage()    {}
func (*EventMetadataAuthorityUpdate) Descriptor() ([]byte, []int) {
	return fileDescriptor_fe8ab7e15b7f0646, []int{12}
}
func (m *EventMetadataAuthorityUpdate) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *EventMetadataAuthorityUpdate) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_EventMetadataAuthorityUpdate.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *EventMetadataAuthorityUpdate) XXX_Merge(src proto.Message) {
	xxx_messageInfo_EventMetadataAuthorityUpdate.Merge(m, src)
}
func (m *EventMetadataAuthorityUpdate) XXX_Size() int {
	return m.Size()
}
func (m *EventMetadataAuthorityUpdate) XXX_DiscardUnknown() {
	xxx_messageInfo_EventMetadataAuthorityUpdate.DiscardUnknown(m)
}

var xxx_messageInfo_EventMetadataAuthorityUpdate proto.InternalMessageInfo

func (m *EventMetadataAuthorityUpdate) GetMetadataId() string {
	if m != nil {
		return m.MetadataId
	}
	return ""
}

func (m *EventMetadataAuthorityUpdate) GetNewAuthority() string {
	if m != nil {
		return m.NewAuthority
	}
	return ""
}

type EventMintAuthorityUpdate struct {
	MetadataId   string `protobuf:"bytes,1,opt,name=metadata_id,json=metadataId,proto3" json:"metadata_id,omitempty"`
	NewAuthority string `protobuf:"bytes,2,opt,name=new_authority,json=newAuthority,proto3" json:"new_authority,omitempty"`
}

func (m *EventMintAuthorityUpdate) Reset()         { *m = EventMintAuthorityUpdate{} }
func (m *EventMintAuthorityUpdate) String() string { return proto.CompactTextString(m) }
func (*EventMintAuthorityUpdate) ProtoMessage()    {}
func (*EventMintAuthorityUpdate) Descriptor() ([]byte, []int) {
	return fileDescriptor_fe8ab7e15b7f0646, []int{13}
}
func (m *EventMintAuthorityUpdate) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *EventMintAuthorityUpdate) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_EventMintAuthorityUpdate.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *EventMintAuthorityUpdate) XXX_Merge(src proto.Message) {
	xxx_messageInfo_EventMintAuthorityUpdate.Merge(m, src)
}
func (m *EventMintAuthorityUpdate) XXX_Size() int {
	return m.Size()
}
func (m *EventMintAuthorityUpdate) XXX_DiscardUnknown() {
	xxx_messageInfo_EventMintAuthorityUpdate.DiscardUnknown(m)
}

var xxx_messageInfo_EventMintAuthorityUpdate proto.InternalMessageInfo

func (m *EventMintAuthorityUpdate) GetMetadataId() string {
	if m != nil {
		return m.MetadataId
	}
	return ""
}

func (m *EventMintAuthorityUpdate) GetNewAuthority() string {
	if m != nil {
		return m.NewAuthority
	}
	return ""
}

type EventCollectionCreation struct {
	Creator      string `protobuf:"bytes,1,opt,name=creator,proto3" json:"creator,omitempty"`
	CollectionId uint64 `protobuf:"varint,2,opt,name=collection_id,json=collectionId,proto3" json:"collection_id,omitempty"`
}

func (m *EventCollectionCreation) Reset()         { *m = EventCollectionCreation{} }
func (m *EventCollectionCreation) String() string { return proto.CompactTextString(m) }
func (*EventCollectionCreation) ProtoMessage()    {}
func (*EventCollectionCreation) Descriptor() ([]byte, []int) {
	return fileDescriptor_fe8ab7e15b7f0646, []int{14}
}
func (m *EventCollectionCreation) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *EventCollectionCreation) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_EventCollectionCreation.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *EventCollectionCreation) XXX_Merge(src proto.Message) {
	xxx_messageInfo_EventCollectionCreation.Merge(m, src)
}
func (m *EventCollectionCreation) XXX_Size() int {
	return m.Size()
}
func (m *EventCollectionCreation) XXX_DiscardUnknown() {
	xxx_messageInfo_EventCollectionCreation.DiscardUnknown(m)
}

var xxx_messageInfo_EventCollectionCreation proto.InternalMessageInfo

func (m *EventCollectionCreation) GetCreator() string {
	if m != nil {
		return m.Creator
	}
	return ""
}

func (m *EventCollectionCreation) GetCollectionId() uint64 {
	if m != nil {
		return m.CollectionId
	}
	return 0
}

type EventCollectionVerification struct {
	Verifier     string `protobuf:"bytes,1,opt,name=verifier,proto3" json:"verifier,omitempty"`
	CollectionId uint64 `protobuf:"varint,2,opt,name=collection_id,json=collectionId,proto3" json:"collection_id,omitempty"`
	NftId        string `protobuf:"bytes,3,opt,name=nft_id,json=nftId,proto3" json:"nft_id,omitempty"`
}

func (m *EventCollectionVerification) Reset()         { *m = EventCollectionVerification{} }
func (m *EventCollectionVerification) String() string { return proto.CompactTextString(m) }
func (*EventCollectionVerification) ProtoMessage()    {}
func (*EventCollectionVerification) Descriptor() ([]byte, []int) {
	return fileDescriptor_fe8ab7e15b7f0646, []int{15}
}
func (m *EventCollectionVerification) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *EventCollectionVerification) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_EventCollectionVerification.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *EventCollectionVerification) XXX_Merge(src proto.Message) {
	xxx_messageInfo_EventCollectionVerification.Merge(m, src)
}
func (m *EventCollectionVerification) XXX_Size() int {
	return m.Size()
}
func (m *EventCollectionVerification) XXX_DiscardUnknown() {
	xxx_messageInfo_EventCollectionVerification.DiscardUnknown(m)
}

var xxx_messageInfo_EventCollectionVerification proto.InternalMessageInfo

func (m *EventCollectionVerification) GetVerifier() string {
	if m != nil {
		return m.Verifier
	}
	return ""
}

func (m *EventCollectionVerification) GetCollectionId() uint64 {
	if m != nil {
		return m.CollectionId
	}
	return 0
}

func (m *EventCollectionVerification) GetNftId() string {
	if m != nil {
		return m.NftId
	}
	return ""
}

type EventCollectionUnverification struct {
	Verifier     string `protobuf:"bytes,1,opt,name=verifier,proto3" json:"verifier,omitempty"`
	CollectionId uint64 `protobuf:"varint,2,opt,name=collection_id,json=collectionId,proto3" json:"collection_id,omitempty"`
	NftId        string `protobuf:"bytes,3,opt,name=nft_id,json=nftId,proto3" json:"nft_id,omitempty"`
}

func (m *EventCollectionUnverification) Reset()         { *m = EventCollectionUnverification{} }
func (m *EventCollectionUnverification) String() string { return proto.CompactTextString(m) }
func (*EventCollectionUnverification) ProtoMessage()    {}
func (*EventCollectionUnverification) Descriptor() ([]byte, []int) {
	return fileDescriptor_fe8ab7e15b7f0646, []int{16}
}
func (m *EventCollectionUnverification) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *EventCollectionUnverification) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_EventCollectionUnverification.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *EventCollectionUnverification) XXX_Merge(src proto.Message) {
	xxx_messageInfo_EventCollectionUnverification.Merge(m, src)
}
func (m *EventCollectionUnverification) XXX_Size() int {
	return m.Size()
}
func (m *EventCollectionUnverification) XXX_DiscardUnknown() {
	xxx_messageInfo_EventCollectionUnverification.DiscardUnknown(m)
}

var xxx_messageInfo_EventCollectionUnverification proto.InternalMessageInfo

func (m *EventCollectionUnverification) GetVerifier() string {
	if m != nil {
		return m.Verifier
	}
	return ""
}

func (m *EventCollectionUnverification) GetCollectionId() uint64 {
	if m != nil {
		return m.CollectionId
	}
	return 0
}

func (m *EventCollectionUnverification) GetNftId() string {
	if m != nil {
		return m.NftId
	}
	return ""
}

type EventUpdateCollectionAuthority struct {
	CollectionId uint64 `protobuf:"varint,1,opt,name=collection_id,json=collectionId,proto3" json:"collection_id,omitempty"`
	NewAuthority string `protobuf:"bytes,2,opt,name=new_authority,json=newAuthority,proto3" json:"new_authority,omitempty"`
}

func (m *EventUpdateCollectionAuthority) Reset()         { *m = EventUpdateCollectionAuthority{} }
func (m *EventUpdateCollectionAuthority) String() string { return proto.CompactTextString(m) }
func (*EventUpdateCollectionAuthority) ProtoMessage()    {}
func (*EventUpdateCollectionAuthority) Descriptor() ([]byte, []int) {
	return fileDescriptor_fe8ab7e15b7f0646, []int{17}
}
func (m *EventUpdateCollectionAuthority) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *EventUpdateCollectionAuthority) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_EventUpdateCollectionAuthority.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *EventUpdateCollectionAuthority) XXX_Merge(src proto.Message) {
	xxx_messageInfo_EventUpdateCollectionAuthority.Merge(m, src)
}
func (m *EventUpdateCollectionAuthority) XXX_Size() int {
	return m.Size()
}
func (m *EventUpdateCollectionAuthority) XXX_DiscardUnknown() {
	xxx_messageInfo_EventUpdateCollectionAuthority.DiscardUnknown(m)
}

var xxx_messageInfo_EventUpdateCollectionAuthority proto.InternalMessageInfo

func (m *EventUpdateCollectionAuthority) GetCollectionId() uint64 {
	if m != nil {
		return m.CollectionId
	}
	return 0
}

func (m *EventUpdateCollectionAuthority) GetNewAuthority() string {
	if m != nil {
		return m.NewAuthority
	}
	return ""
}

func init() {
	proto.RegisterType((*MasterEdition)(nil), "bluzelle.curium.nft.MasterEdition")
	proto.RegisterType((*Metadata)(nil), "bluzelle.curium.nft.Metadata")
	proto.RegisterType((*Collection)(nil), "bluzelle.curium.nft.Collection")
	proto.RegisterType((*Creator)(nil), "bluzelle.curium.nft.Creator")
	proto.RegisterType((*NFT)(nil), "bluzelle.curium.nft.NFT")
	proto.RegisterType((*Params)(nil), "bluzelle.curium.nft.Params")
	proto.RegisterType((*EventMetadataCreation)(nil), "bluzelle.curium.nft.EventMetadataCreation")
	proto.RegisterType((*EventNFTCreation)(nil), "bluzelle.curium.nft.EventNFTCreation")
	proto.RegisterType((*EventPrintEdition)(nil), "bluzelle.curium.nft.EventPrintEdition")
	proto.RegisterType((*EventNFTTransfer)(nil), "bluzelle.curium.nft.EventNFTTransfer")
	proto.RegisterType((*EventMetadataSign)(nil), "bluzelle.curium.nft.EventMetadataSign")
	proto.RegisterType((*EventMetadataUpdate)(nil), "bluzelle.curium.nft.EventMetadataUpdate")
	proto.RegisterType((*EventMetadataAuthorityUpdate)(nil), "bluzelle.curium.nft.EventMetadataAuthorityUpdate")
	proto.RegisterType((*EventMintAuthorityUpdate)(nil), "bluzelle.curium.nft.EventMintAuthorityUpdate")
	proto.RegisterType((*EventCollectionCreation)(nil), "bluzelle.curium.nft.EventCollectionCreation")
	proto.RegisterType((*EventCollectionVerification)(nil), "bluzelle.curium.nft.EventCollectionVerification")
	proto.RegisterType((*EventCollectionUnverification)(nil), "bluzelle.curium.nft.EventCollectionUnverification")
	proto.RegisterType((*EventUpdateCollectionAuthority)(nil), "bluzelle.curium.nft.EventUpdateCollectionAuthority")
}

func init() { proto.RegisterFile("nft/nft.proto", fileDescriptor_fe8ab7e15b7f0646) }

var fileDescriptor_fe8ab7e15b7f0646 = []byte{
	// 952 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xbc, 0x56, 0xcf, 0x6f, 0xdb, 0x36,
	0x14, 0x8e, 0x6a, 0xc7, 0x3f, 0x5e, 0xea, 0x2c, 0x65, 0x92, 0x45, 0xcb, 0x5a, 0xdb, 0x50, 0xb1,
	0xc1, 0x3b, 0x4c, 0x46, 0x33, 0xec, 0xd2, 0xc3, 0xb0, 0x25, 0x68, 0x30, 0x03, 0x4b, 0x60, 0x28,
	0x49, 0x31, 0x0c, 0x18, 0x34, 0x5a, 0xa2, 0x1d, 0x16, 0x12, 0xa5, 0x91, 0x94, 0x13, 0xef, 0xaf,
	0xd8, 0x71, 0xc7, 0x1e, 0x76, 0xdb, 0x3f, 0xd2, 0x63, 0x8f, 0x3b, 0x15, 0x43, 0x72, 0xd9, 0x79,
	0x7f, 0xc1, 0x20, 0x52, 0xbf, 0xe2, 0x06, 0x48, 0x0e, 0xc3, 0x6e, 0xfc, 0xf8, 0xc8, 0xef, 0xf1,
	0x7d, 0xef, 0x23, 0x25, 0xe8, 0xb0, 0xa9, 0x1c, 0xb2, 0xa9, 0xb4, 0x63, 0x1e, 0xc9, 0x08, 0x6d,
	0x4e, 0x82, 0xe4, 0x17, 0x12, 0x04, 0xc4, 0xf6, 0x12, 0x4e, 0x93, 0xd0, 0x66, 0x53, 0xb9, 0xbb,
	0x35, 0x8b, 0x66, 0x91, 0x8a, 0x0f, 0xd3, 0x91, 0x5e, 0xba, 0xdb, 0xf5, 0x22, 0x11, 0x46, 0x62,
	0x38, 0xc1, 0x82, 0x0c, 0xe7, 0xcf, 0x26, 0x44, 0xe2, 0x67, 0x43, 0x2f, 0xa2, 0x4c, 0xc7, 0xad,
	0x43, 0xe8, 0x1c, 0x61, 0x21, 0x09, 0x7f, 0xe1, 0x53, 0x49, 0x23, 0x86, 0x3e, 0x84, 0x86, 0x48,
	0xe2, 0x38, 0x58, 0x98, 0x46, 0xdf, 0x18, 0xd4, 0x9d, 0x0c, 0xa1, 0x27, 0x00, 0x21, 0xbe, 0x74,
	0xb3, 0xd8, 0x03, 0x15, 0x6b, 0x87, 0xf8, 0xf2, 0x44, 0x4d, 0x58, 0x7f, 0xd4, 0xa0, 0x75, 0x44,
	0x24, 0xf6, 0xb1, 0xc4, 0x68, 0x1d, 0x1e, 0x50, 0x3f, 0xdb, 0xff, 0x80, 0xfa, 0x08, 0x41, 0x9d,
	0xe1, 0x90, 0xa8, 0x5d, 0x6d, 0x47, 0x8d, 0xd1, 0x06, 0xd4, 0x12, 0x4e, 0xcd, 0x9a, 0x9a, 0x4a,
	0x87, 0xe8, 0x4b, 0xd8, 0x11, 0x69, 0x51, 0xdc, 0x9d, 0x12, 0xe2, 0x4e, 0xb0, 0xa0, 0xc2, 0x8d,
	0x23, 0xca, 0xa4, 0x30, 0xeb, 0x7d, 0x63, 0xd0, 0x71, 0xb6, 0x74, 0xf8, 0x90, 0x90, 0xfd, 0x34,
	0x38, 0x56, 0x31, 0xb4, 0x07, 0xdb, 0x31, 0xa7, 0x21, 0xe6, 0x0b, 0x57, 0xe0, 0x80, 0xb8, 0xe7,
	0x38, 0x8e, 0x09, 0x23, 0xbe, 0xb9, 0xda, 0x37, 0x06, 0x2d, 0x67, 0x33, 0x0b, 0x9e, 0xe0, 0x80,
	0x7c, 0x9b, 0x85, 0xd2, 0x62, 0xa8, 0x70, 0xc3, 0x44, 0xe2, 0x49, 0x40, 0xcc, 0x86, 0x5a, 0xd8,
	0xa6, 0xe2, 0x48, 0x4f, 0xa0, 0xaf, 0xa0, 0xe5, 0x71, 0x82, 0x65, 0xc4, 0x85, 0xd9, 0xec, 0xd7,
	0x06, 0x6b, 0x7b, 0x8f, 0xed, 0x5b, 0x24, 0xb7, 0x0f, 0xf4, 0xa2, 0xfd, 0xfa, 0x9b, 0x77, 0xbd,
	0x15, 0xa7, 0xd8, 0x83, 0x3e, 0x07, 0x14, 0x66, 0x5a, 0xb8, 0x38, 0x91, 0xe7, 0x11, 0xa7, 0x72,
	0x61, 0xb6, 0x54, 0xa9, 0x8f, 0xf2, 0xc8, 0x37, 0x79, 0x00, 0x7d, 0x02, 0xeb, 0x21, 0x65, 0xb2,
	0xb2, 0xb4, 0xad, 0x96, 0x76, 0xd2, 0xd9, 0x72, 0xd9, 0x08, 0xd6, 0x43, 0xd5, 0x2a, 0x97, 0xe8,
	0x5e, 0x99, 0xd0, 0x37, 0x06, 0x6b, 0x7b, 0xd6, 0xad, 0x67, 0xbb, 0xd1, 0x55, 0xa7, 0x13, 0x56,
	0xa1, 0xf5, 0xbb, 0x01, 0x70, 0x10, 0x05, 0x01, 0xf1, 0x54, 0xcf, 0x97, 0xfb, 0x95, 0x7a, 0x60,
	0x11, 0x4e, 0xa2, 0x20, 0xeb, 0x58, 0x86, 0x8a, 0x3e, 0xd6, 0xde, 0xef, 0x63, 0xbd, 0xec, 0xe3,
	0x4d, 0x71, 0x57, 0x97, 0xc5, 0xfd, 0x0c, 0x36, 0x92, 0xd8, 0xc7, 0x92, 0x54, 0xea, 0x6d, 0xa8,
	0xdd, 0x1f, 0xe8, 0xf9, 0xa2, 0x62, 0xeb, 0x0c, 0x9a, 0x99, 0xc4, 0xc8, 0x84, 0x26, 0xf6, 0x7d,
	0x4e, 0x84, 0x50, 0xe7, 0x6c, 0x3b, 0x39, 0x44, 0xbb, 0xd0, 0x9a, 0x13, 0x4e, 0xa7, 0x94, 0xf8,
	0xea, 0xb8, 0x2d, 0xa7, 0xc0, 0x68, 0x0b, 0x56, 0xc5, 0x39, 0xe6, 0xfa, 0xc4, 0x1d, 0x47, 0x03,
	0x6b, 0x06, 0xb5, 0xe3, 0xc3, 0x53, 0xb4, 0x03, 0x4d, 0x2f, 0x0a, 0x02, 0xb7, 0x28, 0xbd, 0x91,
	0xc2, 0x91, 0x8f, 0x7a, 0xb0, 0x56, 0xb4, 0x8f, 0xfa, 0x99, 0xd7, 0x21, 0x9f, 0x1a, 0xf9, 0x69,
	0xcd, 0x82, 0xfc, 0xac, 0x48, 0xeb, 0x4e, 0x3a, 0x4c, 0x13, 0x45, 0x17, 0x8c, 0xf0, 0x4c, 0x07,
	0x0d, 0xac, 0x57, 0xd0, 0x18, 0x63, 0x8e, 0x43, 0x81, 0x5e, 0xc2, 0x1a, 0x15, 0x22, 0x21, 0x6e,
	0xcc, 0xa9, 0x47, 0x54, 0xbe, 0xb5, 0xbd, 0x8f, 0x6c, 0x7d, 0x39, 0xed, 0xf4, 0x72, 0xda, 0xd9,
	0xe5, 0xb4, 0x0f, 0x22, 0xca, 0xf6, 0x77, 0x53, 0x47, 0xfd, 0xf3, 0xae, 0x87, 0x16, 0x38, 0x0c,
	0x9e, 0x5b, 0x95, 0xbd, 0x96, 0x03, 0x0a, 0x8d, 0x53, 0xf0, 0xbc, 0xf5, 0xdb, 0xeb, 0xde, 0xca,
	0xdf, 0xaf, 0x7b, 0x86, 0xe5, 0xc0, 0xf6, 0x8b, 0x39, 0x61, 0x32, 0xbf, 0x84, 0x4a, 0xb8, 0xb4,
	0xb9, 0x26, 0x34, 0x33, 0x63, 0xe6, 0xca, 0x65, 0xf0, 0xce, 0x3a, 0xad, 0x03, 0xd8, 0x50, 0x9c,
	0xc7, 0x87, 0xa7, 0xf7, 0xa0, 0xdb, 0x86, 0x06, 0x9b, 0xca, 0x9c, 0xa9, 0xed, 0xac, 0xb2, 0xa9,
	0x1c, 0xf9, 0xd6, 0x31, 0x3c, 0x52, 0x24, 0x63, 0x4e, 0x99, 0xcc, 0x5f, 0x99, 0xa5, 0xd4, 0x9a,
	0xa9, 0x2a, 0xb1, 0x09, 0xcd, 0xdc, 0xe5, 0xfa, 0x5c, 0x39, 0xb4, 0x7e, 0x2c, 0x0f, 0x75, 0xca,
	0x31, 0x13, 0x53, 0x52, 0x4d, 0x6d, 0x54, 0x52, 0x2b, 0x1f, 0x13, 0xe6, 0x13, 0x5e, 0xf8, 0x58,
	0xa1, 0xd4, 0x32, 0x9c, 0x78, 0x84, 0xce, 0x09, 0xcf, 0xbc, 0x5c, 0x60, 0xeb, 0xbb, 0xec, 0xb8,
	0xb9, 0x8e, 0x27, 0x74, 0xa6, 0x1f, 0x45, 0x3a, 0x4b, 0xfb, 0x6b, 0x64, 0x44, 0x0a, 0xdd, 0xad,
	0xe0, 0x18, 0x36, 0x6f, 0xb0, 0x9d, 0x29, 0x87, 0xa7, 0xd5, 0x69, 0xaf, 0x17, 0x22, 0x66, 0xf0,
	0x6e, 0x46, 0x1f, 0x1e, 0xdf, 0x60, 0x2c, 0x6e, 0x4b, 0x46, 0x7d, 0xa7, 0xb2, 0x4f, 0xa1, 0xc3,
	0xc8, 0x45, 0xe5, 0xf2, 0x69, 0x6d, 0x1e, 0x32, 0x72, 0x51, 0xde, 0xbc, 0x9f, 0xc0, 0xd4, 0x59,
	0xaa, 0x2f, 0xd0, 0x7f, 0x9a, 0xe1, 0x7b, 0xd8, 0x51, 0x19, 0xca, 0x67, 0xe8, 0x1e, 0x16, 0x7b,
	0x0a, 0x1d, 0xaf, 0x58, 0x5f, 0xea, 0xf3, 0xb0, 0x9c, 0x1c, 0xf9, 0x56, 0x02, 0x1f, 0x2f, 0x31,
	0xbf, 0x54, 0xef, 0x81, 0xa7, 0xd9, 0xcb, 0xf7, 0x22, 0xa7, 0x2f, 0xf0, 0xbd, 0xf8, 0x2b, 0x66,
	0xab, 0x55, 0x7d, 0x7e, 0x01, 0x4f, 0x96, 0xd2, 0x9e, 0xb1, 0xf9, 0xff, 0x91, 0xf8, 0x15, 0x74,
	0x55, 0x62, 0xdd, 0x9e, 0x32, 0x7d, 0xf9, 0xe5, 0x78, 0x8f, 0xdd, 0xb8, 0x85, 0xfd, 0x3e, 0x5d,
	0xdb, 0xff, 0xfa, 0xcd, 0x55, 0xd7, 0x78, 0x7b, 0xd5, 0x35, 0xfe, 0xba, 0xea, 0x1a, 0xbf, 0x5e,
	0x77, 0x57, 0xde, 0x5e, 0x77, 0x57, 0xfe, 0xbc, 0xee, 0xae, 0xfc, 0xf0, 0xe9, 0x8c, 0xca, 0xf3,
	0x64, 0x62, 0x7b, 0x51, 0x38, 0xcc, 0xbf, 0x47, 0x43, 0xfd, 0x3d, 0x1a, 0x5e, 0xa6, 0xff, 0x2e,
	0x43, 0xb9, 0x88, 0x89, 0x98, 0x34, 0xd4, 0x7f, 0xc7, 0x17, 0xff, 0x06, 0x00, 0x00, 0xff, 0xff,
	0xf4, 0x48, 0xfb, 0x0e, 0xd3, 0x08, 0x00, 0x00,
}

func (this *Params) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*Params)
	if !ok {
		that2, ok := that.(Params)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.IssuePrice.Equal(&that1.IssuePrice) {
		return false
	}
	return true
}
func (m *MasterEdition) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MasterEdition) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MasterEdition) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.MaxSupply != 0 {
		i = encodeVarintNft(dAtA, i, uint64(m.MaxSupply))
		i--
		dAtA[i] = 0x10
	}
	if m.Supply != 0 {
		i = encodeVarintNft(dAtA, i, uint64(m.Supply))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *Metadata) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Metadata) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Metadata) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.MasterEdition != nil {
		{
			size, err := m.MasterEdition.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintNft(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x52
	}
	if len(m.MintAuthority) > 0 {
		i -= len(m.MintAuthority)
		copy(dAtA[i:], m.MintAuthority)
		i = encodeVarintNft(dAtA, i, uint64(len(m.MintAuthority)))
		i--
		dAtA[i] = 0x4a
	}
	if len(m.MetadataAuthority) > 0 {
		i -= len(m.MetadataAuthority)
		copy(dAtA[i:], m.MetadataAuthority)
		i = encodeVarintNft(dAtA, i, uint64(len(m.MetadataAuthority)))
		i--
		dAtA[i] = 0x42
	}
	if len(m.Creators) > 0 {
		for iNdEx := len(m.Creators) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Creators[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintNft(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x3a
		}
	}
	if m.IsMutable {
		i--
		if m.IsMutable {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x30
	}
	if m.PrimarySaleHappened {
		i--
		if m.PrimarySaleHappened {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x28
	}
	if m.SellerFeeBasisPoints != 0 {
		i = encodeVarintNft(dAtA, i, uint64(m.SellerFeeBasisPoints))
		i--
		dAtA[i] = 0x20
	}
	if len(m.Uri) > 0 {
		i -= len(m.Uri)
		copy(dAtA[i:], m.Uri)
		i = encodeVarintNft(dAtA, i, uint64(len(m.Uri)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.Name) > 0 {
		i -= len(m.Name)
		copy(dAtA[i:], m.Name)
		i = encodeVarintNft(dAtA, i, uint64(len(m.Name)))
		i--
		dAtA[i] = 0x12
	}
	if m.Id != 0 {
		i = encodeVarintNft(dAtA, i, uint64(m.Id))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *Collection) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Collection) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Collection) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.UpdateAuthority) > 0 {
		i -= len(m.UpdateAuthority)
		copy(dAtA[i:], m.UpdateAuthority)
		i = encodeVarintNft(dAtA, i, uint64(len(m.UpdateAuthority)))
		i--
		dAtA[i] = 0x32
	}
	if m.IsMutable {
		i--
		if m.IsMutable {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x28
	}
	if len(m.Uri) > 0 {
		i -= len(m.Uri)
		copy(dAtA[i:], m.Uri)
		i = encodeVarintNft(dAtA, i, uint64(len(m.Uri)))
		i--
		dAtA[i] = 0x22
	}
	if len(m.Name) > 0 {
		i -= len(m.Name)
		copy(dAtA[i:], m.Name)
		i = encodeVarintNft(dAtA, i, uint64(len(m.Name)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.Symbol) > 0 {
		i -= len(m.Symbol)
		copy(dAtA[i:], m.Symbol)
		i = encodeVarintNft(dAtA, i, uint64(len(m.Symbol)))
		i--
		dAtA[i] = 0x12
	}
	if m.Id != 0 {
		i = encodeVarintNft(dAtA, i, uint64(m.Id))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *Creator) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Creator) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Creator) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Share != 0 {
		i = encodeVarintNft(dAtA, i, uint64(m.Share))
		i--
		dAtA[i] = 0x18
	}
	if m.Verified {
		i--
		if m.Verified {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x10
	}
	if len(m.Address) > 0 {
		i -= len(m.Address)
		copy(dAtA[i:], m.Address)
		i = encodeVarintNft(dAtA, i, uint64(len(m.Address)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *NFT) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *NFT) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *NFT) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Owner) > 0 {
		i -= len(m.Owner)
		copy(dAtA[i:], m.Owner)
		i = encodeVarintNft(dAtA, i, uint64(len(m.Owner)))
		i--
		dAtA[i] = 0x22
	}
	if m.Seq != 0 {
		i = encodeVarintNft(dAtA, i, uint64(m.Seq))
		i--
		dAtA[i] = 0x18
	}
	if m.MetadataId != 0 {
		i = encodeVarintNft(dAtA, i, uint64(m.MetadataId))
		i--
		dAtA[i] = 0x10
	}
	if m.CollId != 0 {
		i = encodeVarintNft(dAtA, i, uint64(m.CollId))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *Params) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Params) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Params) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	{
		size, err := m.IssuePrice.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintNft(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0xa
	return len(dAtA) - i, nil
}

func (m *EventMetadataCreation) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *EventMetadataCreation) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *EventMetadataCreation) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.MetadataId != 0 {
		i = encodeVarintNft(dAtA, i, uint64(m.MetadataId))
		i--
		dAtA[i] = 0x10
	}
	if len(m.Creator) > 0 {
		i -= len(m.Creator)
		copy(dAtA[i:], m.Creator)
		i = encodeVarintNft(dAtA, i, uint64(len(m.Creator)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *EventNFTCreation) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *EventNFTCreation) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *EventNFTCreation) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.NftId) > 0 {
		i -= len(m.NftId)
		copy(dAtA[i:], m.NftId)
		i = encodeVarintNft(dAtA, i, uint64(len(m.NftId)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Creator) > 0 {
		i -= len(m.Creator)
		copy(dAtA[i:], m.Creator)
		i = encodeVarintNft(dAtA, i, uint64(len(m.Creator)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *EventPrintEdition) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *EventPrintEdition) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *EventPrintEdition) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Edition != 0 {
		i = encodeVarintNft(dAtA, i, uint64(m.Edition))
		i--
		dAtA[i] = 0x10
	}
	if len(m.MetadataId) > 0 {
		i -= len(m.MetadataId)
		copy(dAtA[i:], m.MetadataId)
		i = encodeVarintNft(dAtA, i, uint64(len(m.MetadataId)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *EventNFTTransfer) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *EventNFTTransfer) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *EventNFTTransfer) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Receiver) > 0 {
		i -= len(m.Receiver)
		copy(dAtA[i:], m.Receiver)
		i = encodeVarintNft(dAtA, i, uint64(len(m.Receiver)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.Sender) > 0 {
		i -= len(m.Sender)
		copy(dAtA[i:], m.Sender)
		i = encodeVarintNft(dAtA, i, uint64(len(m.Sender)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.NftId) > 0 {
		i -= len(m.NftId)
		copy(dAtA[i:], m.NftId)
		i = encodeVarintNft(dAtA, i, uint64(len(m.NftId)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *EventMetadataSign) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *EventMetadataSign) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *EventMetadataSign) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.MetadataId != 0 {
		i = encodeVarintNft(dAtA, i, uint64(m.MetadataId))
		i--
		dAtA[i] = 0x10
	}
	if len(m.Signer) > 0 {
		i -= len(m.Signer)
		copy(dAtA[i:], m.Signer)
		i = encodeVarintNft(dAtA, i, uint64(len(m.Signer)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *EventMetadataUpdate) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *EventMetadataUpdate) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *EventMetadataUpdate) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.MetadataId != 0 {
		i = encodeVarintNft(dAtA, i, uint64(m.MetadataId))
		i--
		dAtA[i] = 0x10
	}
	if len(m.Updater) > 0 {
		i -= len(m.Updater)
		copy(dAtA[i:], m.Updater)
		i = encodeVarintNft(dAtA, i, uint64(len(m.Updater)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *EventMetadataAuthorityUpdate) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *EventMetadataAuthorityUpdate) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *EventMetadataAuthorityUpdate) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.NewAuthority) > 0 {
		i -= len(m.NewAuthority)
		copy(dAtA[i:], m.NewAuthority)
		i = encodeVarintNft(dAtA, i, uint64(len(m.NewAuthority)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.MetadataId) > 0 {
		i -= len(m.MetadataId)
		copy(dAtA[i:], m.MetadataId)
		i = encodeVarintNft(dAtA, i, uint64(len(m.MetadataId)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *EventMintAuthorityUpdate) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *EventMintAuthorityUpdate) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *EventMintAuthorityUpdate) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.NewAuthority) > 0 {
		i -= len(m.NewAuthority)
		copy(dAtA[i:], m.NewAuthority)
		i = encodeVarintNft(dAtA, i, uint64(len(m.NewAuthority)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.MetadataId) > 0 {
		i -= len(m.MetadataId)
		copy(dAtA[i:], m.MetadataId)
		i = encodeVarintNft(dAtA, i, uint64(len(m.MetadataId)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *EventCollectionCreation) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *EventCollectionCreation) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *EventCollectionCreation) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.CollectionId != 0 {
		i = encodeVarintNft(dAtA, i, uint64(m.CollectionId))
		i--
		dAtA[i] = 0x10
	}
	if len(m.Creator) > 0 {
		i -= len(m.Creator)
		copy(dAtA[i:], m.Creator)
		i = encodeVarintNft(dAtA, i, uint64(len(m.Creator)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *EventCollectionVerification) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *EventCollectionVerification) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *EventCollectionVerification) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.NftId) > 0 {
		i -= len(m.NftId)
		copy(dAtA[i:], m.NftId)
		i = encodeVarintNft(dAtA, i, uint64(len(m.NftId)))
		i--
		dAtA[i] = 0x1a
	}
	if m.CollectionId != 0 {
		i = encodeVarintNft(dAtA, i, uint64(m.CollectionId))
		i--
		dAtA[i] = 0x10
	}
	if len(m.Verifier) > 0 {
		i -= len(m.Verifier)
		copy(dAtA[i:], m.Verifier)
		i = encodeVarintNft(dAtA, i, uint64(len(m.Verifier)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *EventCollectionUnverification) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *EventCollectionUnverification) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *EventCollectionUnverification) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.NftId) > 0 {
		i -= len(m.NftId)
		copy(dAtA[i:], m.NftId)
		i = encodeVarintNft(dAtA, i, uint64(len(m.NftId)))
		i--
		dAtA[i] = 0x1a
	}
	if m.CollectionId != 0 {
		i = encodeVarintNft(dAtA, i, uint64(m.CollectionId))
		i--
		dAtA[i] = 0x10
	}
	if len(m.Verifier) > 0 {
		i -= len(m.Verifier)
		copy(dAtA[i:], m.Verifier)
		i = encodeVarintNft(dAtA, i, uint64(len(m.Verifier)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *EventUpdateCollectionAuthority) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *EventUpdateCollectionAuthority) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *EventUpdateCollectionAuthority) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.NewAuthority) > 0 {
		i -= len(m.NewAuthority)
		copy(dAtA[i:], m.NewAuthority)
		i = encodeVarintNft(dAtA, i, uint64(len(m.NewAuthority)))
		i--
		dAtA[i] = 0x12
	}
	if m.CollectionId != 0 {
		i = encodeVarintNft(dAtA, i, uint64(m.CollectionId))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func encodeVarintNft(dAtA []byte, offset int, v uint64) int {
	offset -= sovNft(v)
	base := offset
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return base
}
func (m *MasterEdition) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Supply != 0 {
		n += 1 + sovNft(uint64(m.Supply))
	}
	if m.MaxSupply != 0 {
		n += 1 + sovNft(uint64(m.MaxSupply))
	}
	return n
}

func (m *Metadata) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Id != 0 {
		n += 1 + sovNft(uint64(m.Id))
	}
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovNft(uint64(l))
	}
	l = len(m.Uri)
	if l > 0 {
		n += 1 + l + sovNft(uint64(l))
	}
	if m.SellerFeeBasisPoints != 0 {
		n += 1 + sovNft(uint64(m.SellerFeeBasisPoints))
	}
	if m.PrimarySaleHappened {
		n += 2
	}
	if m.IsMutable {
		n += 2
	}
	if len(m.Creators) > 0 {
		for _, e := range m.Creators {
			l = e.Size()
			n += 1 + l + sovNft(uint64(l))
		}
	}
	l = len(m.MetadataAuthority)
	if l > 0 {
		n += 1 + l + sovNft(uint64(l))
	}
	l = len(m.MintAuthority)
	if l > 0 {
		n += 1 + l + sovNft(uint64(l))
	}
	if m.MasterEdition != nil {
		l = m.MasterEdition.Size()
		n += 1 + l + sovNft(uint64(l))
	}
	return n
}

func (m *Collection) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Id != 0 {
		n += 1 + sovNft(uint64(m.Id))
	}
	l = len(m.Symbol)
	if l > 0 {
		n += 1 + l + sovNft(uint64(l))
	}
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovNft(uint64(l))
	}
	l = len(m.Uri)
	if l > 0 {
		n += 1 + l + sovNft(uint64(l))
	}
	if m.IsMutable {
		n += 2
	}
	l = len(m.UpdateAuthority)
	if l > 0 {
		n += 1 + l + sovNft(uint64(l))
	}
	return n
}

func (m *Creator) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Address)
	if l > 0 {
		n += 1 + l + sovNft(uint64(l))
	}
	if m.Verified {
		n += 2
	}
	if m.Share != 0 {
		n += 1 + sovNft(uint64(m.Share))
	}
	return n
}

func (m *NFT) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.CollId != 0 {
		n += 1 + sovNft(uint64(m.CollId))
	}
	if m.MetadataId != 0 {
		n += 1 + sovNft(uint64(m.MetadataId))
	}
	if m.Seq != 0 {
		n += 1 + sovNft(uint64(m.Seq))
	}
	l = len(m.Owner)
	if l > 0 {
		n += 1 + l + sovNft(uint64(l))
	}
	return n
}

func (m *Params) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = m.IssuePrice.Size()
	n += 1 + l + sovNft(uint64(l))
	return n
}

func (m *EventMetadataCreation) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Creator)
	if l > 0 {
		n += 1 + l + sovNft(uint64(l))
	}
	if m.MetadataId != 0 {
		n += 1 + sovNft(uint64(m.MetadataId))
	}
	return n
}

func (m *EventNFTCreation) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Creator)
	if l > 0 {
		n += 1 + l + sovNft(uint64(l))
	}
	l = len(m.NftId)
	if l > 0 {
		n += 1 + l + sovNft(uint64(l))
	}
	return n
}

func (m *EventPrintEdition) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.MetadataId)
	if l > 0 {
		n += 1 + l + sovNft(uint64(l))
	}
	if m.Edition != 0 {
		n += 1 + sovNft(uint64(m.Edition))
	}
	return n
}

func (m *EventNFTTransfer) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.NftId)
	if l > 0 {
		n += 1 + l + sovNft(uint64(l))
	}
	l = len(m.Sender)
	if l > 0 {
		n += 1 + l + sovNft(uint64(l))
	}
	l = len(m.Receiver)
	if l > 0 {
		n += 1 + l + sovNft(uint64(l))
	}
	return n
}

func (m *EventMetadataSign) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Signer)
	if l > 0 {
		n += 1 + l + sovNft(uint64(l))
	}
	if m.MetadataId != 0 {
		n += 1 + sovNft(uint64(m.MetadataId))
	}
	return n
}

func (m *EventMetadataUpdate) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Updater)
	if l > 0 {
		n += 1 + l + sovNft(uint64(l))
	}
	if m.MetadataId != 0 {
		n += 1 + sovNft(uint64(m.MetadataId))
	}
	return n
}

func (m *EventMetadataAuthorityUpdate) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.MetadataId)
	if l > 0 {
		n += 1 + l + sovNft(uint64(l))
	}
	l = len(m.NewAuthority)
	if l > 0 {
		n += 1 + l + sovNft(uint64(l))
	}
	return n
}

func (m *EventMintAuthorityUpdate) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.MetadataId)
	if l > 0 {
		n += 1 + l + sovNft(uint64(l))
	}
	l = len(m.NewAuthority)
	if l > 0 {
		n += 1 + l + sovNft(uint64(l))
	}
	return n
}

func (m *EventCollectionCreation) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Creator)
	if l > 0 {
		n += 1 + l + sovNft(uint64(l))
	}
	if m.CollectionId != 0 {
		n += 1 + sovNft(uint64(m.CollectionId))
	}
	return n
}

func (m *EventCollectionVerification) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Verifier)
	if l > 0 {
		n += 1 + l + sovNft(uint64(l))
	}
	if m.CollectionId != 0 {
		n += 1 + sovNft(uint64(m.CollectionId))
	}
	l = len(m.NftId)
	if l > 0 {
		n += 1 + l + sovNft(uint64(l))
	}
	return n
}

func (m *EventCollectionUnverification) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Verifier)
	if l > 0 {
		n += 1 + l + sovNft(uint64(l))
	}
	if m.CollectionId != 0 {
		n += 1 + sovNft(uint64(m.CollectionId))
	}
	l = len(m.NftId)
	if l > 0 {
		n += 1 + l + sovNft(uint64(l))
	}
	return n
}

func (m *EventUpdateCollectionAuthority) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.CollectionId != 0 {
		n += 1 + sovNft(uint64(m.CollectionId))
	}
	l = len(m.NewAuthority)
	if l > 0 {
		n += 1 + l + sovNft(uint64(l))
	}
	return n
}

func sovNft(x uint64) (n int) {
	return (math_bits.Len64(x|1) + 6) / 7
}
func sozNft(x uint64) (n int) {
	return sovNft(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (m *MasterEdition) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowNft
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MasterEdition: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MasterEdition: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Supply", wireType)
			}
			m.Supply = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNft
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Supply |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MaxSupply", wireType)
			}
			m.MaxSupply = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNft
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MaxSupply |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipNft(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthNft
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Metadata) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowNft
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Metadata: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Metadata: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			m.Id = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNft
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Id |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNft
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthNft
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthNft
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Uri", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNft
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthNft
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthNft
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Uri = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SellerFeeBasisPoints", wireType)
			}
			m.SellerFeeBasisPoints = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNft
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.SellerFeeBasisPoints |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field PrimarySaleHappened", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNft
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.PrimarySaleHappened = bool(v != 0)
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IsMutable", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNft
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.IsMutable = bool(v != 0)
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Creators", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNft
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthNft
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthNft
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Creators = append(m.Creators, Creator{})
			if err := m.Creators[len(m.Creators)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MetadataAuthority", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNft
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthNft
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthNft
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.MetadataAuthority = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MintAuthority", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNft
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthNft
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthNft
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.MintAuthority = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 10:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MasterEdition", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNft
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthNft
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthNft
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.MasterEdition == nil {
				m.MasterEdition = &MasterEdition{}
			}
			if err := m.MasterEdition.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipNft(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthNft
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Collection) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowNft
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Collection: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Collection: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			m.Id = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNft
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Id |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Symbol", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNft
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthNft
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthNft
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Symbol = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNft
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthNft
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthNft
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Uri", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNft
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthNft
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthNft
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Uri = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IsMutable", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNft
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.IsMutable = bool(v != 0)
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field UpdateAuthority", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNft
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthNft
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthNft
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.UpdateAuthority = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipNft(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthNft
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Creator) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowNft
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Creator: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Creator: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Address", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNft
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthNft
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthNft
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Address = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Verified", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNft
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Verified = bool(v != 0)
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Share", wireType)
			}
			m.Share = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNft
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Share |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipNft(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthNft
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *NFT) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowNft
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: NFT: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: NFT: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CollId", wireType)
			}
			m.CollId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNft
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.CollId |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MetadataId", wireType)
			}
			m.MetadataId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNft
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MetadataId |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Seq", wireType)
			}
			m.Seq = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNft
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Seq |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Owner", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNft
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthNft
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthNft
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Owner = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipNft(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthNft
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Params) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowNft
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Params: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Params: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field IssuePrice", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNft
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthNft
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthNft
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.IssuePrice.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipNft(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthNft
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *EventMetadataCreation) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowNft
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: EventMetadataCreation: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: EventMetadataCreation: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Creator", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNft
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthNft
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthNft
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Creator = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MetadataId", wireType)
			}
			m.MetadataId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNft
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MetadataId |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipNft(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthNft
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *EventNFTCreation) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowNft
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: EventNFTCreation: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: EventNFTCreation: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Creator", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNft
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthNft
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthNft
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Creator = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field NftId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNft
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthNft
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthNft
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.NftId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipNft(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthNft
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *EventPrintEdition) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowNft
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: EventPrintEdition: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: EventPrintEdition: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MetadataId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNft
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthNft
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthNft
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.MetadataId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Edition", wireType)
			}
			m.Edition = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNft
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Edition |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipNft(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthNft
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *EventNFTTransfer) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowNft
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: EventNFTTransfer: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: EventNFTTransfer: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field NftId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNft
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthNft
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthNft
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.NftId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Sender", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNft
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthNft
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthNft
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Sender = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Receiver", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNft
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthNft
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthNft
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Receiver = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipNft(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthNft
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *EventMetadataSign) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowNft
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: EventMetadataSign: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: EventMetadataSign: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Signer", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNft
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthNft
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthNft
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Signer = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MetadataId", wireType)
			}
			m.MetadataId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNft
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MetadataId |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipNft(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthNft
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *EventMetadataUpdate) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowNft
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: EventMetadataUpdate: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: EventMetadataUpdate: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Updater", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNft
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthNft
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthNft
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Updater = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MetadataId", wireType)
			}
			m.MetadataId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNft
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MetadataId |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipNft(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthNft
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *EventMetadataAuthorityUpdate) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowNft
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: EventMetadataAuthorityUpdate: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: EventMetadataAuthorityUpdate: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MetadataId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNft
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthNft
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthNft
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.MetadataId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field NewAuthority", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNft
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthNft
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthNft
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.NewAuthority = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipNft(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthNft
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *EventMintAuthorityUpdate) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowNft
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: EventMintAuthorityUpdate: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: EventMintAuthorityUpdate: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MetadataId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNft
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthNft
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthNft
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.MetadataId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field NewAuthority", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNft
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthNft
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthNft
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.NewAuthority = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipNft(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthNft
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *EventCollectionCreation) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowNft
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: EventCollectionCreation: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: EventCollectionCreation: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Creator", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNft
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthNft
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthNft
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Creator = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CollectionId", wireType)
			}
			m.CollectionId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNft
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.CollectionId |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipNft(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthNft
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *EventCollectionVerification) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowNft
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: EventCollectionVerification: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: EventCollectionVerification: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Verifier", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNft
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthNft
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthNft
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Verifier = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CollectionId", wireType)
			}
			m.CollectionId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNft
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.CollectionId |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field NftId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNft
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthNft
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthNft
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.NftId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipNft(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthNft
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *EventCollectionUnverification) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowNft
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: EventCollectionUnverification: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: EventCollectionUnverification: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Verifier", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNft
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthNft
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthNft
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Verifier = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CollectionId", wireType)
			}
			m.CollectionId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNft
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.CollectionId |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field NftId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNft
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthNft
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthNft
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.NftId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipNft(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthNft
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *EventUpdateCollectionAuthority) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowNft
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: EventUpdateCollectionAuthority: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: EventUpdateCollectionAuthority: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CollectionId", wireType)
			}
			m.CollectionId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNft
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.CollectionId |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field NewAuthority", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNft
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthNft
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthNft
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.NewAuthority = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipNft(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthNft
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipNft(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	depth := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowNft
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowNft
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
		case 1:
			iNdEx += 8
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowNft
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if length < 0 {
				return 0, ErrInvalidLengthNft
			}
			iNdEx += length
		case 3:
			depth++
		case 4:
			if depth == 0 {
				return 0, ErrUnexpectedEndOfGroupNft
			}
			depth--
		case 5:
			iNdEx += 4
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
		if iNdEx < 0 {
			return 0, ErrInvalidLengthNft
		}
		if depth == 0 {
			return iNdEx, nil
		}
	}
	return 0, io.ErrUnexpectedEOF
}

var (
	ErrInvalidLengthNft        = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowNft          = fmt.Errorf("proto: integer overflow")
	ErrUnexpectedEndOfGroupNft = fmt.Errorf("proto: unexpected end of group")
)
